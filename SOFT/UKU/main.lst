L 1 "main.c"
N//Базовая ветка
N//#define SC16IS740_UART
N
N#ifdef UKU2071x
N#define can1_out mcp2515_transmit
N#endif
N
N
N#include "lcd_AGM1232_uku207_3.h"
L 1 "lcd_AGM1232_uku207_3.h" 1
N#ifndef _LCD_AGM1232_UKU203_H_
N
N#define _LCD_AGM1232_UKU203_H_
N
N
N#define A0	18
N#define E1	19
N#define E2	20
N#define RW     21
N
N#define D0     22
N#define D1     D0+1
N#define D2     D1+1
N#define D3     D2+1
N#define D4     D3+1
N#define D5     D4+1
N#define D6     D5+1
N#define D7     D6+1
N
N#define RES	30
N
N
N#define _RESET_				226
N#define _DISPLAY_ON_             	175
N#define _DISPLAY_OFF_            	174
N#define _SET_PAGE_               	184
N#define _SET_COLUMN_             	0
N#define _SET_RAW_             	0xc0
N#define _SET_DISPLAY_START_LINE_ 	192
N#define Max_Col		60
N#define Max_page 		3   
N
N
Nvoid lcd1_chk(void);
Nvoid lcd1_wr(char in);
Nvoid lcd2_chk(void);
Nvoid lcd2_wr(char in);
Nchar data1_wr(char in);
Nvoid data2_wr(char in);
Nvoid lcd_set_page(char in);
Nvoid lcd_set_col(char in);
Nvoid lcd_set_raw(char in);
Nvoid lcd_init(void);
Nvoid status(void);
Nvoid delay(void);
Nvoid ltstrobe(char in);
Nvoid lcd_init_(void);
Nvoid lcd_clear(void);
Nvoid lcd_on(void);
Nvoid lcd_off(void);
Nvoid lcd_out(char* adr);
N
N#endif
L 10 "main.c" 2
N#include "rtl.h"
L 1 "C:\Keil\ARM\RV31\INC\rtl.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - A P I 
N *----------------------------------------------------------------------------
N *      Name:    RTL.H 
N *      Purpose: Application Programming Interface. 
N *      Rev.:    V4.13
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2010 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __RTL_H__
N#define __RTL_H__
N
N/* RL-ARM version number. */
N#define __RL_ARM_VER    413
N 
N#define __task          __declspec(noreturn)
N
N#ifndef NULL
N #ifdef __cplusplus              // EC++
S  #define NULL          0
N #else
N  #define NULL          ((void *) 0)
N #endif
N#endif
N
N#ifndef EOF
N #define EOF            -1
N#endif
N
N#ifndef __size_t
N #define __size_t       1
N typedef unsigned int   size_t;
N#endif
N
Ntypedef signed char     S8;
Ntypedef unsigned char   U8;
Ntypedef short           S16;
Ntypedef unsigned short  U16;
Ntypedef int             S32;
Ntypedef unsigned int    U32;
Ntypedef long long       S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char   BIT;
Ntypedef unsigned int    BOOL;
N
N#ifndef __TRUE
N #define __TRUE         1
N#endif
N#ifndef __FALSE
N #define __FALSE        0
N#endif
N
N#ifdef __BIG_ENDIAN
S #define U32_LE(v) (__rev(v))
S #define U16_LE(v) (__rev(v) >> 16) 
S #define U32_BE(v)       (v)
S #define U16_BE(v)       (v)
N#else
N #define U32_BE(v) (__rev(v))
N #define U16_BE(v) (__rev(v) >> 16) 
N #define U32_LE(v)       (v)
N #define U16_LE(v)       (v)
N#endif
N
N/*----------------------------------------------------------------------------
N *                             RTX Kernel API
N *---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus               // EC++
Sextern "C"  {
N#endif
N
N/* Definition of Semaphore type */
Ntypedef U32 OS_SEM[2];
N
N/* Definition of Mailbox type */
N#define os_mbx_declare(name,cnt)    U32 name [4 + cnt]
Ntypedef U32 OS_MBX[];
N
N/* Definition of Mutex type */
Ntypedef U32 OS_MUT[3];
N
N/* Task Identification number. */
Ntypedef U32 OS_TID;
N
N/* Function return of system calls returning an object identification */
Ntypedef void *OS_ID;
N
N/* Function return of system calls indicating an event or completion state */
Ntypedef U32 OS_RESULT;
N
N/* Return codes */
N#define OS_R_TMO        0x01
N#define OS_R_EVT        0x02
N#define OS_R_SEM        0x03
N#define OS_R_MBX        0x04
N#define OS_R_MUT        0x05
N
N#define OS_R_OK         0x00
N#define OS_R_NOK        0xff
N
N#define OS_TCB_SIZE     48
N#define OS_TMR_SIZE     8
N
N/* Error Codes */
N#define OS_ERR_STK_OVF  1
N#define OS_ERR_FIFO_OVF 2
N#define OS_ERR_MBX_OVF  3
N
N#if !(defined(__TARGET_ARCH_6S_M) || defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X#if !(0L || 1L || 0L)
S
S/*----------------------------------------------------------------------------
S *      Functions ARM
S *---------------------------------------------------------------------------*/
S
S/* Task Management */
S#define os_sys_init(tsk)              os_sys_init0(tsk,0,NULL)
S#define os_sys_init_prio(tsk,prio)    os_sys_init0(tsk,prio,NULL)
S#define os_sys_init_user(tsk,prio,stk,size)                                   \
S                                      os_sys_init0(tsk,prio|(size<<8),stk)
X#define os_sys_init_user(tsk,prio,stk,size)                                                                         os_sys_init0(tsk,prio|(size<<8),stk)
S#define os_tsk_create(tsk,prio)       os_tsk_create0(tsk,prio,NULL,NULL)
S#define os_tsk_create_user(tsk,prio,stk,size)                                 \
S                                      os_tsk_create0(tsk,prio|(size<<8),stk,NULL)
X#define os_tsk_create_user(tsk,prio,stk,size)                                                                       os_tsk_create0(tsk,prio|(size<<8),stk,NULL)
S#define os_tsk_create_ex(tsk,prio,argv) os_tsk_create_ex0(tsk,prio,NULL,argv)
S#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                         \
S                                      os_tsk_create_ex0(tsk,prio|(size<<8),stk,argv)
X#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                                                               os_tsk_create_ex0(tsk,prio|(size<<8),stk,argv)
S#define os_tsk_delete_self()          os_tsk_delete(0)
S#define os_tsk_prio_self(prio)        os_tsk_prio(0,prio)
S#define isr_tsk_get()                 os_tsk_self()
S
Sextern void      os_sys_init0 (void (*task)(void), U32 prio_stksz, void *stk);
Sextern OS_TID    os_tsk_create0 (void (*task)(void), U32 prio_stksz, 
S                                 void *stk, void *argv);
Sextern OS_TID    os_tsk_create_ex0 (void (*task)(void *), U32 prio_stksz, 
S                                    void *stk, void *argv);
Sextern OS_TID    os_tsk_self (void);
Sextern void      os_tsk_pass (void);
Sextern OS_RESULT os_tsk_prio (OS_TID task_id, U8 new_prio);
Sextern OS_RESULT os_tsk_delete (OS_TID task_id);
S
S/* Event flag Management */
S#define os_evt_wait_or(wflags,tmo)      os_evt_wait(wflags,tmo,__FALSE)
S#define os_evt_wait_and(wflags,tmo)     os_evt_wait(wflags,tmo,__TRUE)
S
Sextern OS_RESULT os_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait);
Sextern void      os_evt_set (U16 event_flags, OS_TID task_id);
Sextern void      os_evt_clr (U16 clear_flags, OS_TID task_id);
Sextern void      isr_evt_set (U16 event_flags, OS_TID task_id);
Sextern U16       os_evt_get (void);
S
S/* Semaphore Management */
Sextern void      os_sem_init (OS_ID semaphore, U16 token_count);
Sextern OS_RESULT os_sem_send (OS_ID semaphore);
Sextern OS_RESULT os_sem_wait (OS_ID semaphore, U16 timeout);
Sextern void      isr_sem_send (OS_ID semaphore);
S
S/* Mailbox Management */
S#define isr_mbx_check(mbx)              os_mbx_check(mbx)
S
Sextern void      os_mbx_init (OS_ID mailbox, U16 mbx_size);
Sextern OS_RESULT os_mbx_send (OS_ID mailbox, void *message_ptr, U16 timeout);
Sextern OS_RESULT os_mbx_wait (OS_ID mailbox, void  **message, U16 timeout);
Sextern OS_RESULT os_mbx_check (OS_ID mailbox);
Sextern void      isr_mbx_send (OS_ID mailbox, void *message_ptr);
Sextern OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message);
S
S/* Mutex Management */
Sextern void      os_mut_init (OS_ID mutex);
Sextern OS_RESULT os_mut_release (OS_ID mutex);
Sextern OS_RESULT os_mut_wait (OS_ID mutex, U16 timeout);
S
S/* Time Management */
Sextern void      os_dly_wait (U16 delay_time);
Sextern void      os_itv_set (U16 interval_time);
Sextern void      os_itv_wait (void);
S
S/* User Timer Management */
Sextern OS_ID     os_tmr_create (U16 tcnt, U16 info);
Sextern OS_ID     os_tmr_kill (OS_ID timer);
S
S/* System Functions */
Sextern void      tsk_lock (void) __swi (5);
Sextern void      tsk_unlock (void);
S
S/* Fixed Memory Block Management Functions */
Sextern int       _init_box (void *box_mem, U32 box_size, U32 blk_size);
Sextern void     *_alloc_box (void *box_mem) __swi (1);
Sextern void     *_calloc_box (void *box_mem);
Sextern int       _free_box (void *box_mem, void *box) __swi (2);
S
N#else
N
N/*----------------------------------------------------------------------------
N *      Functions Cortex-M
N *---------------------------------------------------------------------------*/
N
N#define __SVC_0         __svc_indirect(0)
N
N/* Task Management */
Nextern void      os_set_env    (void);
Nextern void      rt_sys_init   (void (*task)(void), U8 priority, void *stk);
Nextern void      rt_tsk_pass   (void);
Nextern OS_TID    rt_tsk_self   (void);
Nextern OS_RESULT rt_tsk_prio   (OS_TID task_id, U8 new_prio);
Nextern OS_TID    rt_tsk_create (void (*task)(void), U8 priority, void *stk, void *argv);
Nextern OS_RESULT rt_tsk_delete (OS_TID task_id);
N
N#define os_sys_init(tsk)              os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,0,NULL)
X#define os_sys_init(tsk)              os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,0,NULL)
N#define os_sys_init_user(tsk,prio,stk,size)                                   \
N                                      os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,prio|(size<<8),stk)
X#define os_sys_init_user(tsk,prio,stk,size)                                                                         os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,prio|(size<<8),stk)
N#define os_sys_init_prio(tsk,prio)    os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,prio,NULL)
X#define os_sys_init_prio(tsk,prio)    os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,prio,NULL)
N#define os_tsk_create(tsk,prio)       _os_tsk_create((U32)rt_tsk_create,tsk,prio,NULL,NULL)
N#define os_tsk_create_user(tsk,prio,stk,size)                                 \
N                                      _os_tsk_create((U32)rt_tsk_create,tsk,prio|(size<<8),stk,NULL)
X#define os_tsk_create_user(tsk,prio,stk,size)                                                                       _os_tsk_create((U32)rt_tsk_create,tsk,prio|(size<<8),stk,NULL)
N#define os_tsk_create_ex(tsk,prio,argv) _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio,NULL,argv)
N#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                         \
N                                      _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio|(size<<8),stk,argv)
X#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                                                               _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio|(size<<8),stk,argv)
N#define os_tsk_self()                 _os_tsk_self((U32)rt_tsk_self)
N#define os_tsk_pass()                 _os_tsk_pass((U32)rt_tsk_pass)
N#define os_tsk_prio(task_id,new_prio) _os_tsk_prio((U32)rt_tsk_prio,task_id,new_prio)
N#define os_tsk_prio_self(prio)        _os_tsk_prio((U32)rt_tsk_prio,0,prio)
N#define os_tsk_delete(task_id)        _os_tsk_delete((U32)rt_tsk_delete,task_id)
N#define os_tsk_delete_self()          _os_tsk_delete((U32)rt_tsk_delete, 0)
N#define isr_tsk_get()                 rt_tsk_self()
N
Nextern void      _os_sys_init(U32 p, void (*task)(void), U32 prio_stksz,
N                                     void *stk)                        __SVC_0;
X                                     void *stk)                        __svc_indirect(0);
Nextern OS_TID    _os_tsk_create (U32 p, void (*task)(void), U32 prio_stksz,
N                                        void *stk, void *argv)         __SVC_0;
X                                        void *stk, void *argv)         __svc_indirect(0);
Nextern OS_TID    _os_tsk_create_ex (U32 p, void (*task)(void *), U32 prio_stksz,
N                                           void *stk, void *argv)      __SVC_0;
X                                           void *stk, void *argv)      __svc_indirect(0);
Nextern OS_TID    _os_tsk_self (U32 p)                                  __SVC_0;
Xextern OS_TID    _os_tsk_self (U32 p)                                  __svc_indirect(0);
Nextern void      _os_tsk_pass (U32 p)                                  __SVC_0;
Xextern void      _os_tsk_pass (U32 p)                                  __svc_indirect(0);
Nextern OS_RESULT _os_tsk_prio (U32 p, OS_TID task_id, U8 new_prio)     __SVC_0;
Xextern OS_RESULT _os_tsk_prio (U32 p, OS_TID task_id, U8 new_prio)     __svc_indirect(0);
Nextern OS_RESULT _os_tsk_delete (U32 p, OS_TID task_id)                __SVC_0;
Xextern OS_RESULT _os_tsk_delete (U32 p, OS_TID task_id)                __svc_indirect(0);
N
N/* Event flag Management */
Nextern OS_RESULT rt_evt_wait (U16 wait_flags,  U16 timeout, BOOL and_wait);
Nextern void      rt_evt_set  (U16 event_flags, OS_TID task_id);
Nextern void      rt_evt_clr  (U16 clear_flags, OS_TID task_id);
Nextern U16       rt_evt_get  (void);
N
N#define os_evt_wait_or(wflags,tmo)    _os_evt_wait((U32)rt_evt_wait,wflags,tmo,__FALSE)
N#define os_evt_wait_and(wflags,tmo)   _os_evt_wait((U32)rt_evt_wait,wflags,tmo,__TRUE)
N#define os_evt_set(evt_flags,task_id) _os_evt_set((U32)rt_evt_set,evt_flags,task_id)
N#define os_evt_clr(clr_flags,task_id) _os_evt_clr((U32)rt_evt_clr,clr_flags,task_id)
N#define os_evt_get()                  _os_evt_get((U32)rt_evt_get)
N
Nextern OS_RESULT _os_evt_wait(U32 p, U16 wait_flags, U16 timeout,
N                                     BOOL and_wait)                    __SVC_0;
X                                     BOOL and_wait)                    __svc_indirect(0);
Nextern void      _os_evt_set (U32 p, U16 event_flags, OS_TID task_id)  __SVC_0;
Xextern void      _os_evt_set (U32 p, U16 event_flags, OS_TID task_id)  __svc_indirect(0);
Nextern void      _os_evt_clr (U32 p, U16 clear_flags, OS_TID task_id)  __SVC_0;
Xextern void      _os_evt_clr (U32 p, U16 clear_flags, OS_TID task_id)  __svc_indirect(0);
Nextern U16       _os_evt_get (U32 p)                                   __SVC_0;
Xextern U16       _os_evt_get (U32 p)                                   __svc_indirect(0);
Nextern void      isr_evt_set (U16 event_flags, OS_TID task_id);
N
N/* Semaphore Management */
Nextern void      rt_sem_init (OS_ID semaphore, U16 token_count);
Nextern OS_RESULT rt_sem_send (OS_ID semaphore);
Nextern OS_RESULT rt_sem_wait (OS_ID semaphore, U16 timeout);
N
N#define os_sem_init(sem,t_count)     _os_sem_init((U32)rt_sem_init,sem,t_count)
N#define os_sem_send(sem)             _os_sem_send((U32)rt_sem_send,sem)
N#define os_sem_wait(sem,tmo)         _os_sem_wait((U32)rt_sem_wait,sem,tmo)
N
Nextern void      _os_sem_init (U32 p, OS_ID semaphore, 
N                                      U16 token_count)                 __SVC_0;
X                                      U16 token_count)                 __svc_indirect(0);
Nextern OS_RESULT _os_sem_send (U32 p, OS_ID semaphore)                 __SVC_0;
Xextern OS_RESULT _os_sem_send (U32 p, OS_ID semaphore)                 __svc_indirect(0);
Nextern OS_RESULT _os_sem_wait (U32 p, OS_ID semaphore, U16 timeout)    __SVC_0;
Xextern OS_RESULT _os_sem_wait (U32 p, OS_ID semaphore, U16 timeout)    __svc_indirect(0);
Nextern void      isr_sem_send (OS_ID semaphore);
N
N/* Mailbox Management */
Nextern void      rt_mbx_init  (OS_ID mailbox, U16 mbx_size);
Nextern OS_RESULT rt_mbx_send  (OS_ID mailbox, void *p_msg,    U16 timeout);
Nextern OS_RESULT rt_mbx_wait  (OS_ID mailbox, void **message, U16 timeout);
Nextern OS_RESULT rt_mbx_check (OS_ID mailbox);
N
N#define os_mbx_init(mbx,mbx_size)     _os_mbx_init((U32)rt_mbx_init,mbx,mbx_size)
N#define os_mbx_send(mbx,p_msg,tmo)    _os_mbx_send((U32)rt_mbx_send,mbx,p_msg,tmo)
N#define os_mbx_wait(mbx,message,tmo)  _os_mbx_wait((U32)rt_mbx_wait,mbx,message,tmo)
N#define os_mbx_check(mbx)             _os_mbx_check((U32)rt_mbx_check,mbx)
N#define isr_mbx_check(mbx)            rt_mbx_check(mbx)
N
Nextern void      _os_mbx_init (U32 p, OS_ID mailbox, U16 mbx_size)     __SVC_0;
Xextern void      _os_mbx_init (U32 p, OS_ID mailbox, U16 mbx_size)     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_send (U32 p, OS_ID mailbox, void *message_ptr,
N                                      U16 timeout)                     __SVC_0;
X                                      U16 timeout)                     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_wait (U32 p, OS_ID mailbox, void  **message,
N                                      U16 timeout)                     __SVC_0;
X                                      U16 timeout)                     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_check (U32 p, OS_ID mailbox)                  __SVC_0;
Xextern OS_RESULT _os_mbx_check (U32 p, OS_ID mailbox)                  __svc_indirect(0);
Nextern void      isr_mbx_send (OS_ID mailbox, void *message_ptr);
Nextern OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message);
N
N/* Mutex Management */
Nextern void      rt_mut_init    (OS_ID mutex);
Nextern OS_RESULT rt_mut_release (OS_ID mutex);
Nextern OS_RESULT rt_mut_wait    (OS_ID mutex, U16 timeout);
N
N#define os_mut_init(mutex)         _os_mut_init((U32)rt_mut_init,mutex)
N#define os_mut_release(mutex)      _os_mut_release((U32)rt_mut_release,mutex)
N#define os_mut_wait(mutex,timeout) _os_mut_wait((U32)rt_mut_wait,mutex,timeout)
N
Nextern void      _os_mut_init (U32 p, OS_ID mutex)                     __SVC_0;
Xextern void      _os_mut_init (U32 p, OS_ID mutex)                     __svc_indirect(0);
Nextern OS_RESULT _os_mut_release (U32 p, OS_ID mutex)                  __SVC_0;
Xextern OS_RESULT _os_mut_release (U32 p, OS_ID mutex)                  __svc_indirect(0);
Nextern OS_RESULT _os_mut_wait (U32 p, OS_ID mutex, U16 timeout)        __SVC_0;
Xextern OS_RESULT _os_mut_wait (U32 p, OS_ID mutex, U16 timeout)        __svc_indirect(0);
N
N/* Time Management */
Nextern void      rt_dly_wait (U16 delay_time);
Nextern void      rt_itv_set  (U16 interval_time);
Nextern void      rt_itv_wait (void);
N
N#define os_dly_wait(delay_time)    _os_dly_wait((U32)rt_dly_wait,delay_time)
N#define os_itv_set(interval_time)  _os_itv_set((U32)rt_itv_set,interval_time)
N#define os_itv_wait()              _os_itv_wait((U32)rt_itv_wait)
N
Nextern void      _os_dly_wait (U32 p, U16 delay_time)                  __SVC_0;
Xextern void      _os_dly_wait (U32 p, U16 delay_time)                  __svc_indirect(0);
Nextern void      _os_itv_set (U32 p, U16 interval_time)                __SVC_0;
Xextern void      _os_itv_set (U32 p, U16 interval_time)                __svc_indirect(0);
Nextern void      _os_itv_wait (U32 p)                                  __SVC_0;
Xextern void      _os_itv_wait (U32 p)                                  __svc_indirect(0);
N
N/* User Timer Management */
Nextern OS_ID     rt_tmr_create (U16 tcnt, U16 info);
Nextern OS_ID     rt_tmr_kill   (OS_ID timer);
N
N#define os_tmr_create(tcnt,info)   _os_tmr_create((U32)rt_tmr_create,tcnt,info)
N#define os_tmr_kill(timer)         _os_tmr_kill((U32)rt_tmr_kill,timer)
N
Nextern OS_ID     _os_tmr_create (U32 p, U16 tcnt, U16 info)            __SVC_0;
Xextern OS_ID     _os_tmr_create (U32 p, U16 tcnt, U16 info)            __svc_indirect(0);
Nextern OS_ID     _os_tmr_kill (U32 p, OS_ID timer)                     __SVC_0;
Xextern OS_ID     _os_tmr_kill (U32 p, OS_ID timer)                     __svc_indirect(0);
N
N/* System Functions */
Nextern void      rt_tsk_lock   (void);
Nextern void      rt_tsk_unlock (void);
N
N#define tsk_lock()                 _os_tsk_lock((U32)rt_tsk_lock)
N#define tsk_unlock()               _os_tsk_unlock((U32)rt_tsk_unlock)
N
Nextern void      _os_tsk_lock (U32 p)                                  __SVC_0;
Xextern void      _os_tsk_lock (U32 p)                                  __svc_indirect(0);
Nextern void      _os_tsk_unlock (U32 p)                                __SVC_0;
Xextern void      _os_tsk_unlock (U32 p)                                __svc_indirect(0);
N
N/* Fixed Memory Block Management Functions */
Nextern int       _init_box (void *box_mem, U32 box_size, U32 blk_size);
Nextern void     *_alloc_box (void *box_mem);
Nextern void     *_calloc_box (void *box_mem);
Nextern int       _free_box (void *box_mem, void *box);
N
N#endif
N
N#define BOX_ALIGN_8     0x80000000
N#define _declare_box(pool,size,cnt)   U32 pool[(((size)+3)/4)*(cnt) + 3]
N#define _declare_box8(pool,size,cnt)  U64 pool[(((size)+7)/8)*(cnt) + 2]
N#define _init_box8(pool,size,bsize)   _init_box (pool,size,bsize | BOX_ALIGN_8)
N
N/* For compatibility with older configurations.*/
N#define os_stk_overflow         os_error
N
N/*----------------------------------------------------------------------------
N *                        Flash File System API
N *---------------------------------------------------------------------------*/
N
Ntypedef struct {                        /* RL Time format (FFS, TCPnet)      */
N  U8  hr;                               /* Hours    [0..23]                  */
N  U8  min;                              /* Minutes  [0..59]                  */
N  U8  sec;                              /* Seconds  [0..59]                  */
N  U8  day;                              /* Day      [1..31]                  */
N  U8  mon;                              /* Month    [1..12]                  */
N  U16 year;                             /* Year     [1980..2107]             */
N} RL_TIME;
N
Ntypedef struct {                        /* Search info record                */
N  S8  name[256];                        /* Name                              */
N  U32 size;                             /* File size in bytes                */
N  U16 fileID;                           /* System Identification             */
N  U8  attrib;                           /* Attributes                        */
N  RL_TIME time;                         /* Create/Modify Time                */
N} FINFO;
N
Nextern int finit (void);
Nextern int fdelete (const char *filename);
Nextern int frename (const char *oldname, const char *newname);
Nextern int ffind (const char *pattern, FINFO *info);
Nextern U64 ffree (const char *drive);
Nextern int fformat (const char *drive);
Nextern int fanalyse (const char *drive);
Nextern int fcheck (const char *drive);
Nextern int fdefrag (const char *drive);
N
N/* The following macros provide for common functions */
N#define unlink(fn)      fdelete(fn);
N
N/*----------------------------------------------------------------------------
N *                             TCPnet API
N *---------------------------------------------------------------------------*/
N
N/* UDP Options */
N#define UDP_OPT_SEND_CS    0x01   /* Calculate Checksum for UDP send frames  */
N#define UDP_OPT_CHK_CS     0x02   /* Verify Checksum for received UDP frames */
N
N/* TCP Socket Types */
N#define TCP_TYPE_SERVER    0x01   /* Socket Type Server (open for listening) */
N#define TCP_TYPE_CLIENT    0x02   /* Socket Type Client (initiate connect)   */
N#define TCP_TYPE_DELAY_ACK 0x04   /* Socket Type Delayed Acknowledge         */
N#define TCP_TYPE_FLOW_CTRL 0x08   /* Socket Type Flow Control                */
N#define TCP_TYPE_CLIENT_SERVER (TCP_TYPE_SERVER | TCP_TYPE_CLIENT)
N
N/* TCP Callback Events */
N#define TCP_EVT_CONREQ     0      /* Connect request received event          */
N#define TCP_EVT_CONNECT    1      /* Connection established event            */
N#define TCP_EVT_CLOSE      2      /* Connection was properly closed          */
N#define TCP_EVT_ABORT      3      /* Connection is for some reason aborted   */
N#define TCP_EVT_ACK        4      /* Previously send data acknowledged       */
N#define TCP_EVT_DATA       5      /* Data received event                     */
N
N/* TCP States */
N#define TCP_STATE_FREE     0      /* Entry is free and unused                */
N#define TCP_STATE_CLOSED   1      /* Entry allocated, socket still closed    */
N#define TCP_STATE_LISTEN   2      /* Socket waiting for incoming connection  */
N#define TCP_STATE_SYN_REC  3      /* SYN frame received                      */
N#define TCP_STATE_SYN_SENT 4      /* SYN packet sent to establish a connect. */
N#define TCP_STATE_FINW1    5      /* Tcp_close started FIN packet was sent   */
N#define TCP_STATE_FINW2    6      /* Our FIN ack-ed, waiting for remote FIN  */
N#define TCP_STATE_CLOSING  7      /* Received FIN independently of our FIN   */
N#define TCP_STATE_LAST_ACK 8      /* Waiting for last ACK for our FIN        */
N#define TCP_STATE_TWAIT    9      /* Timed waiting for 2MSL                  */
N#define TCP_STATE_CONNECT  10     /* TCP Connection established              */
N
N/* DNS Callback Events */
N#define DNS_EVT_SUCCESS    0      /* Host name successfully resolved         */
N#define DNS_EVT_NONAME     1      /* DNS Error, no such name                 */
N#define DNS_EVT_TIMEOUT    2      /* Timeout resolving host                  */
N#define DNS_EVT_ERROR      3      /* Erroneous response packet               */
N
N/* DNS 'get_host_by_name()' result codes */
N#define DNS_RES_OK         0      /* Function finished OK                    */
N#define DNS_ERROR_BUSY     1      /* DNS Client busy, can't process request  */
N#define DNS_ERROR_LABEL    2      /* Host name Label too long                */
N#define DNS_ERROR_NAME     3      /* Host name loo long                      */
N#define DNS_ERROR_NOSRV    4      /* Prim. DNS server not specified (0.0.0.0)*/
N#define DNS_ERROR_UDPSEND  5      /* UDP Send frame error                    */
N
N/* SMTP Callback Events */
N#define SMTP_EVT_SUCCESS   0      /* Email successfully sent                 */
N#define SMTP_EVT_TIMEOUT   1      /* Timeout sending email                   */
N#define SMTP_EVT_ERROR     2      /* Error when sending email                */
N
N/* ARP Cache Entry types */
N#define ARP_FIXED_IP       0      /* Fixed IP adrs is refreshed after tout   */
N#define ARP_TEMP_IP        1      /* Temp adrs is removed after timeout      */
N
Nextern void init_TcpNet (void);
Nextern void main_TcpNet (void);
Nextern void timer_tick (void);
Nextern U8   udp_get_socket (U8 tos, U8 opt, 
N                            U16 (*listener)(U8 socket, U8 *remip, U16 port, U8 *buf, U16 len));
Nextern BOOL udp_release_socket (U8 socket);
Nextern BOOL udp_open (U8 socket, U16 locport);
Nextern BOOL udp_close (U8 socket);
Nextern BOOL udp_mcast_ttl (U8 socket, U8 ttl);
Nextern U8  *udp_get_buf (U16 size);
Nextern BOOL udp_send (U8 socket, U8 *remip, U16 remport, U8 *buf, U16 dlen);
Nextern U8   tcp_get_socket (U8 type, U8 tos, U16 tout,
N                            U16 (*listener)(U8 socket, U8 event, U8 *buf, U16 len));
Nextern BOOL tcp_release_socket (U8 socket);
Nextern BOOL tcp_listen (U8 socket, U16 locport);
Nextern BOOL tcp_connect (U8 socket, U8 *remip, U16 remport, U16 locport);
Nextern U8  *tcp_get_buf (U16 size);
Nextern U16  tcp_max_dsize (U8 socket);
Nextern BOOL tcp_check_send (U8 socket);
Nextern U8   tcp_get_state (U8 socket);
Nextern BOOL tcp_send (U8 socket, U8 *buf, U16 dlen);
Nextern BOOL tcp_close (U8 socket);
Nextern BOOL tcp_abort (U8 socket);
Nextern void tcp_reset_window (U8 socket);
Nextern BOOL arp_cache_ip (U8 *ipadr, U8 type);
Nextern void ppp_listen (char const *user, char const *passw);
Nextern void ppp_connect (char const *dialnum, char const *user, char const *passw);
Nextern void ppp_close (void);
Nextern BOOL ppp_is_up (void);
Nextern void slip_listen (void);
Nextern void slip_connect (char const *dialnum);
Nextern void slip_close (void);
Nextern BOOL slip_is_up (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8 event, U8 *host_ip));
Nextern BOOL smtp_connect (U8 *ipadr, U16 port, void (*cbfunc)(U8 event));
Nextern void dhcp_disable (void);
Nextern BOOL igmp_join (U8 *group_ip);
Nextern BOOL igmp_leave (U8 *group_ip);
Nextern BOOL snmp_trap (U8 *manager_ip, U8 gen_trap, U8 spec_trap, U16 *obj_list);
Nextern BOOL snmp_set_community (const char *community);
N#ifdef __cplusplus               // EC++
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N  
N#endif
N 
L 11 "main.c" 2
N#include "type.h"
L 1 "type.h" 1
N/*****************************************************************************
N *   type.h:  Type definition Header file for NXP LPC17xx Family 
N *   Microprocessors
N *
N *   Copyright(C) 2009, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2009.05.25  ver 1.00    Prelimnary version, first Release
N *
N******************************************************************************/
N#include <stdint.h>
L 1 "C:\Keil\ARM\RV31\INC\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 13 "type.h" 2
N
N#ifndef __TYPE_H__
N#define __TYPE_H__
N
N#ifndef NULL
S#define NULL    ((void *)0)
N#endif
N
N#ifndef FALSE
N#define FALSE   (0)
N#endif
N
N#ifndef TRUE
N#define TRUE    (1)
N#endif
N
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N
N#endif  /* __TYPE_H__ */
L 12 "main.c" 2
N#include "main.h"
L 1 "main.h" 1
N#include <rtl.h>
N
N#ifdef UKU_TELECORE2016
S#define UKU_TELECORE2015
S#define UKU2071x
N#endif
N
N#ifdef UKU2071x
N#define MCP2515_CAN
N#define SC16IS740_UART
N//#define can1_out mcp2515_transmit
N#endif
N
N#define SOFT_NUM	1051
N#define SOFT_DATE	21112UL
N
N#define _ACDC_
N
N//#define _IPS_	100
N
N#define NUM_OF_SET_TABL	2
N#define DEEP_OF_SET_TABL 19
N
N#define CONTROL_BYTE_FOR_XPORT 0
N
N#define MINIM_INV_ADRESS	20
N//-минималный адрес инвертора в кановской сети, не может быть меньше 16
N#define MAX_NET_ADRESS		31
N//-максимальный адрес устройства в кановской сети ИБЭПа
N
N#define BIN__N(x) (x) | x>>3 | x>>6 | x>>9
N#define BIN__B(x) (x) & 0xf | (x)>>12 & 0xf0
N#define BIN8(v) (BIN__B(BIN__N(0x##v)))
N
N#ifndef UKU_KONTUR
N#define OID_ENTERPRISE 	OID0(1,3), 6, 1, 4, 1, 130, 131, 31
N#endif
N#ifdef UKU_KONTUR
S#define OID_ENTERPRISE 	OID0(1,3), 6, 1, 4, 1, 130, 167, 60
N#endif
N
N#ifndef UKU_KONTUR
N
N#define OID_DEVICE 		14
N
N#define DISPLAY_DEVICE_INFO			1
N#define DISPLAY_DEVICE_INFO_CODE			1
N#define DISPLAY_DEVICE_INFO_SERIAL			2
N#define DISPLAY_DEVICE_INFO_LOCATION 		3
N#define DISPLAY_DEVICE_INFO_NUMOFBAT 		4
N#define DISPLAY_DEVICE_INFO_NUMOFBPS 		5
N#define DISPLAY_DEVICE_INFO_NUMOFINV 		6
N#define DISPLAY_DEVICE_INFO_NUMOFAVT 		7
N#define DISPLAY_DEVICE_INFO_NUMOFDT 		8
N#define DISPLAY_DEVICE_INFO_NUMOFSK 		9
N#define DISPLAY_DEVICE_INFO_NUMOFEVENTS		10
N#define DISPLAY_DEVICE_INFO_MODEL_NAME		11
N
N#define DISPLAY_MAINS_POWER			2
N#define DISPLAY_MAINS_POWER_VOLTAGE		1
N#define DISPLAY_MAINS_POWER_FREQUENCY		2
N#define DISPLAY_MAINS_POWER_STATUS			3
N#define DISPLAY_MAINS_POWER_ALARM			4
N#define DISPLAY_MAINS_POWER_VOLTAGE_PHASEA	5
N#define DISPLAY_MAINS_POWER_VOLTAGE_PHASEB	6
N#define DISPLAY_MAINS_POWER_VOLTAGE_PHASEC	7
N
N
N#define DISPLAY_LOAD				3
N#define DISPLAY_LOAD_VOLTAGE				1
N#define DISPLAY_LOAD_CURRENT				2
N
N#define DISPLAY_PSU					4
N#define DISPLAY_PSU_ENTRY_NUMBER			1,1
N#define DISPLAY_PSU_ENTRY_VOLTAGE 			1,2
N#define DISPLAY_PSU_ENTRY_CURRENT			1,3
N#define DISPLAY_PSU_ENTRY_TEMPERATURE		1,4
N#define DISPLAY_PSU_ENTRY_STATUS			1,5
N#define DISPLAY_PSU_ENTRY_VENTRESURS		1,6
N
N#define DISPLAY_BAT					5
N#define DISPLAY_BAT_NUMBER				1,1
N#define DISPLAY_BAT_VOLTAGE				1,2
N#define DISPLAY_BAT_CURRENT				1,3
N#define DISPLAY_BAT_TEMPERATURE			1,4
N#define DISPLAY_BAT_CAPACITY				1,5
N#define DISPLAY_BAT_CHARGE				1,6
N#define DISPLAY_BAT_STATUS				1,7
N
N#define DISPLAY_SPEC				6
N#define DISPLAY_SPEC_STAT				1
N#define DISPLAY_SPEC_COMMAND				2
N
N#define DISPLAY_SPEC_TRAP_MESSAGE			5
N#define DISPLAY_SPEC_TRAP_VALUE_0			6
N#define DISPLAY_SPEC_TRAP_VALUE_1			7
N#define DISPLAY_SPEC_TRAP_VALUE_2			8
N
N
N#define DISPLAY_INV					14
N#define DISPLAY_INV_ENTRY_NUMBER			1,1
N#define DISPLAY_INV_ENTRY_VOLTAGE 			1,2
N#define DISPLAY_INV_ENTRY_CURRENT			1,3
N#define DISPLAY_INV_ENTRY_TEMPERATURE		1,4
N#define DISPLAY_INV_ENTRY_STATUS			1,5
N
N#define LCD_SIZE 200
N
N#define SNMP_COMMAND				8
N#define COMMAND_ANSWER					1
N#define COMMAND_PARAMETR					2
N
N#define SYSPARAMS					10
N#define SYSPARAMSSOUNDALARMEN				1
N#define SYSPARAMSALARMAUTODISABLE			2
N#define SYSPARAMS_BAT_TEST_TIME			3
N#define SYSPARAMS_U_MAX					4
N#define SYSPARAMS_U_MIN					5
N#define SYSPARAMS_U_0_GRAD				6
N#define SYSPARAMS_U_20_GRAD				7 
N#define SYSPARAMS_U_SIGN					8
N#define SYSPARAMS_U_MIN_POWER				9
N#define SYSPARAMS_U_WITHOUT_BAT			10
N#define SYSPARAMS_IBK					11
N#define SYSPARAMS_IZMAX					12
N#define SYSPARAMS_IMAX					13
N#define SYSPARAMS_IMIN					14
N#define SYSPARAMS_UVZ					15
N#define SYSPARAMS_TZAS					16
N#define SYSPARAMS_TSIGN_BAT				17
N#define SYSPARAMS_TMAX_BAT				18
N#define SYSPARAMS_TSIGN_BPS				19
N#define SYSPARAMS_TMAX_BPS				20	
N#define SYSPARAMS_BAT_PART_ALARM			21
N#define SYSPARAMS_POWER_CNT_ADRESS			22	
N
N#define DISPLAY_AVT					11
N#define DISPLAY_AVT_ENTRY_NUMBER			1,1
N#define DISPLAY_AVT_ENTRY_STAT 			1,2
N
N#define DISPLAY_ENERGY				12
N#define DISPLAY_ENERGY_VVOD_PHASE_A		1
N#define DISPLAY_ENERGY_VVOD_PHASE_B		2
N#define DISPLAY_ENERGY_VVOD_PHASE_C		3
N#define DISPLAY_ENERGY_PES_PHASE_A			4
N#define DISPLAY_ENERGY_PES_PHASE_B			5
N#define DISPLAY_ENERGY_PES_PHASE_C			6
N#define DISPLAY_ENERGY_TOTAL_ENERGY			7
N#define DISPLAY_ENERGY_CURRENT_ENERGY		8
N#define DISPLAY_ENERGY_INPUT_VOLTAGE		9
N
N
N#define DISPLAY_SK					15
N#define DISPLAY_SK_ENTRY_NUMBER			1,1
N#define DISPLAY_SK_AKTIVITY	 			1,2
N#define DISPLAY_SK_ALARM_AKTIVITY 			1,3
N#define DISPLAY_SK_ALARM 	 			1,4
N
N#define DISPLAY_DT					17
N#define DISPLAY_DT_ENTRY_NUMBER			1,1
N#define DISPLAY_DT_TEMPER	 			1,2
N#define DISPLAY_DT_ERROR 				1,3
N
N#define DISPLAY_MAKB				16
N#define DISPLAY_MAKB_ENTRY_NUMBER			1,1
N#define DISPLAY_MAKB_CONNECT_STATUS		1,2
N#define DISPLAY_MAKB_VOLTAGE0				1,3
N#define DISPLAY_MAKB_VOLTAGE1				1,4
N#define DISPLAY_MAKB_VOLTAGE2				1,5
N#define DISPLAY_MAKB_VOLTAGE3				1,6
N#define DISPLAY_MAKB_VOLTAGE4				1,7
N#define DISPLAY_MAKB_TEMPER0				1,8
N#define DISPLAY_MAKB_TEMPER1				1,9
N#define DISPLAY_MAKB_TEMPER2				1,10
N#define DISPLAY_MAKB_TEMPER3				1,11
N#define DISPLAY_MAKB_TEMPER4				1,12
N#define DISPLAY_MAKB_TEMPER0_STAT			1,13
N#define DISPLAY_MAKB_TEMPER1_STAT			1,14
N#define DISPLAY_MAKB_TEMPER2_STAT			1,15
N#define DISPLAY_MAKB_TEMPER3_STAT			1,16
N#define DISPLAY_MAKB_TEMPER4_STAT			1,17
N
N#define DISPLAY_LAKB				18
N#define DISPLAY_LAKB_ENTRY_NUMBER			1,1
N#define DISPLAY_LAKB_MAX_CELL_VOLTAGE		1,2
N#define DISPLAY_LAKB_MIN_CELL_VOLTAGE		1,3
N#define DISPLAY_LAKB_MAX_CELL_TEMPERATURE	1,4
N#define DISPLAY_LAKB_MIN_CELL_TEMPERATURE	1,5
N#define DISPLAY_LAKB_VOLTAGE				1,6
N#define DISPLAY_LAKB_CH_CURR				1,7
N#define DISPLAY_LAKB_DSCH_CURR				1,8
N#define DISPLAY_LAKB_RAT_CAP				1,9
N#define DISPLAY_LAKB_SOH					1,10
N#define DISPLAY_LAKB_SOC					1,11	
N#define DISPLAY_LAKB_CCLV					1,12
N#define DISPLAY_LAKB_RBT					1,13
N#define DISPLAY_LAKB_FLAGS1					1,14
N#define DISPLAY_LAKB_FLAGS2					1,15
N#define DISPLAY_LAKB_CELL_TEMPERATURE_1		1,16
N#define DISPLAY_LAKB_CELL_TEMPERATURE_2		1,17
N#define DISPLAY_LAKB_CELL_TEMPERATURE_3		1,18
N#define DISPLAY_LAKB_CELL_TEMPERATURE_4		1,19
N#define DISPLAY_LAKB_CELL_TEMPERATURE_AMBIENT	1,20
N#define DISPLAY_LAKB_CELL_TEMPERATURE_POWER		1,21
N#define DISPLAY_LAKB_CHARGE_AND_DISCHARGE_CURRENT_ALARM_STATUS		1,22
N#define DISPLAY_LAKB_BATTERY_TOTAL_VOLTAGE_ALARM_STATUS				1,23
N#define DISPLAY_LAKB_CUSTOM_ALARM_QUANTITY							1,24
N#define DISPLAY_LAKB_BALANCED_EVENT_CODE							1,25
N#define DISPLAY_LAKB_VOLTAGE_EVENT_CODE								1,26
N#define DISPLAY_LAKB_TEMPERATURE_EVENT_CODE							1,27
N#define DISPLAY_LAKB_CURRENT_EVENT_CODE								1,28
N#define DISPLAY_LAKB_FET_STATUS_CODE								1,29
N#define DISPLAY_LAKB_BALANCED_STATUS_CODE							1,30
N#define DISPLAY_LAKB_SYSTEM_STATUS_CODE								1,31
N#define DISPLAY_LAKB_DAMP1				1,32
N#define DISPLAY_LAKB_DAMP2				1,33
N#define DISPLAY_LAKB_DAMP3				1,34
N#define DISPLAY_LAKB_DAMP4				1,35
N#define DISPLAY_LAKB_DAMP5				1,36
N
N#define DISPLAY_KLIMAT				20
N#define DISPLAY_KLIMAT_WARM_SIGNAL		1
N#define DISPLAY_KLIMAT_COOL_SIGNAL		2
N#define DISPLAY_KLIMAT_WARM_ON_TEMPER	3
N#define DISPLAY_KLIMAT_WARM_OFF_TEMPER	4
N#define DISPLAY_KLIMAT_WARM_Q			5
N#define DISPLAY_KLIMAT_COOL_100_TEMPER	6
N#define DISPLAY_KLIMAT_COOL_80_TEMPER	7
N#define DISPLAY_KLIMAT_COOL_60_TEMPER	8
N#define DISPLAY_KLIMAT_COOL_40_TEMPER	9
N#define DISPLAY_KLIMAT_COOL_20_TEMPER	10
N#define DISPLAY_KLIMAT_COOL_100_DTEMPER	11
N#define DISPLAY_KLIMAT_COOL_80_DTEMPER	12
N#define DISPLAY_KLIMAT_COOL_60_DTEMPER	13
N#define DISPLAY_KLIMAT_COOL_40_DTEMPER	14
N#define DISPLAY_KLIMAT_COOL_20_DTEMPER	15
N#define DISPLAY_KLIMAT_WARM_STAT		16
N#define DISPLAY_KLIMAT_INT_VENT_PWM_STAT	17
N#define DISPLAY_KLIMAT_EXT_VENT_PWM_STAT	18	
N
N
N#define COMMAND_OK		0x5555
N#define COMAND_FAIL		0xaaaa
N#define COMMAND_INVALID	0xeeee
N#define WRONG_PARAMETER	0xeeef
N
N#define SNMP_BPS_DISABLE		5
N#define SNMP_BPS_UNDISABLE	8
N#define SNMP_SPEC_VZ		3
N#define SNMP_SPEC_KE		4
N#define SNMP_SPEC_DISABLE	7
N
N
N#define DISPLAY_LOG					9
N#define DISPLAY_LOG_ENTRY_EVENTS 			1,1
N//#define DISPLAY_LOG_ENTRY_EVENTS 			1,1
N
N#endif
N
N
N
N
N#ifdef UKU_KONTUR
S
S#define OID_DEVICE 		1,2
S
S#define DISPLAY_DEVICE_INFO			1
S#define DISPLAY_DEVICE_INFO_CODE			1
S#define DISPLAY_DEVICE_INFO_SERIAL			2
S#define DISPLAY_DEVICE_INFO_LOCATION 		3
S#define DISPLAY_DEVICE_INFO_NUMOFBAT 		4
S#define DISPLAY_DEVICE_INFO_NUMOFBPS 		5
S#define DISPLAY_DEVICE_INFO_NUMOFINV 		6
S#define DISPLAY_DEVICE_INFO_NUMOFAVT 		7
S#define DISPLAY_DEVICE_INFO_NUMOFDT 		8
S#define DISPLAY_DEVICE_INFO_NUMOFSK 		9
S#define DISPLAY_DEVICE_INFO_NUMOFEVENTS		10
S
S#define DISPLAY_MAINS_POWER			1
S#define DISPLAY_MAINS_POWER_VOLTAGE		1
S#define DISPLAY_MAINS_POWER_FREQUENCY		2
S#define DISPLAY_MAINS_POWER_STATUS			3
S#define DISPLAY_MAINS_POWER_ALARM			4
S#define DISPLAY_MAINS_POWER_VOLTAGE_PHASEA	5
S#define DISPLAY_MAINS_POWER_VOLTAGE_PHASEB	6
S#define DISPLAY_MAINS_POWER_VOLTAGE_PHASEC	7
S
S
S#define DISPLAY_LOAD				3
S#define DISPLAY_LOAD_VOLTAGE				1
S#define DISPLAY_LOAD_CURRENT				2
S
S#define DISPLAY_PSU					4
S#define DISPLAY_PSU_ENTRY_NUMBER			1,1
S#define DISPLAY_PSU_ENTRY_VOLTAGE 			1,2
S#define DISPLAY_PSU_ENTRY_CURRENT			1,3
S#define DISPLAY_PSU_ENTRY_TEMPERATURE		1,4
S#define DISPLAY_PSU_ENTRY_STATUS			1,5
S
S#define DISPLAY_BAT					5
S#define DISPLAY_BAT_NUMBER				1,1
S#define DISPLAY_BAT_VOLTAGE				1,2
S#define DISPLAY_BAT_PART_VOLTAGE			1,3
S#define DISPLAY_BAT_CURRENT				1,4
S#define DISPLAY_BAT_TEMPERATURE			1,5
S#define DISPLAY_BAT_CAPACITY				1,6
S#define DISPLAY_BAT_CHARGE				1,7
S#define DISPLAY_BAT_STATUS				1,8
S
S#define DISPLAY_SPEC				6
S#define DISPLAY_SPEC_STAT				1
S#define DISPLAY_SPEC_COMMAND				2
S
S#define DISPLAY_SPEC_TRAP_MESSAGE			5
S#define DISPLAY_SPEC_TRAP_VALUE_0			6
S#define DISPLAY_SPEC_TRAP_VALUE_1			7
S#define DISPLAY_SPEC_TRAP_VALUE_2			8
S
S
S
S
S#define LCD_SIZE 200
S
S#define SNMP_COMMAND				8
S#define COMMAND_ANSWER					1
S#define COMMAND_PARAMETR					2
S
S#define SYSPARAMS					10
S#define SYSPARAMSSOUNDALARMEN				1
S#define SYSPARAMSALARMAUTODISABLE			2
S#define SYSPARAMS_BAT_TEST_TIME			3
S#define SYSPARAMS_U_MAX					4
S#define SYSPARAMS_U_MIN					5
S#define SYSPARAMS_U_0_GRAD				6
S#define SYSPARAMS_U_20_GRAD				7 
S#define SYSPARAMS_U_SIGN					8
S#define SYSPARAMS_U_MIN_POWER				9
S#define SYSPARAMS_U_WITHOUT_BAT			10
S#define SYSPARAMS_IBK					11
S#define SYSPARAMS_IZMAX					12
S#define SYSPARAMS_IMAX					13
S#define SYSPARAMS_IMIN					14
S#define SYSPARAMS_UVZ					15
S#define SYSPARAMS_TZAS					16
S#define SYSPARAMS_TSIGN_BAT				17
S#define SYSPARAMS_TMAX_BAT				18
S#define SYSPARAMS_TSIGN_BPS				19
S#define SYSPARAMS_TMAX_BPS				20	
S#define SYSPARAMS_BAT_PART_ALARM			21
S#define SYSPARAMS_POWER_CNT_ADRESS			22
S
S
S#define DISPLAY_AVT					11
S#define DISPLAY_AVT_ENTRY_NUMBER			1,1
S#define DISPLAY_AVT_ENTRY_STAT 			1,2
S
S#define DISPLAY_ENERGY				12
S#define DISPLAY_ENERGY_VVOD_PHASE_A		1
S#define DISPLAY_ENERGY_VVOD_PHASE_B		2
S#define DISPLAY_ENERGY_VVOD_PHASE_C		3
S#define DISPLAY_ENERGY_PES_PHASE_A			4
S#define DISPLAY_ENERGY_PES_PHASE_B			5
S#define DISPLAY_ENERGY_PES_PHASE_C			6
S#define DISPLAY_ENERGY_TOTAL_ENERGY		7
S#define DISPLAY_ENERGY_CURRENT_ENERGY		8
S
S
S#define DISPLAY_SK					14
S#define DISPLAY_SK_ENTRY_NUMBER			1,1
S#define DISPLAY_SK_NAME					1,2
S#define DISPLAY_SK_AKTIVITY	 			1,3
S#define DISPLAY_SK_ALARM_AKTIVITY 			1,4
S#define DISPLAY_SK_ALARM 	 			1,5
S
S#define DISPLAY_DT					15
S#define DISPLAY_DT_EXT					1
S#define DISPLAY_DT_MSAN	 				2
S#define DISPLAY_DT_EPU 					3
S
S#define DISPLAY_KLIMAT				16
S#define DISPLAY_KLIMAT_BOX_TEMPER				1
S#define DISPLAY_KLIMAT_SETTINGS_BOX_ALARM_TEMPER	2
S#define DISPLAY_KLIMAT_SETTINGS_VENT_ON			3
S#define DISPLAY_KLIMAT_SETTINGS_VENT_OFF		4
S#define DISPLAY_KLIMAT_SETTINGS_WARM_ON			5
S#define DISPLAY_KLIMAT_SETTINGS_WARM_OFF		6
S#define DISPLAY_KLIMAT_SETTINGS_LOAD_ON			7
S#define DISPLAY_KLIMAT_SETTINGS_LOAD_OFF		8
S#define DISPLAY_KLIMAT_SETTINGS_BATT_ON			9
S#define DISPLAY_KLIMAT_SETTINGS_BATT_OFF		10
S
S
S
S#define COMMAND_OK		0x5555
S#define COMAND_FAIL		0xaaaa
S#define COMMAND_INVALID	0xeeee
S#define WRONG_PARAMETER	0xeeef
S
S#define SNMP_BPS_DISABLE		5
S#define SNMP_BPS_UNDISABLE	8
S#define SNMP_SPEC_VZ		3
S#define SNMP_SPEC_KE		4
S#define SNMP_SPEC_DISABLE	7
S
S
S#define DISPLAY_LOG					9
S#define DISPLAY_LOG_ENTRY_EVENTS 			1,1
S//#define DISPLAY_LOG_ENTRY_EVENTS 			1,1
N#endif
N
N//#define SEC_IN_HOUR	36000L
N
N#define LCD_SIZE 200
N
N
N#define MAX_NUM_OF_BAT	2
N#define MAX_NUM_OF_BPS	12
N//#define PAROL_ALL_ZERO
N
N#define AH_CONSTANT		36000L
N
N//***********************************************
N//Состояние источников
N
N
N
N
N#define MASK(lengt) 		(0xffffffff>>(32-lengt))
N#define MASK_OFFSET(shift,lengt)	(MASK(lengt)<<shift)
N
N#define GET_REG( reg, shift, lengt) 		( (reg & MASK_OFFSET(shift,lengt)) >> shift)
N#define SET_REG( reg, val, shift, lengt)  	reg = ( (reg & ~MASK_OFFSET(shift,lengt)) | (val << shift) )
N//#define CHK_REG( reg, mask ) ( (reg) & (mask) == (mask) )
N
N
N
N#define delay_ms(x) {long xx; xx=(unsigned long)x * 12000UL; while(xx)xx--;}
N#define delay_us(x) {long xx; xx=(unsigned long)x * 12UL; while(xx)xx--;}
N
N//*************************************************
N//сообщения
N#define MESS_DEEP	10
N
N#define 	MESS_ZERO 		0
N#define 	MESS_BAT1_OFF 		1
N#define 	MESS_BAT2_OFF		2
N#define 	MESS_ALL_SRC_OFF	3
N#define 	MESS_ALL_SRC_ON	4
N//#define 	MESS_RELSAM_ON		5
N#define 	MESS_SRC1_OFF		6
N#define 	MESS_SRC2_OFF		7
N#define 	MESS_SRC3_OFF		8
N#define 	MESS_SRC4_OFF		9
N#define 	MESS_SRC5_OFF		10
N#define 	MESS_SRC6_OFF		11
N#define 	MESS_SRC7_OFF		12
N#define 	MESS_SRC8_OFF		13
N#define 	MESS_SRC9_OFF		14
N#define 	MESS_SRC10_OFF		15
N#define 	MESS_SRC11_OFF		16
N#define 	MESS_SRC12_OFF		17
N#define 	MESS_BAT_CONTROL	18
N#define 	MESS_SRC_CONTROL	19
N#define 	MESS_LOAD2_WAIT	9 
N#define 	MESS_PONG			100
N#define	MESS_SPA_UART_PONG	101 
N#define	MESS_SPA_BLOK_BPS1	102
N#define	MESS_SPA_BLOK_BPS2	103
N#define	MESS_SPA_LEAVE_BPS1	104
N#define	MESS_SPA_LEAVE_BPS2	105
N#define 	MESS_SRC_ON_OFF	150
N#define   _MESS_SRC_MASK_BLOK_2SEC		151
N#define   _MESS_SRC_MASK_UNBLOK		152
N#define 	_MESS_SRC_MASK_ON			153
N#define	_MESS_SRC_PWM				154
N#define	_MESS_U_NECC				155
N#define   _MESS_FAST_REG				156
N//#define   _MESS_U_AVT_GOOD			157
N
N#define 	MESS_BAT_ON_OFF	160
N#define   _MESS_BAT_MASK_BLOK_AFTER_2SEC		161
N#define	_MESS_BAT_MASK_ON					162
N#define	_MESS_BAT_MASK_OFF					163
N
N		
N//#define	MESS_SPA_UART_SRAM	200 
N//#define	MESS_SPA_UART_CMND	201 
N
N#define	MESS2UNECC_HNDL   					190
N#define  		PARAM_UNECC_SET				 	191
N#define	MESS2BAT_HNDL   					200
N//#define	MESS2BAT_HNDL1   					201
N#define		PARAM_BAT_ALL_OFF_AFTER_2SEC			201
N#define		PARAM_BAT_MASK_OFF_AFTER_2SEC			202
N//#define		PARAM_BAT_ON						202
N#define	MESS2BPS_HNDL   					205
N#define		PARAM_BPS_ALL_OFF_AFTER_2SEC			206
N#define		PARAM_BPS_MASK_OFF_AFTER_2SEC			207
N#define		PARAM_BPS_MASK_ON_OFF_AFTER_2SEC		208
N#define		PARAM_BPS_MASK_ON					209
N#define		PARAM_BPS_ALL_ON					210
N#define 	MESS2RELE_HNDL						210
N#define 	MESS2KLIMAT_CNTRL					211
N#define		PARAM_RELE_SAMOKALIBR				100
N#define		PARAM_RELE_AV_1						101
N#define		PARAM_RELE_AV_2						102
N#define		PARAM_RELE_AV_3						103
N#define		PARAM_RELE_LOAD_OFF					103
N#define		PARAM_RELE_AV_4						104
N//#define		PARAM_RELE_WARM					104
N#define		PARAM_RELE_AV_COMM					105
N#define		PARAM_RELE_AV_BPS					106
N#define		PARAM_RELE_VENT						107
N#define		PARAM_RELE_VENT_WARM				107
N#define		PARAM_RELE_AV_BAT1					108
N#define		PARAM_RELE_AV_BAT2					109
N#define		PARAM_RELE_NPN						110
N#define		PARAM_RELE_WARM				     	111
N#define 		PARAM_RELE_VVENT				112
N#define 		PARAM_RELE_EXT					113
N#define 		PARAM_RELE_BAT_IS_DISCHARGED	114
N#define		PARAM_KLIMAT_CNTRL_VENT_INT			115
N#define		PARAM_KLIMAT_CNTRL_VENT_EXT			116
N
N#define	MESS2IND_HNDL						215
N#define		PARAM_SAMOKALIBR					216
N#define 		PARAM_U_AVT_GOOD					217
N#define	MESS2MATEMAT						220
N#define		PARAM_SAMOKALIBR					216
N#define	MESS2CNTRL_HNDL   					225
N#define		PARAM_CNTRL_STAT_PLUS				100
N#define		PARAM_CNTRL_STAT_MINUS				105
N#define		PARAM_CNTRL_STAT_STEP_DOWN			110
N#define 		PARAM_CNTRL_STAT_SET		    		229
N#define 		PARAM_CNTRL_STAT_FAST_REG		    	230	
N#define	MESS2KB_HNDL   					230
N#define		PARAM_CNTRL_IS_DOWN					231
N#define	MESS2VENT_HNDL   					240
N#define		PARAM_VENT_CB					241
N
N#define MESS2NET_DRV							33
N#define	PARAM_BPS_NET_OFF						34
N
N#define LCD_SIZE 200
N
N
N
N#define BIN__N(x) (x) | x>>3 | x>>6 | x>>9
N#define BIN__B(x) (x) & 0xf | (x)>>12 & 0xf0
N#define BIN8(v) (BIN__B(BIN__N(0x##v)))
N
N
N
N#define BAUD_RATE0 9600UL
N#define BAUD_RATE1 9600UL
N
N
N
N
N
N#ifndef PAROL_ALL_ZERO
N#define PAROL_KALIBR 873
N#define PAROL_SET 184
N#define PAROL_MODE 0 
N#define PAROL_ALLER 815 
N#define PAROL_BAT_IN 722 
N#define PAROL_BAT_OUT 722
N#define PAROL_KE 125
N#define PAROL_VZ 126
N#define PAROL_TST 999 
N#define PAROL_DEFAULT 295
N#define PAROL_AUSW 949
N#endif                
N
N#ifdef PAROL_ALL_ZERO
S#define PAROL_KALIBR 0
S#define PAROL_SET 0
S#define PAROL_MODE 0 
S#define PAROL_ALLER 0 
S#define PAROL_BAT_IN 0 
S#define PAROL_BAT_OUT 0
S#define PAROL_KE 0
S#define PAROL_VZ 0
S#define PAROL_TST 0
S#define PAROL_DEFAULT 0
S#define PAROL_AUSW 0
N#endif
N
N
N#define CNT_SRC_MAX	60
N
N
N
N//
N
N//#define SHIFT_REL_AV_BPS	     4
N 
N
N
N#ifdef UKU_MGTS
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_AV_COMM	9
S#define SHIFT_REL_LOAD_OFF	5
S#define SHIFT_REL_VENT	     7
S#define SHIFT_REL_LIGHT 	     4
N#endif
N
N#ifdef UKU_RSTKM
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_AV_COMM	9
S#define SHIFT_REL_LOAD_OFF	5
S#define SHIFT_REL_VENT	     7
S#define SHIFT_REL_LIGHT 	     4
N#endif
N
N#ifdef UKU_3U
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_AV_BAT1	4
S#define SHIFT_REL_AV_BAT2	9
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
N#endif
N
N#ifdef UKU_GLONASS
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_AV_BAT1	4
S#define SHIFT_REL_AV_BAT2	9
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
N#endif
N
N#ifdef UKU_KONTUR
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_AV_COMM	9
S#define SHIFT_REL_LOAD_OFF	5
S#define SHIFT_REL_VENT	     7
S#define SHIFT_REL_VENT_WARM   7
S#define SHIFT_REL_WARM 	     4
S#define SHIFT_REL_LIGHT 	     4
N#endif
N
N#ifdef UKU_6U
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_AV_BAT1	4
S#define SHIFT_REL_AV_BAT2	9
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_VENT		5
N#endif
N
N#ifdef UKU_220
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_AV_BAT	4
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_VENT		9
N#endif
N
N#ifdef UKU_220_IPS_TERMOKOMPENSAT
N#define SHIFT_REL_BAT1	     8
N#define SHIFT_REL_BAT2	     6
N#define SHIFT_REL_AV_NET		25
N#define SHIFT_REL_AV_BPS	     5
N#define SHIFT_REL_AV_BAT	     4
N#endif
N
N#ifdef UKU_220_V2
S#define SHIFT_REL_AV_NET		25
S#define SHIFT_REL_AV_BAT	4
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_VENT		9
N#endif
N
N#ifdef UKU_TELECORE2015
S#define SHIFT_REL_AV_NET		5
S#define SHIFT_REL_AV_BAT	4
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_LIGHT		9
S#define SHIFT_REL_WARM		4
S#define SHIFT_REL_VENT	     7
S#define SHIFT_REL_VVENT	     6
N#endif
N
N#ifdef UKU_TELECORE2017
S#define SHIFT_REL_AV_NET		5
S#define SHIFT_REL_AV_BAT	4
S#define SHIFT_REL_AV_BPS	     7
S#define SHIFT_REL_BAT1	     8
S#define SHIFT_REL_BAT2	     6
S#define SHIFT_REL_LIGHT		9
S#define SHIFT_REL_WARM		4
S#define SHIFT_REL_VENT	     7
S#define SHIFT_REL_VVENT	     6
N#endif
N
N//***********************************************
N//Таймер
Nextern char b1000Hz,b100Hz,b50Hz,b10Hz,b5Hz,b2Hz,b1Hz;
Nextern short t0cnt,t0cnt0,t0cnt1,t0cnt2,t0cnt3,t0cnt4,t0cnt5,t0cnt6,t0_cnt7;
Nextern char bFL5,bFL2,bFL,bFL_;
Nextern signed short main_10Hz_cnt;
Nextern signed short main_1Hz_cnt;
N
N//***********************************************
N//Структура ИБЭПа
Nextern char cnt_of_slave;
N//char cnt_of_wrks;   //колличество работающих источников , для индикации
N
N
N
N
N//***********************************************
N//Индикация
Ntypedef enum {
N	iMn_VD,
N	iSet_VD,
N	#ifndef UKU_TELECORE2017
N	iMn_TELECORE2017,
N	#endif 
N	iSrv_sl,iNet,iNet3,iNetEM,
N	iSet,iSet_220_IPS_TERMOKOMPENSAT,iSet_220_V2,
N	iInv_set,
N	iMakb,
N	iBps,iBps_elteh,iS2,iSet_prl,iK_prl,iDnd,
N	iK, iK_220_IPS_TERMOKOMPENSAT,iK_220_IPS_TERMOKOMPENSAT_IB,iK_TELECORE,iK_VD,
N	iSpcprl,iSpc,k,Crash_0,Crash_1,iKednd,iAv_view_avt,iAKE,iSpc_termocompensat,
N	iLoad,iAVAR,
N	iStr,iStr_VD,
N	iVrs,iPrltst,iApv,
N	iK_bps,iK_bps_sel,iK_bat_ips_termokompensat_ib,iK_bat_TELECORE,iK_bat_sel,iK_bat_sel_TELECORE,iK_load,iK_net,iK_net3,
N	iK_makb_sel,iK_makb,iK_out,
N	iTst_220_IPS_TERMOKOMPENSAT,iTst_VD,
N	iTst_klbr,iTst_BPS1,iTst_BPS2,iTst_BPS12,iDebug,
N	iDef_220_IPS_TERMOKOMPENSAT,
N	iSet_st_prl,iK_pdp,iSet_T,
N	iDeb,
N	iPrl_bat_in_out,iPrl_bat_in_sel,iPdp1,iJAv_sel,iJAv_net_sel,iJAv_net,iJAv_src1,
N	iTst_bps,/*iJAv_bat,iJAv_bat_sel,*/iAusw,iAusw_prl,iAusw_set,
N	iK_t_ext,iK_t_3U,iK_t_ext_6U,
N	iAv_view,
N	iBatLogKe,iJ_bat_ke,iBatLogVz,iJ_bat_vz,iBatLogWrk,
N	iExtern,
N	iK_power_net,
N	iExt_set,iExt_set_3U,
N	iExt_dt,
N	iExt_sk,iExt_sk_3U,
N	iExt_ddv,iExt_ddi,iExt_dud,iExt_dp,iSM,iLog,iLog_,iBatLog,iKlimat,iKlimat_kontur,iKlimat_TELECORE,
N	iEnerg3,iEnerg,
N	iVent,
N	iK_power_net3,
N	iAvt,iLan_set,
N	iNpn_set,
N	iBps_list,
N	iRele_set,iRele_set_,
N	iAvt_set_sel,iAvt_set,iSet_li_bat,
N	iOut_volt_contr,iDop_rele_set,iBlok_ips_set,iIps_Curr_Avg_Set}i_enum;
N
Ntypedef struct  
N{
N
Ni_enum i;
Nsigned char s_i;
Nsigned char s_i1;
Nsigned char s_i2;
Nsigned char i_s;
N} stuct_ind;
N
N#define ind     a_ind.i
N#define sub_ind     a_ind.s_i
N#define sub_ind1     a_ind.s_i1
N#define sub_ind2     a_ind.s_i2
N#define index_set     a_ind.i_s
N
Nextern stuct_ind a_ind,b_ind[10],c_ind;
Nextern signed short ptr_ind;
Nextern char lcd_buffer[LCD_SIZE+100];
Xextern char lcd_buffer[200+100];
Nextern signed char parol[3];
Nextern char phase;
Nextern char lcd_bitmap[1024];
Nextern char dig[5];
Nextern signed short ind_pointer;
Nextern char zero_on;
Nextern char mnemo_cnt;
Nextern char simax;
Nextern short av_j_si_max;
Nextern const char ABCDEF[];
Nextern const char sm_mont[13][4]; 
N
N
N//**********************************************
N//Коэффициенты, отображаемые из EEPROM
Nextern signed short Ktsrc[2];
Nextern signed short Kusrc[2];
Nextern signed short Kisrc[2];
Nextern signed short Ki0src[2];
Nextern signed short Kubat[2];
Nextern signed short Kubatm[2];
Nextern unsigned short Kibat0[2];
Nextern signed short Kibat1[2];
Nextern signed short Ktbat[2];
Nextern signed short Kunet;
Nextern signed short Ktext[3];
Nextern signed short Kuload;
Nextern signed short Kunet_ext[3];
Nextern signed short KunetA;
Nextern signed short KunetB;
Nextern signed short KunetC;
Nextern signed short Kubps;
Nextern signed short Kuout;
Nextern signed short Kuvd;
N
Nextern signed short MAIN_IST;
Nextern signed short UMAX;
Nextern signed short UOUT;
Nextern signed short UOUT_;
Nextern signed short UAVT;
Nextern signed short TMAX;
Nextern signed short TSIGN;
Nextern signed short TSYSMAX;
Nextern signed short AV_OFF_AVT;
Nextern signed short USIGN;
Nextern signed short UMN;
Nextern signed short ZV_ON;
Nextern signed short UINMAX;
Nextern signed short UINMIN;
Nextern signed short UOUTMAX;
Nextern signed short UOUTMIN;
Nextern signed short IKB;
N
Nextern signed short IMAX;
Nextern signed short IMIN;
Nextern signed short APV_ON;
Nextern signed short IZMAX;
Nextern signed short U0B;
Nextern signed short TZAS;
Nextern signed short VZ_HR;
Nextern signed short TBAT;
Nextern signed short U_AVT;
Nextern signed short DU;
N
Nextern signed short RELE_SET_MASK[4];
N
Nextern signed short TBATMAX;
Nextern signed short TBATSIGN;
Nextern signed short UBM_AV;
Nextern signed short RELE_LOG;
Nextern signed short TBOXMAX;
Nextern signed short TBOXREG;
Nextern signed short TBOXVENTMAX;
Nextern signed short TLOADDISABLE;
Nextern signed short TLOADENABLE;
Nextern signed short TBATDISABLE;
Nextern signed short TBATENABLE;
Nextern signed short TBOXMAX;
Nextern signed short TBOXREG;
Nextern signed short TBOXVENTMAX;
Nextern signed short TLOADDISABLE;
Nextern signed short TLOADENABLE;
Nextern signed short TBATDISABLE;
Nextern signed short TBATENABLE;
Nextern signed short TVENTON;
Nextern signed short TVENTOFF;
Nextern signed short TWARMON;
Nextern signed short TWARMOFF;
Ntypedef enum {rvsAKB=0,rvsEXT,rvsBPS} enum_releventsign;
Nextern enum_releventsign RELEVENTSIGN;
Nextern signed short TZNPN;
Nextern signed short UONPN;
Nextern signed short UVNPN;
Ntypedef enum {npnoOFF=0,npnoRELEVENT,npnoRELEAVBAT2} enum_npn_out;
Nextern enum_npn_out NPN_OUT;
Ntypedef enum {npnsULOAD=0,npnsAVNET} enum_npn_sign;
Nextern enum_npn_sign NPN_SIGN;
Nextern signed short TERMOKOMPENS;
Nextern signed short TBOXVENTON; 
Nextern signed short TBOXVENTOFF;
Nextern signed short TBOXWARMON; 
Nextern signed short TBOXWARMOFF;
Nextern signed short BAT_TYPE;	//Тип батареи. 0 - обычная свинцовая, 1-литиевая COSLIGHT, 2-литиевая SACRED SUN , 3-литиевая ZTT
Nextern signed short DU_LI_BAT;	//Параметр, определяющий напряжение содержания литиевой батареи
Nextern signed short FORVARDBPSCHHOUR;	//Периодичностьсмены ведущего источника в часах. Если 0 - функция выключена и ведущий первый источник
Nextern signed short NUMBAT;
Nextern signed short NUMBAT_TELECORE;
Nextern signed short NUMIST;
Nextern signed short NUMINV;
Nextern signed short NUMDT;
Nextern signed short NUMSK;
Nextern signed short NUMEXT;
Nextern signed short NUMAVT;
Nextern signed short NUMMAKB;
Nextern signed short NUMBYPASS;
Nextern signed short U_OUT_KONTR_MAX;
Nextern signed short U_OUT_KONTR_MIN;
Nextern signed short U_OUT_KONTR_DELAY;
Nextern signed short DOP_RELE_FUNC;
Nextern signed short CNTRL_HNDL_TIME;	//Постоянная времени регулирования источников для Телекора
Nextern signed short USODERG_LI_BAT;		//Напряжение содержания литиевой батареи
Nextern signed short QSODERG_LI_BAT;		//Заряд при котором начинает действовать напряжение содержания литиевой батареи
Nextern signed short TVENTMAX;			//Максимальный ресурс вентилятора
Nextern signed short ICA_EN;				//Включенность режима выравнивания токов ИПС
Nextern signed short ICA_CH;				//Канал связи для выравнивания токов, 0 - MODBUS, 1 - MODBUS-TCP
Nextern signed short ICA_MODBUS_ADDRESS;//Адрес ведомого для выравнивания токов по шине MODBUS-RTU
Nextern signed short ICA_MODBUS_TCP_IP1,ICA_MODBUS_TCP_IP2,ICA_MODBUS_TCP_IP3,ICA_MODBUS_TCP_IP4;	//IP ведомого для выравнивания токов по шине MODBUS-TCP
Nextern signed short ICA_MODBUS_TCP_UNIT_ID;	//UNIT ID ведомого для выравнивания токов по шине MODBUS-TCP
Nextern signed short PWM_START;			//Начальный шим для ЭЛТЕХа
Nextern signed short KB_ALGORITM;		//2-х или 3-х ступеннчатый алгоритм проверки цепи батареи
Nextern signed short REG_SPEED;			//скорость регулирования, 1- стандартная, 2,3,4,5- замедленная в 2,3,4,5 раз
N
Ntypedef enum {apvON=0x01,apvOFF=0x00}enum_apv_on;
Nextern enum_apv_on APV_ON1,APV_ON2;
N
Nextern signed short APV_ON2_TIME;
N
Ntypedef enum {bisON=0x0055,bisOFF=0x00aa}enum_bat_is_on;
Nextern enum_bat_is_on BAT_IS_ON[2];
N
Nextern signed short BAT_DAY_OF_ON[2];
Nextern signed short BAT_MONTH_OF_ON[2];
Nextern signed short BAT_YEAR_OF_ON[2];
Nextern signed short BAT_C_NOM[2];
Nextern signed short BAT_RESURS[2];
Nextern signed short BAT_C_REAL[2];
N//extern signed short BAT_TYPE[2];
N
Nextern unsigned short AUSW_MAIN;
Nextern unsigned long 	AUSW_MAIN_NUMBER;
Nextern unsigned short AUSW_DAY;
Nextern unsigned short AUSW_MONTH;
Nextern unsigned short AUSW_YEAR;
Nextern unsigned short AUSW_UKU;
Nextern unsigned short AUSW_UKU_SUB;
Nextern unsigned long AUSW_UKU_NUMBER;
Nextern unsigned long	AUSW_BPS1_NUMBER;
Nextern unsigned long  AUSW_BPS2_NUMBER;
Nextern unsigned short AUSW_RS232;
Nextern unsigned short AUSW_PDH;
Nextern unsigned short AUSW_SDH;
Nextern unsigned short AUSW_ETH;
N
Nextern signed short TMAX_EXT_EN[3];
Nextern signed short TMAX_EXT[3];
Nextern signed short TMIN_EXT_EN[3];
Nextern signed short TMIN_EXT[3];
Nextern signed short T_EXT_REL_EN[3];
Nextern signed short T_EXT_ZVUK_EN[3];
Nextern signed short T_EXT_LCD_EN[3];
Nextern signed short T_EXT_RS_EN[3];
N
Nextern signed short SK_SIGN[4];
Nextern signed short SK_REL_EN[4];
Nextern signed short SK_ZVUK_EN[4];
Nextern signed short SK_LCD_EN[4];
Nextern signed short SK_RS_EN[4];
N
Ntypedef enum {AVZ_1=1,AVZ_2=2,AVZ_3=3,AVZ_6=6,AVZ_12=12,AVZ_OFF=0}enum_avz;
Nextern enum_avz AVZ;
N
Nextern unsigned short HOUR_AVZ;
Nextern unsigned short MIN_AVZ;
Nextern unsigned short SEC_AVZ;
Nextern unsigned short DATE_AVZ;
Nextern unsigned short MONTH_AVZ;
Nextern unsigned short YEAR_AVZ;
Nextern unsigned short AVZ_TIME;
Ntypedef enum {mnON=0x55,mnOFF=0xAA}enum_mnemo_on;
Nextern enum_mnemo_on MNEMO_ON;
Nextern unsigned short MNEMO_TIME;
Nextern signed short POWER_CNT_ADRESS;
N
Nextern signed short ETH_IS_ON;
Nextern signed short ETH_DHCP_ON;
Nextern signed short ETH_IP_1;
Nextern signed short ETH_IP_2;
Nextern signed short ETH_IP_3;
Nextern signed short ETH_IP_4;
Nextern signed short ETH_MASK_1;
Nextern signed short ETH_MASK_2;
Nextern signed short ETH_MASK_3;
Nextern signed short ETH_MASK_4;
Nextern signed short ETH_TRAP1_IP_1;
Nextern signed short ETH_TRAP1_IP_2;
Nextern signed short ETH_TRAP1_IP_3;
Nextern signed short ETH_TRAP1_IP_4;
Nextern signed short ETH_TRAP2_IP_1;
Nextern signed short ETH_TRAP2_IP_2;
Nextern signed short ETH_TRAP2_IP_3;
Nextern signed short ETH_TRAP2_IP_4;
Nextern signed short ETH_TRAP3_IP_1;
Nextern signed short ETH_TRAP3_IP_2;
Nextern signed short ETH_TRAP3_IP_3;
Nextern signed short ETH_TRAP3_IP_4;
Nextern signed short ETH_TRAP4_IP_1;
Nextern signed short ETH_TRAP4_IP_2;
Nextern signed short ETH_TRAP4_IP_3;
Nextern signed short ETH_TRAP4_IP_4;
Nextern signed short ETH_TRAP5_IP_1;
Nextern signed short ETH_TRAP5_IP_2;
Nextern signed short ETH_TRAP5_IP_3;
Nextern signed short ETH_TRAP5_IP_4;
Nextern signed short ETH_SNMP_PORT_READ;
Nextern signed short ETH_SNMP_PORT_WRITE;
Nextern signed short ETH_GW_1;
Nextern signed short ETH_GW_2;
Nextern signed short ETH_GW_3;
Nextern signed short ETH_GW_4;
N
Nextern signed short RELE_VENT_LOGIC;
N
Nextern signed short MODBUS_ADRESS;
Nextern signed short MODBUS_BAUDRATE;
Nextern signed short BAT_LINK;
Nextern signed short I_LOAD_MODE;		//способ измерения выходного тока - по шунту или как сумму токов источников
N
N
N//***********************************************
N//Состояние батарей
Ntypedef struct
N     {
N	char 		_cnt_to_block;
N	signed short	_Ub;
N     signed short	_Ubm;
N     signed short	_dUbm;
N	signed short	_Ib;
N	signed short	_Tb;
N	char 		_nd;
N	char 		_cnt_wrk;
N	char 		_wrk;
N	unsigned short _zar;
N	char 		_full_ver;
N	signed long 	_zar_cnt;
N	signed long 	_zar_cnt_ke;
N	unsigned short _Iintegr,_Iintegr_; 
N	signed short 	_u_old[8];
N	signed short	_u_old_cnt;
N	unsigned long 	_wrk_date[2];
N	char 		_rel_stat;
N	char			_av;
N	char			_time_cnt;
N	char 		_temper_stat;
N	//0бит - подогрев
N	//1бит - перегрев
N	signed short 	_sign_temper_cnt;
N	signed short 	_max_temper_cnt;
N	signed long 	_resurs_cnt;
N	signed short 	_cnt_as; 	//счетчик несимметрии, считает до 5 минут при выполнении условий несимметрии, когда досчитывает - пишет в журнал
N     //signed short   _max_cell_volt;
N	//signed short   _min_cell_volt;
N	} BAT_STAT; 
Nextern BAT_STAT bat[2],bat_ips;
Nextern signed short		bat_u_old_cnt;
Nextern signed short 	Ib_ips_termokompensat;
N
N//#ifdef UKU_TELECORE2015
Ntypedef enum {bsOFF=0,bsCOMM_ON,bsOK} enum_batStat;
N//***********************************************
N//Состояние литиевой батареи
Ntypedef struct
N     {
N	//char 		_cnt_to_block;
N	signed short	_Ub;
N     //signed short	_Ubm;
N     //signed short	_dUbm;
N	signed short	_Ib;
N	signed short	_Tb;
N	char 		_nd;
N	char   		_soh;
N	char 		_soc;
N	signed short   _ratCap;
N	char 		_comErrStat;	//Состояние связи с батареей: 1-ошибка, 0-связь в норме
N	enum_batStat	_batStat;
N	signed short 	_cclv;
N	char 		_rbt;
N	short 		_canErrorCnt;
N	char			_canError;
N	char 		_485Error;
N	short 		_485ErrorCnt;
N	//char 		_full_ver;
N	//signed long 	_zar_cnt;
N	//signed long 	_zar_cnt_ke;
N	//unsigned short _Iintegr,_Iintegr_; 
N	//signed short 	_u_old[8];
N	//signed short	_u_old_cnt;
N	//unsigned long 	_wrk_date[2];
N	//char 		_rel_stat;
N	//char			_av;
N	//char			_time_cnt;
N	//char 		_temper_stat;
N	//0бит - подогрев
N	//1бит - перегрев
N	//signed short 	_sign_temper_cnt;
N	//signed short 	_max_temper_cnt;
N	//signed long 	_resurs_cnt;
N	//signed short 	_cnt_as; 	//счетчик несимметрии, считает до 5 минут при выполнении условий несимметрии, когда досчитывает - пишет в журнал
N     //signed short   _max_cell_volt;
N	//signed short   _min_cell_volt;
N	} LI_BAT_STAT; 
Nextern LI_BAT_STAT li_bat;
N//#endif
N//***********************************************
N//Состояние байпаса
Ntypedef struct
N     {
N	signed short 	_Iout;
N	signed short 	_Uout;
N	signed short 	_Pout;
N	signed short 	_Unet; 	
N	signed short 	_Uin;
N	char			_T;
N	char 		_flags;
N	char			_cnt;
N	char 		_adress;
N	} BYPS_STAT; 
Nextern BYPS_STAT byps;
N
N//***********************************************
N//Мониторы АКБ
Ntypedef struct
N     {
N	signed short	_U[5];
N	signed short	_Ub[5];
N	signed short	_T[5];
N	signed short	_T_nd[5];
N	signed short 	_cnt; 	
N	} MAKB_STAT; 
Nextern MAKB_STAT makb[4];
N
N//***********************************************
N//Литиевые АКБ
Ntypedef struct
N     {
N	signed short	_max_cell_volt;
N	signed short	_min_cell_volt;
N	signed short	_max_cell_temp;
N	signed short	_min_cell_temp;
N	signed short	_tot_bat_volt;
N	signed short	_ch_curr;
N	signed short	_dsch_curr;
N	signed short	_rat_cap;
N	signed short	_s_o_h;
N	signed short	_s_o_c;
N	signed short	_c_c_l_v;
N	signed short	_r_b_t;
N	signed short	_b_p_ser_num;
N	signed short   _flags1;
N	signed short 	_flags2;
N	signed short 	_communication2lvlErrorStat; 	//флаг аварийности низовой связи с батареей, вычисляется в плате расширения
N	signed short	_communication2lvlErrorCnt;  	//счетчик аварийности низовой связи с батареей
N	signed short 	_cnt;
N	signed short 	_communicationFullErrorStat;	//флаг аварийности всего канала связи с батареей, 0 - норма, 1 - отсутствует связь с промежуточной платой, 2 - отсутствует связь промежуточной платы и батареи  	
N	signed short   _battIsOn;		//0 - отсутствует, 1 - присутствует
N	char 		_plazma[8];		//переменные для отладки
N	signed short 	_isOnCnt;
N	signed short	_s_o_c_abs;		//остаточный заряд в абсолютном выражении
N	signed short 	_s_o_c_percent; //остаточный заряд в процентном выражении
N	signed short	_plazma_ss;
N	signed short	_zar_percent;	//заряд батареи в процетах
N	signed char		_cell_temp_1;	//температура 1-го датчика батареи(ZTT)
N	signed char		_cell_temp_2;	//температура 2-го датчика батареи(ZTT)
N	signed char		_cell_temp_3;	//температура 3-го датчика батареи(ZTT)
N	signed char		_cell_temp_4;	//температура 4-го датчика батареи(ZTT)
N	signed char		_cell_temp_ambient;	//температура датчика окружающей среды батареи(ZTT)
N	signed char		_cell_temp_power;	//температура датчика силовой части батареи(ZTT)
N	//signed char 	_pack_volt_state;	//статус аварии по напряжениям батареи(ZTT)
N	//signed char 	_pack_temper_state;	//статус аварии по температурам батареи(ZTT)
N	//signed char 	_pack_alarm_state;	//статус аварий батареи(ZTT)
N	signed char		_charge_and_discharge_current_alarm_status;	 	//(ZTT)
N	signed char 	_battery_total_voltage_alarm_status;			//(ZTT)
N	signed char		_custom_alarm_quantity;							//(ZTT)
N	signed char		_balanced_event_code;							//(ZTT)
N	signed char 	_voltage_event_code;							//(ZTT)
N	signed char 	_temperature_event_code;						//(ZTT)
N	signed char		_current_event_code;							//(ZTT)
N	signed char		_fet_status_code;								//(ZTT)
N	signed short	_balanced_status_code;							//(ZTT)
N	signed char 	_system_status_code;							//(ZTT)
N
N	} LAKB_STAT; 
Nextern LAKB_STAT lakb[3];
Nextern char lakb_damp[1][42];
Nextern char bLAKB_KONF_CH;
Nextern char bLAKB_KONF_CH_old;
Nextern char lakb_ison_mass[7];
Nextern short lakb_mn_ind_cnt;
Nextern char bLAKB_KONF_CH_EN;
Nextern char bRS485ERR;
Nextern short LBAT_STRUKT;
Nextern char lakb_error_cnt;	//счетчик неправильного показания ннапряжения батареи
Nextern short numOfPacks,numOfPacks_;
Nextern short numOfCells, numOfTemperCells, baseOfData;
Nextern short lakb_stat_comm_error;	//аварийность канала связи с литиевыми батареями. 0 означает исправность платы расширения и наличие связи со всеми литиевыми батареями
Nextern short lakbNotErrorNum;		//колличество литиевых батарей с исправной связью
Nextern short lakbKanErrorCnt;		//Счетчик аварийности канала связи с платой расширения
Nextern short lakbKanErrorStat;		//Состояние аварийности канала связи с платой расширения
N
N
N
N//***********************************************
N//Телеметрия по внутренней шине
Nextern char can_slot[12][16];
Nextern char plazma_can_inv[3];
N
N//***********************************************
N//Состояние источников
N
N
Ntypedef struct
N    {
N    enum {dSRC=3,dINV=5,dNET_METR=7,dIBAT_METR=9,dMAKB=11}_device;
N	char _av;
N	//0бит - авария по перегреву
N	//1бит - авария по завышенному Uвых
N	//2бит - авария по заниженному Uвых
N	//3бит - авария по обрыву связи	
N	//4бит - ресурс вентилятора выработан    
N 	enum {bsOFF_AV_NET,bsAPV,bsWRK,bsRDY,bsBL,bsAV}_state;
N    char _cnt;
N     char _cnt_old;
N     char _cnt_more2;
N     char _buff[20]; 
N     //char _av_net;
N     //char _av_u_max;
N     //char _av_u_min;
N     //char _av_temper; 
N     signed _Uii; 
N     signed _Uin;
N     signed _Ii;
N     signed _Ti; 
N     char _flags_tu;
N	 signed _Uisum;
N     //char _flags_tu_old;
N     //char _is_ready;
N     //char _is_wrk;
N     //char _is_link;
N     //char _is_av;
N     signed _vol_u;
N     signed _vol_i;
N     char _is_on_cnt;
N     //int _ist_blok_host_cnt_; //блокирование источников извне(CAN или RS), если не 0 то источник заблокирован.
N     int _ist_blok_host_cnt;
N     short _blok_cnt; //блокирование источников 
N     char _flags_tm;
N	signed short _overload_av_cnt;     
N     signed short _temp_av_cnt;
N     signed short _umax_av_cnt;
N     signed short _umin_av_cnt;
N     signed _rotor;
N     signed  short _x_; 
N     char _adr_ee;
N	char _last_avar;
N	char _vent_resurs_temp[4];
N	unsigned short _vent_resurs;
N	signed short debug_info_to_uku0;
N	signed short debug_info_to_uku1;
N	signed short _avg;
N	signed short _cntrl_stat;
N     } BPS_STAT; 
Nextern BPS_STAT bps[29];
N
N//***********************************************
N//Состояние инверторов
Ntypedef struct
N     {
N	char _av;
N	//0бит - авария по перегреву
N	//1бит - авария по завышенному Uвых
N	//2бит - авария по заниженному Uвых
N	//3бит - авария по обрыву связи	    
N     enum {isAPV,isWRK,isRDY,isBL,isAV,isOFF_AV_NET}_state;
N     char _cnt;
N     char _cnt_old;
N     char _cnt_more2;
N     char _buff[16]; 
N     signed _Uio; 
N     signed _Ii;
N     signed _Ti; 
N	signed _Uil;
N	signed _Uin;
N	signed _Pio;
N     char _flags_tu;
N     signed _vol_u;
N     signed _vol_i;
N     char _is_on_cnt;
N     //int _ist_blok_host_cnt_; //блокирование источников извне(CAN или RS), если не 0 то источник заблокирован.
N     int _ist_blok_host_cnt;
N     short _blok_cnt; //блокирование источников 
N     char _flags_tm;
N	char _flags_tm_old;
N	signed short _overload_av_cnt;     
N     signed short _temp_av_cnt;
N     signed short _umax_av_cnt;
N     signed short _umin_av_cnt;
N     signed _rotor;
N     signed  short _x_; 
N     char _adr_ee;
N	char _last_avar;
N	char _Pnom;
N	char _Uoutmin;
N	char _Uoutmax;
N	char _net_contr_en;
N	char _pwm_en;
N	char _phase_mode;
N
N     } INV_STAT; 
N#ifdef UKU_220_V2
Sextern INV_STAT inv[3];
N#endif
N#ifndef UKU_220_V2
Nextern INV_STAT inv[20];
N#endif
Nextern char first_inv_slot;
N
N//***********************************************
N//Состояние нагрузки
Nextern signed short load_U;
Nextern signed short load_I;
N
N//***********************************************
N//Состояние выхода
Nextern signed short bps_U;
Nextern signed short out_U;
Nextern signed short in_U;
Nextern signed short out_I;
Nextern signed short vd_U;
Nextern signed short bps_I;
Nextern signed short sys_T;
N
N//***********************************************
N//Состояние первичной сети
Nextern signed short net_U,net_Ustore,net_Ua,net_Ub,net_Uc;
Nextern char bFF,bFF_;
Nextern signed short net_F,hz_out,hz_out_cnt,net_F3;
Nextern signed char unet_drv_cnt;
Nextern char net_av;
N
N
Nextern char plazma_plazma_plazma;
N
Nvoid bitmap_hndl(void);
Nvoid ind_hndl(void);
N__irq void timer1_interrupt(void);
N__irq void timer0_interrupt(void); 
N
N
N//***********************************************
N//Состояние внешних датчиков
N//signed short tout[4];
Nextern char tout_max_cnt[4],tout_min_cnt[4];
Ntypedef enum {tNORM,tMAX,tMIN}enum_tout_stat;
Nextern enum_tout_stat tout_stat[4];
Nextern signed short t_ext[3];
Nextern char ND_EXT[3];
Nextern signed char sk_cnt[4],sk_av_cnt[4];
Ntypedef enum  {ssOFF,ssON} enum_sk_stat;
Nextern enum_sk_stat sk_stat[4];
Ntypedef enum  {sasOFF,sasON} enum_sk_av_stat;
Nextern enum_sk_av_stat sk_av_stat[4],sk_av_stat_old[4];
Nextern signed short t_box,t_box_warm,t_box_vent;
Nextern char TELECORE2017_EXT_VENT_PWM,TELECORE2017_INT_VENT_PWM;
N
N//***********************************************
N//Звуки
Nextern BOOL bSILENT;
N
N//***********************************************
N//Тест
Ntypedef enum {tstOFF,tst1,tst2} enum_tst_state;
Nextern enum_tst_state tst_state[15];
N
N//-----------------------------------------------
N//Контроль заряда
Nextern char sign_U[2],sign_I[2];
Nextern char superviser_cnt;
N
N//-----------------------------------------------
N//Плата расширения
Nextern unsigned short adc_buff_ext_[3];
Nextern unsigned short Uvv[3];
Nextern unsigned short Uvv0;
Nextern short pos_vent;
Nextern short t_ext_can;
Nextern char t_ext_can_nd;
N
N//-----------------------------------------------
N//Плата расширения 2
Nextern char eb2_data[30];
Nextern short eb2_data_short[10];
Nextern short Uvv_eb2[3],Upes_eb2[3];
Nextern short Kvv_eb2[3],Kpes_eb2[3];
N
N//-----------------------------------------------
N//Состояние вводов
Nextern signed short vvod_pos;
N
N//-----------------------------------------------
N//Работа со щетчиком
Nextern signed long power_summary;
Nextern signed short power_current;
Nextern signed long power_summary_tempo,power_summary_tempo_old;
Nextern signed short power_current_tempo,power_current_tempo_old;
Nextern char powerSummaryCnt;
Nextern char powerCurrentCnt;
N
N
Nextern char bRESET;
Nextern char bRESET_EXT;
Nextern char bRESET_INT_WDT;
Nextern char bRESET_EXT_WDT;
N
N//-----------------------------------------------
N//Климатконтроль и вентиляторы
Nextern signed short main_vent_pos;
Nextern signed char t_box_cnt;
Ntypedef enum  {mvsOFF,mvsON} enum_mixer_vent_stat;
Nextern enum_mixer_vent_stat mixer_vent_stat;
Ntypedef struct
N     {
N	signed short _T[4];
N	char _nd[4];
N	signed short _T_dispers[4];
N	char _max_dispers_num;
N	signed short _max_dispers;
N    	signed short _avg1;
N	signed short _avg2;
N	char _avg_cnt;
N     } INT_BOX_TEMPER;
Nextern INT_BOX_TEMPER ibt;
Ntypedef enum {tbdsON,tbdsOFF,tbdsMNL} enum_tbatdisable_stat;
Nextern enum_tbatdisable_stat tbatdisable_stat;
Ntypedef enum {tldsON,tldsOFF,tldsMNL} enum_tloaddisable_stat;
Nextern enum_tloaddisable_stat tloaddisable_stat;
Ntypedef enum {atsOFF,atsON} enum_av_tbox_stat;
Nextern enum_av_tbox_stat av_tbox_stat;
Nextern signed short av_tbox_cnt;
Nextern char tbatdisable_cmnd,tloaddisable_cmnd;
Nextern short tbatdisable_cnt,tloaddisable_cnt;
N#ifdef UKU_KONTUR
Sextern short t_box_vent_on_cnt;
Sextern short t_box_warm_on_cnt;
Stypedef enum {vsOFF,vsON} enum_vent_stat;
Sextern enum_vent_stat vent_stat_k;
Stypedef enum {wsOFF,wsON} enum_warm_stat;
Sextern enum_warm_stat warm_stat_k;
N#endif
N
N#ifdef UKU_TELECORE2015
Sextern short t_box_vent_on_cnt;
Sextern short t_box_warm_on_cnt;
Sextern short t_box_vvent_on_cnt;
Stypedef enum {vsOFF,vsON} enum_vent_stat;
Sextern enum_vent_stat vent_stat_k,vvent_stat_k;
Stypedef enum {wsOFF,wsON} enum_warm_stat;
Sextern enum_warm_stat warm_stat_k;
Sextern signed short TELECORE2015_KLIMAT_WARM_ON_temp;
N#endif
N
N#ifdef UKU_TELECORE2017
Sextern short t_box_vent_on_cnt;
Sextern short t_box_warm_on_cnt;
Sextern short t_box_vvent_on_cnt;
Stypedef enum {vsOFF,vsON} enum_vent_stat;
Sextern enum_vent_stat vent_stat_k,vvent_stat_k;
Stypedef enum {wsOFF,wsON} enum_warm_stat;
Sextern enum_warm_stat warm_stat_k;
Sextern signed short TELECORE2017_KLIMAT_WARM_ON_temp;
Sextern signed char t_box_warm_minus20_cnt;
Sextern signed char t_box_warm_plus65_cnt;
Sextern signed char t_box_cool_plus70_cnt;
S#define ULAUNCH UB0
S#define ULINECC UB20
N#endif
N
Nextern char ext_can_cnt;
N
N
Nsigned short abs_pal(signed short in);
Nvoid ADC_IRQHandler(void);
N
N
N//-----------------------------------------------
N//Состояние контролируемых автоматов нагрузки 
Ntypedef enum  {avtOFF,avtON} enum_avt_stat;
Nextern enum_avt_stat avt_stat[12],avt_stat_old[12]; 
N
N//-----------------------------------------------
N//Показания АЦП на плате измерения тока батареи
Nextern signed long ibat_metr_buff_[2];
Nextern short bIBAT_SMKLBR;
Nextern char ibat_metr_cnt;
N
N//-----------------------------------------------
N//Управление низкоприоритетной нагрузкой
Nextern signed short npn_tz_cnt;
Ntypedef enum {npnsOFF=0,npnsON} enum_npn_stat;
Nextern enum_npn_stat npn_stat;
N
Nextern char snmp_plazma;
N
N
Nextern char ips_bat_av_vzvod;
Nextern char ips_bat_av_stat;
N
Nextern char rel_warm_plazma;
Nextern char can_byps_plazma0,can_byps_plazma1;
N
Nextern short plazma_bat_drv0,plazma_bat_drv1,bat_drv_cnt_cnt;
Nextern unsigned short bat_drv_rx_cnt;
Nextern char bat_drv_rx_buff[512];
Nextern char bat_drv_rx_in;
N
Nextern short can_plazma;
N
N//-----------------------------------------------
N//Климатконтроль TELECORE2015	
N#ifdef UKU_TELECORE2015
Sextern signed short TELECORE2015_KLIMAT_WARM_SIGNAL;
Sextern signed short TELECORE2015_KLIMAT_VENT_SIGNAL;
Sextern signed short TELECORE2015_KLIMAT_WARM_ON;
Sextern signed short TELECORE2015_KLIMAT_WARM_OFF;
Sextern signed short TELECORE2015_KLIMAT_CAP;
Sextern signed short TELECORE2015_KLIMAT_VENT_ON;
Sextern signed short TELECORE2015_KLIMAT_VENT_OFF;
Sextern signed short TELECORE2015_KLIMAT_VVENT_ON;
Sextern signed short TELECORE2015_KLIMAT_VVENT_OFF;
N#endif
N
N
N#ifndef FALSE
S#define FALSE   (0)
N#endif
N
N#ifndef TRUE
S#define TRUE    (1)
N#endif
N
N//-----------------------------------------------
N//Ускоренный заряд
Nextern signed short speedChrgCurr;			//максимальный ток ускоренного заряда, отображение из ЕЕПРОМ
Nextern signed short speedChrgVolt;			//максимальное напряжение ускоренного заряда, отображение из ЕЕПРОМ
Nextern signed short speedChrgTimeInHour; 	//максимальное время ускоренного заряда в часах, отображение из ЕЕПРОМ
Nextern signed short speedChrgAvtEn;	 		//Автоматическое включение Ускоренного заряда включено/выключено
Nextern signed short speedChrgDU;	    	//Просадка напряжения необходимая для включения ускоренного заряда
Nextern signed short speedChIsOn;			//Текущее состояние ускоренного заряда вкл/выкл
Nextern signed long  speedChTimeCnt;			//Счетчик времени прямой ускоренного заряда
Nextern signed short speedChrgBlckSrc;		//Источник сигнала блокировки, 0-выкл., 1-СК1, 2-СК2
Nextern signed short speedChrgBlckLog;		//Логика сигнала блокировки, 1 - блокировка по замкнутому СК, 0 - по разомкнутому
Nextern signed short speedChrgBlckStat;		//Сигнал блокировки для выравнивающего и ускоренного заряда.
Nextern char  		speedChrgShowCnt;		//Счетчик показа информационного сообщения
N
N//-----------------------------------------------
N//Блокировка ИПС
Nextern signed short ipsBlckSrc;
Nextern signed short ipsBlckLog;
Nextern signed short ipsBlckStat;
N
N//-----------------------------------------------
N//Контроль выходного напряжения
Nextern signed short outVoltContrHndlCnt;		//Счетчик, считает в плюс в случае выполнения условия аварии
Nextern signed short outVoltContrHndlCnt_;		//Счетчик, считает в плюс в случае отсутствия выполнения условия аварии
Nextern char uout_av;
N
N//-----------------------------------------------
N//Контроль работы вольтдобавки
Nextern char bVDISWORK;
Nextern char vd_is_work_cnt;
N
Nextern short plazma_numOfCells;
Nextern short plazma_numOfTemperCells;
Nextern short plazma_numOfPacks;
N
Nextern char plazma_ztt[2];
Nextern char plazma1809;
N
Nextern U8 socket_tcp;
N
N//-----------------------------------------------
N//Выравнивание токов ИПС
Nextern char ica_plazma[10];
Nextern char ica_timer_cnt;
Nextern signed short ica_my_current;
Nextern signed short ica_your_current;
Nextern signed short ica_u_necc;
Nextern U8 tcp_soc_avg;
Nextern U8 tcp_connect_stat;
N
N//-----------------------------------------------
N//Авария по перегрузке
Nextern short overloadHndlCnt;
Nextern char overloadAvar;
N
N//-----------------------------------------------
N//Авария по выходному напряжению
Nextern short uAvarHndlOutUMaxCnt,uAvarHndlOutUMinCnt;
Nextern char uOutAvar;
N
N//-----------------------------------------------
N//Авария по входному напряжению
Nextern short uAvarHndlInUMaxCnt,uAvarHndlInUMinCnt;
Nextern char uInAvar;
N
N//-----------------------------------------------
N//Авария по температуре системы
Nextern short sysTAvarHndlCnt;
Nextern char sysTAvar;
N
N//***********************************************
N//Состояния аварий для реле
Nextern short rele_av_flags;
Nextern short avar_vd_stat;
N
Nextern short pvlk;
N//-----------------------------------------------
N//Ресурс вентиляторов
N//extern char vent_resurs_temp[4];
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
L 13 "main.c" 2
N#include "simbol.h"
L 1 "simbol.h" 1
N
Nconst char caracter[1536]={
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,
N0x3E,0x1C,0x08,0x00,0x00,0x08,0x0C,0x0E,
N0x0C,0x08,0x7f,0x49,0x51,0x49,0x45,0x7f,
N0x7f,0x41,0x41,0x41,0x41,0x7f,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x5F,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x14,0x3E,0x14,0x3E,0x14,
N0x00,0x24,0x2A,0x7F,0x2A,0x12,0x00,0x23,
N0x13,0x08,0x64,0x62,0x00,0x36,0x49,0x55,
N0x22,0x50,0x00,0x00,0x00,0x00,0x06,0x00,
N0x00,0x00,0x3E,0x41,0x00,0x00,0x00,0x00,
N0x00,0x41,0x3E,0x00,0x00,0x14,0x08,0x3E,
N0x08,0x14,0x00,0x08,0x08,0x3E,0x08,0x08,
N0x00,0x00,0x50,0x30,0x00,0x00,0x00,0x08,
N0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x60,
N0x60,0x00,0x00,0x40,0x20,0x10,0x08,0x04,
N0x00,0x3E,0x51,0x49,0x45,0x3E,0x00,0x00,
N0x42,0x7F,0x40,0x00,0x00,0x42,0x61,0x51,
N0x49,0x46,0x00,0x21,0x41,0x45,0x4B,0x31,
N0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x27,
N0x45,0x45,0x45,0x39,0x00,0x3C,0x4A,0x49,
N0x49,0x30,0x00,0x01,0x71,0x09,0x05,0x03,
N0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x06,
N0x49,0x49,0x29,0x1E,0x00,0x00,0x36,0x36,
N0x00,0x00,0x00,0x00,0x56,0x36,0x00,0x00,
N0x00,0x00,0x08,0x14,0x22,0x00,0x00,0x14,
N0x14,0x14,0x14,0x14,0x00,0x00,0x22,0x14,
N0x08,0x00,0x00,0x02,0x01,0x51,0x09,0x06,
N0x00,0x32,0x49,0x79,0x41,0x3E,0x00,0x7E,
N0x11,0x11,0x11,0x7E,0x00,0x7F,0x49,0x49,
N0x49,0x36,0x00,0x3E,0x41,0x41,0x41,0x22,
N0x00,0x7F,0x41,0x41,0x22,0x1C,0x00,0x7F,
N0x49,0x49,0x49,0x41,0x00,0x7F,0x09,0x09,
N0x09,0x01,0x00,0x3E,0x41,0x41,0x51,0x72,
N0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00,
N0x41,0x7F,0x41,0x00,0x00,0x20,0x40,0x41,
N0x3F,0x01,0x00,0x7F,0x08,0x14,0x22,0x41,
N0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x7F,
N0x02,0x0C,0x02,0x7F,0x00,0x7F,0x04,0x08,
N0x10,0x7F,0x00,0x3E,0x41,0x41,0x41,0x3E,
N0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x3E,
N0x41,0x51,0x21,0x5E,0x00,0x7F,0x09,0x19,
N0x29,0x46,0x00,0x46,0x49,0x49,0x49,0x31,
N0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x3F,
N0x40,0x40,0x40,0x3F,0x00,0x1F,0x20,0x40,
N0x20,0x1F,0x00,0x3F,0x40,0x38,0x40,0x3F,
N0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x07,
N0x08,0x70,0x08,0x07,0x00,0x61,0x51,0x49,
N0x45,0x43,0x00,0x00,0x7F,0x41,0x00,0x00,
N0x00,0x04,0x08,0x10,0x20,0x40,0x00,0x00,
N0x00,0x41,0x7F,0x00,0x00,0x04,0x02,0x01,
N0x02,0x04,0x00,0x40,0x40,0x40,0x40,0x40,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
N0x54,0x54,0x54,0x78,0x00,0x7F,0x48,0x44,
N0x44,0x38,0x00,0x38,0x44,0x44,0x44,0x20,
N0x00,0x30,0x48,0x48,0x50,0x7E,0x00,0x38,
N0x54,0x54,0x54,0x18,0x00,0x08,0x7E,0x09,
N0x01,0x02,0x00,0x08,0x54,0x54,0x54,0x3C,
N0x00,0x7F,0x10,0x08,0x08,0x70,0x00,0x00,
N0x44,0x7D,0x40,0x00,0x00,0x20,0x40,0x44,
N0x3D,0x00,0x00,0x7E,0x10,0x28,0x44,0x00,
N0x00,0x00,0x41,0x7F,0x40,0x00,0x00,0x7C,
N0x04,0x18,0x04,0x78,0x00,0x7C,0x08,0x04,
N0x04,0x78,0x00,0x38,0x44,0x44,0x44,0x38,
N0x00,0x7C,0x14,0x14,0x14,0x08,0x00,0x08,
N0x14,0x14,0x14,0x7C,0x00,0x7C,0x08,0x04,
N0x04,0x08,0x00,0x48,0x54,0x54,0x54,0x20,
N0x00,0x04,0x3F,0x44,0x40,0x20,0x00,0x3C,
N0x40,0x40,0x20,0x7C,0x00,0x1C,0x20,0x40,
N0x20,0x1C,0x00,0x3C,0x40,0x30,0x40,0x3C,
N0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x0C,
N0x50,0x50,0x50,0x3C,0x00,0x44,0x64,0x54,
N0x4C,0x44,0x00,0x00,0x08,0x36,0x41,0x00,
N0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,
N0x41,0x36,0x08,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x04,0x06,0x07,
N0x06,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x08,0x1C,0x3E,
N0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x7F,0x3E,0x1C,0x08,0x00,0x08,0x18,
N0x38,0x18,0x08,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x1C,0x3E,0x3E,0x3E,0x1C,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x7C,0x55,0x54,0x45,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x06,0x09,0x09,0x06,0x00,0x00,
N0x24,0x2E,0x24,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x38,0x55,0x54,0x55,0x18,0x00,0x7C,
N0x10,0x20,0x7B,0x0B,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
N0x00,0x00,0x20,0x30,0x38,0x30,0x20,0x00,
N0x00,0x7E,0x11,0x11,0x11,0x7E,0x00,0x7F,
N0x49,0x49,0x49,0x31,0x00,0x7F,0x49,0x49,
N0x49,0x36,0x00,0x7F,0x01,0x01,0x01,0x03,
N0x00,0x60,0x3E,0x21,0x21,0x7F,0x00,0x7F,
N0x49,0x49,0x49,0x41,0x00,0x77,0x08,0x7F,
N0x08,0x77,0x00,0x41,0x49,0x49,0x49,0x36,
N0x00,0x7F,0x20,0x10,0x08,0x7F,0x00,0x7F,
N0x20,0x11,0x08,0x7F,0x00,0x7F,0x08,0x14,
N0x22,0x41,0x00,0x40,0x7E,0x01,0x01,0x7F,
N0x00,0x7F,0x02,0x0C,0x02,0x7F,0x00,0x7F,
N0x08,0x08,0x08,0x7F,0x00,0x3E,0x41,0x41,
N0x41,0x3E,0x00,0x7F,0x01,0x01,0x01,0x7F,
N0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x3E,
N0x41,0x41,0x41,0x22,0x00,0x01,0x01,0x7F,
N0x01,0x01,0x00,0x47,0x28,0x10,0x08,0x07,
N0x00,0x1C,0x22,0x7F,0x22,0x1C,0x00,0x63,
N0x14,0x08,0x14,0x63,0x00,0x7F,0x40,0x40,
N0x40,0xFF,0x00,0x07,0x08,0x08,0x08,0x7F,
N0x00,0x7F,0x40,0x7F,0x40,0x7F,0x00,0x7F,
N0x40,0x7F,0x40,0xFF,0x00,0x01,0x7F,0x48,
N0x48,0x70,0x00,0x7F,0x44,0x38,0x00,0x7F,
N0x00,0x7F,0x48,0x48,0x48,0x30,0x00,0x22,
N0x41,0x49,0x49,0x3E,0x00,0x7F,0x08,0x3E,
N0x41,0x3E,0x00,0x46,0x29,0x19,0x09,0x7F,
N0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x3C,
N0x4A,0x4A,0x49,0x31,0x00,0x7C,0x54,0x54,
N0x28,0x00,0x00,0x7C,0x04,0x04,0x04,0x0C,
N0x00,0x60,0x38,0x24,0x24,0x7C,0x00,0x38,
N0x54,0x54,0x54,0x18,0x00,0x6C,0x10,0x7C,
N0x10,0x6C,0x00,0x44,0x44,0x54,0x54,0x28,
N0x00,0x7C,0x20,0x10,0x08,0x7C,0x00,0x7C,
N0x20,0x12,0x08,0x7C,0x00,0x7C,0x10,0x28,
N0x44,0x00,0x00,0x40,0x38,0x04,0x04,0x7C,
N0x00,0x7C,0x08,0x10,0x08,0x7C,0x00,0x7C,
N0x10,0x10,0x10,0x7C,0x00,0x38,0x44,0x44,
N0x44,0x38,0x00,0x7C,0x04,0x04,0x04,0x7C,
N0x00,0x7C,0x14,0x14,0x14,0x08,0x00,0x38,
N0x44,0x44,0x44,0x00,0x00,0x04,0x04,0x7C,
N0x04,0x04,0x00,0x0C,0x50,0x50,0x50,0x3C,
N0x00,0x18,0x24,0x7E,0x24,0x18,0x00,0x44,
N0x28,0x10,0x28,0x44,0x00,0x7C,0x40,0x40,
N0x40,0xFC,0x00,0x00,0x1C,0x10,0x10,0x7C,
N0x00,0x7C,0x40,0x7C,0x40,0x7C,0x00,0x7C,
N0x40,0x7C,0x40,0xFC,0x00,0x04,0x7C,0x50,
N0x50,0x20,0x00,0x7C,0x50,0x20,0x00,0x7C,
N0x00,0x7C,0x50,0x50,0x50,0x20,0x00,0x28,
N0x44,0x54,0x54,0x38,0x00,0x7C,0x10,0x38,
N0x44,0x38,0x00,0x08,0x54,0x34,0x14,0x7C};
L 14 "main.c" 2
N#include "25lc640.h"
L 1 "25lc640.h" 1
N
N#define LC640_CS 20
N#define CS_ON       LPC_GPIO0->FIODIR|=(1UL<<LC640_CS);LPC_GPIO0->FIOCLR|=(1UL<<LC640_CS);
N#define CS_OFF      LPC_GPIO0->FIODIR|=(1UL<<LC640_CS);LPC_GPIO0->FIOSET|=(1UL<<LC640_CS);
N
N
N
N
N
N
N
N
Nchar spi1(char in);
Nvoid spi1_config(void);
Nvoid spi1_config_mcp2515(void);
Nvoid spi1_unconfig(void);
Nvoid lc640_wren(void);
Nchar lc640_rdsr(void);
Nint lc640_read(int ADR);
Nint lc640_read_int(int ADR);
Nlong lc640_read_long(int ADR);
Nvoid lc640_read_long_ptr(int ADR,char* out_ptr);
Nvoid lc640_read_str(int ADR, char* ram_ptr, char num);
Nchar lc640_write(int ADR,char in);
Nchar lc640_write_int(short ADR,short in);
Nchar lc640_write_long(int ADR,long in);
Nchar lc640_write_long_ptr(int ADR,char* in);
L 15 "main.c" 2
N#include "Timer.h"
L 1 "Timer.h" 1
N/*****************************************************************************
N *   timer.h:  Header file for NXP LPC17xx Family Microprocessors
N *
N *   Copyright(C) 2009, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2009.05.26  ver 1.00    Prelimnary version, first Release
N *
N******************************************************************************/
N#ifndef __TIMER_H 
N#define __TIMER_H
N
N	
N#define TIME_INTERVAL	(9000000/100 - 1)
N
Nextern void delayMs(uint8_t timer_num, uint32_t delayInMs);
Nextern uint32_t init_timer( uint8_t timer_num, uint32_t timerInterval );
Nextern void enable_timer( uint8_t timer_num );
Nextern void disable_timer( uint8_t timer_num );
Nextern void reset_timer( uint8_t timer_num );
Nextern void TIMER0_IRQHandler (void);
Nextern void TIMER1_IRQHandler (void);
N
N#endif /* end __TIMER_H */
N/*****************************************************************************
N**                            End Of File
N******************************************************************************/
L 16 "main.c" 2
N#include "gran.h"
L 1 "gran.h" 1
N
Nvoid gran_ring_char(signed char *adr, signed char min, signed char max) ;
Nvoid gran_char(signed char *adr, signed char min, signed char max);
Nvoid gran(signed short *adr, signed short min, signed short max);
Nvoid gran_ring(signed short *adr, signed short min, signed short max);
Nvoid gran_long(signed long *adr, signed long min, signed long max); 
L 17 "main.c" 2
N#include "uart0.h"
L 1 "uart0.h" 1
N
N#define RX_BUFFER_SIZE0 1024
N#define TX_BUFFER_SIZE0 1024
N
N#define BUFSIZE    		1024
N
N#define IER_RBR		0x01
N#define IER_THRE		0x02
N#define IER_RLS		0x04
N
N#define PT	(UIB0[1]&0x80)
N#define C_D	(UIB0[1]&0x40)
N#define FR	(UIB0[1]&0x20)
N
N#define IIR_PEND	0x01
N#define IIR_RLS		0x03
N#define IIR_RDA		0x02
N#define IIR_CTI		0x06
N#define IIR_THRE	0x01
N
N#define LSR_RDR		0x01
N#define LSR_OE		0x02
N#define LSR_PE		0x04
N#define LSR_FE		0x08
N#define LSR_BI		0x10
N#define LSR_THRE	0x20
N#define LSR_TEMT	0x40
N#define LSR_RXFE	0x80
N
N#define VIC_UART0	6
N
Nextern char bRXIN0;
Nextern char UIB0[100];
Nextern char flag0;
Nextern char rx_buffer0[RX_BUFFER_SIZE0];
Xextern char rx_buffer0[1024];
Nextern unsigned char tx_buffer0[TX_BUFFER_SIZE0];
Xextern unsigned char tx_buffer0[1024];
Nextern unsigned short rx_wr_index0,rx_rd_index0,rx_counter0;
Nextern unsigned short tx_wr_index0,tx_rd_index0,tx_counter0;
Nextern char rx_buffer_overflow0;
Nextern char plazma_uart0;
Nextern char memo_out[50];
Nextern char data_rs[50];
Nextern char data_rs0[50];
Nextern const char Table87[];
Nextern const char Table95[]; 
N
Nchar crc_87(char* ptr,char num);
Nchar crc_95(char* ptr,char num);
Nvoid putchar0(char c);
Nvoid uart_out0 (char num,char data0,char data1,char data2,char data3,char data4,char data5);
Nvoid uart_out_adr0 (char *ptr, char len);
Nvoid uart0_init(void);
Nchar getchar0(void);
N__irq void uart0_interrupt(void);
Nvoid uart_in_an0(void);
Nsigned short index_offset0 (signed short index,signed short offset);
Nchar control_check0(signed short index);
Nvoid uart_in0(void);
Nvoid uart_out_adr_block (unsigned long adress,char *ptr, char len);
Nvoid rs232_data_out(void);
Nvoid rs232_data_out_tki(void);
Nvoid uart_out_buff0 (char *ptr, char len);
Nvoid rs232_data_out_1(void);
Nuint32_t UARTInit( uint32_t PortNum, uint32_t baudrate );
N
L 18 "main.c" 2
N#include "uart1.h"
L 1 "uart1.h" 1
N#define RX_BUFFER_SIZE1 100
N#define TX_BUFFER_SIZE1 300
N
N#define PT1	(UIB1[1]&0x80)
N#define C_D1	(UIB1[1]&0x40)
N#define FR1	(UIB1[1]&0x20)
N
N#define VIC_UART1 	7
N
Nextern char bRXIN1;
Nextern char UIB1[20];
Nextern char flag1;
Nextern char rx_buffer1[RX_BUFFER_SIZE1];
Xextern char rx_buffer1[100];
Nextern char tx_buffer1[TX_BUFFER_SIZE1];
Xextern char tx_buffer1[300];
Nextern unsigned short rx_wr_index1,rx_rd_index1,rx_counter1;
Nextern unsigned short tx_wr_index1,tx_rd_index1,tx_counter1;
Nextern char rx_buffer_overflow1;
Nextern char plazma_uart1;
Nextern char uart1_mess[10];
Nextern char data_rs1[40];
Ntypedef enum {ursMEGA=0x55,ursXPORT=0xaa}enum_usart1_router_stat;
Nextern enum_usart1_router_stat usart1_router_stat;
Nextern char usart1_router_wrk;
Nextern char memo_out1[100];
N//extern char suzz[4];
Nextern char UIB10[30];
Nextern char usart1_router_cnt;
Nextern char plazma_suz[5];
N
Nvoid putchar1(char c);
Nvoid uart_out1 (char num,char data0,char data1,char data2,char data3,char data4,char data5);
Nvoid uart_out_adr1 (char *ptr, unsigned char len);
Nvoid uart1_init(void);
Nchar getchar1(void);
N__irq void uart1_interrupt(void);
Nvoid uart_in_an1(void);
Nchar index_offset1 (signed char index,signed char offset);
Nchar control_check1(char index);
Nvoid uart_in1(void);
N
L 19 "main.c" 2
N#include "uart2.h"
L 1 "uart2.h" 1
N
N#define RX_BUFFER_SIZE2 1024
N#define TX_BUFFER_SIZE2 1024
N
N//#define BUFSIZE    		1024
N
N#define IER_RBR		0x01
N#define IER_THRE		0x02
N#define IER_RLS		0x04
N
N//#define PT	(UIB2[1]&0x80)
N//#define C_D	(UIB2[1]&0x40)
N//#define FR	(UIB2[1]&0x20)
N
N#define IIR_PEND	0x01
N#define IIR_RLS		0x03
N#define IIR_RDA		0x02
N#define IIR_CTI		0x06
N#define IIR_THRE	0x01
N
N#define LSR_RDR		0x01
N#define LSR_OE		0x02
N#define LSR_PE		0x04
N#define LSR_FE		0x08
N#define LSR_BI		0x10
N#define LSR_THRE	0x20
N#define LSR_TEMT	0x40
N#define LSR_RXFE	0x80
N
N
Nextern char bRXIN2;
Nextern char UIB2[100];
Nextern char flag2;
Nextern char rx_buffer2[RX_BUFFER_SIZE2];
Xextern char rx_buffer2[1024];
Nextern char tx_buffer2[TX_BUFFER_SIZE2];
Xextern char tx_buffer2[1024];
Nextern unsigned short rx_wr_index2,rx_rd_index2,rx_counter2;
Nextern unsigned short tx_wr_index2,tx_rd_index2,tx_counter2;
Nextern char rx_buffer_overflow2;
Nextern char plazma_uart2;
Nextern char memo_out2[50];
Nextern char data_rs2[50];
Nextern char data_rs02[50];
N
Nvoid putchar2(char c);
Nvoid uart_out2 (char num,char data0,char data1,char data2,char data3,char data4,char data5);
Nvoid uart_out_adr2 (char *ptr, char len);
Nvoid uart0_init(void);
Nchar getchar0(void);
N__irq void uart0_interrupt(void);
Nvoid uart_in_an2(void);
Nsigned short index_offset2 (signed short index,signed short offset);
Nchar control_check2(signed short index);
Nvoid uart_in0(void);
Nvoid uart_out_adr2_block (unsigned long adress,char *ptr, char len);
Nuint32_t UART_2_Init(uint32_t baudrate );
Nvoid uart_in2(void); 
N
N
L 20 "main.c" 2
N#include "cmd.h"
L 1 "cmd.h" 1
N//-----------------------------------------------
N// Символы передач
N#define REGU 0xf5
N#define REGI 0xf6
N#define GetTemp 0xfc
N#define TVOL0 0x75
N#define TVOL1 0x76
N#define TVOL2 0x77
N#define TVOL3 0x78
N#define TVOL4 0x79
N#define TVOL5 0x7A
N#define TVOL6 0x7A
N#define TVOL7 0x7A
N#define TTEMPER	0x7c
N#define CSTART  0x1a
N#define CMND	0x16
N#define Blok_flip	0x57
N#define END 	0x0A
N#define QWEST	0x25
N#define IM	0x52
N#define ADD_KF 0x60
N#define SUB_KF 0x61
N#define Zero_kf0 0x63
N#define Zero_kf2 0x64
N#define MEM_KF 0x62
N#define BLKON 0x80
N#define BLKOFF 0x81
N#define Put_reg 0x90
N#define PUTID 0x91
N#define PUTTM1 0xDA
N#define PUTTM2 0xDB
N#define PUTTM3 0xDC
N#define PUTTM1INV2 0xDD
N#define PUTTM2INV2 0xDE
N#define PUTTM3INV2 0xDf
N#define PUTTM_NET 0xEA
N#define PUTTM_NET1 0xEB
N#define PUTTM_IBATMETER 0xD1
N#define GETTM_IBATMETER 0x1d
N#define PUTTM 0xDE
N#define GETTM 0xED 
N#define GETTM_INV 0xFD 
N#define GET_MAKB 0xE1 
N#define PUTTM_MAKB1		0xE2
N#define PUTTM_MAKB2		0xE3
N#define PUTTM_MAKB3		0xE4
N#define KLBR 0xEE
N#define KLBR_MAKB 0xEF
N#define MEM_KF 0x62 
N#define MEM_KF1 0x26
N#define ALRM_RES 0x63
N#define VENT_RES 0x64
N#define PUTTM1BYPS 0xD8
N#define PUTTM2BYPS 0xD9
N#define PUT_LB_TM1 	0x18
N#define PUT_LB_TM2 	0x78
N#define PUT_LB_TM3 	0x38
N#define PUT_LB_TM4 	0x48
N#define PUT_LB_TM5 	0x58
N#define PUT_LB_TM6 	0x68
N#define PUT_ZTT_TM1 	0xC1
N#define PUT_ZTT_TM2 	0xC2
N#define PUT_ZTT_TM3 	0xC3
N#define PUT_ZTT_TM4 	0xC4
N#define PUT_ZTT_TM5 	0xC5
N#define PUT_ZTT_TM6 	0xC6
N#define PUT_ZTT_TM7 	0xC7
N#define PUT_ZTT_TM8 	0xC8
L 21 "main.c" 2
N#include "ret.h"
L 1 "ret.h" 1
N#ifndef _RET_H_
N
N#define _RET_H_
N
Nextern char retind,retsub,retindsec;
Nextern int retcnt,retcntsec;
Nextern unsigned char f0,fc0,f1,fc1;
Nextern short ret_duty;
N
Nvoid ret_ind(char r_i,char r_s,int r_c);
Nvoid ret_ind_hndl(void);
Nvoid ret_ind_sec(char r_i,int r_c);
Nvoid ret_ind_sec_hndl(void);
Nvoid ret(short duty);
Nvoid ret_hndl(void);
N
N#endif
N
N
N//
N
N
N
N 
N
N     
L 22 "main.c" 2
N#include "eeprom_map.h"
L 1 "eeprom_map.h" 1
N
N#define EE_CAN_RESET_CNT	0x06
N#define RESET_CNT	0x08
N
N#define SECTOR_KOEF 0x10
N
N#define EE_KUBAT1		SECTOR_KOEF
N#define EE_KUBAT2		SECTOR_KOEF+2
N#define EE_KI0BAT1		SECTOR_KOEF+4
N#define EE_KI0BAT2		SECTOR_KOEF+6
N#define EE_KI1BAT1		SECTOR_KOEF+8
N#define EE_KI1BAT2		SECTOR_KOEF+10
N#define EE_KTBAT1		SECTOR_KOEF+12
N#define EE_KTBAT2		SECTOR_KOEF+14
N#define EE_KUNET       	SECTOR_KOEF+16
N#define EE_KFNET       	SECTOR_KOEF+18
N#define EE_KULOAD       	SECTOR_KOEF+20
N#define  EE_KUNET_EXT0   SECTOR_KOEF+22
N#define  EE_KUNET_EXT1   SECTOR_KOEF+24
N#define  EE_KUNET_EXT2   SECTOR_KOEF+26
N#define EE_KUBATM1		SECTOR_KOEF+28
N#define EE_KUBATM2		SECTOR_KOEF+30
N#define EE_KVV0_EB2		SECTOR_KOEF+32
N#define EE_KVV1_EB2		SECTOR_KOEF+34
N#define EE_KVV2_EB2		SECTOR_KOEF+36
N#define EE_KPES0_EB2	SECTOR_KOEF+38
N#define EE_KPES1_EB2	SECTOR_KOEF+40
N#define EE_KPES2_EB2	SECTOR_KOEF+42
N#define EE_KUNETA      	SECTOR_KOEF+44
N#define EE_KUNETB      	SECTOR_KOEF+46
N#define EE_KUNETC      	SECTOR_KOEF+48
N#define EE_KUBPS      	SECTOR_KOEF+50
N#define EE_KUOUT      	SECTOR_KOEF+52
N#define EE_KUVD      	SECTOR_KOEF+54
N
N#define SECTOR_SETS 	SECTOR_KOEF+100
N
N#define EE_MAIN_IST 	SECTOR_SETS+2
N#define EE_UMAX    		SECTOR_SETS+4
N#define EE_UOUT    		SECTOR_SETS+6
N#define EE_UAVT    		SECTOR_SETS+8
N#define EE_TMAX			SECTOR_SETS+10
N#define EE_AV_OFF_AVT   SECTOR_SETS+12
N#define EE_USIGN		SECTOR_SETS+14
N#define EE_UMN			SECTOR_SETS+16
N#define EE_ZV_ON		SECTOR_SETS+18
N#define EE_IKB			SECTOR_SETS+20
N#define EE_KVZ			SECTOR_SETS+22
N#define EE_IMAX		SECTOR_SETS+24
N#define EE_IMIN		SECTOR_SETS+26
N#define EE_APV_ON		SECTOR_SETS+28
N#define EE_IZMAX		SECTOR_SETS+30
N#define EE_U0B			SECTOR_SETS+32
N#define EE_TZAS		SECTOR_SETS+34
N#define EE_NUMIST  		SECTOR_SETS+36
N#define EE_NUMINV  		SECTOR_SETS+38
N#define KI0SRC1     	SECTOR_SETS+40
N#define KI0SRC2     	SECTOR_SETS+42
N#define EE_APV_ON1  	SECTOR_SETS+44
N#define EE_APV_ON2  	SECTOR_SETS+46
N#define EE_APV_ON2_TIME  SECTOR_SETS+48
N#define KT_EXT0		SECTOR_SETS+50
N#define KT_EXT1		SECTOR_SETS+52
N#define KT_EXT2		SECTOR_SETS+54
N#define EE_AVZ_TIME		SECTOR_SETS+56
N#define EE_HOUR_AVZ		SECTOR_SETS+58	
N#define EE_MIN_AVZ  	SECTOR_SETS+60
N#define EE_SEC_AVZ  	SECTOR_SETS+62
N#define EE_DATE_AVZ 	SECTOR_SETS+64
N#define EE_MONTH_AVZ	SECTOR_SETS+66
N#define EE_YEAR_AVZ 	SECTOR_SETS+68
N#define EE_AVZ			SECTOR_SETS+70
N#define EE_MNEMO_ON 	SECTOR_SETS+72
N#define EE_MNEMO_TIME 	SECTOR_SETS+74
N#define EE_VZ_HR		SECTOR_SETS+76
N#define EE_TBAT          SECTOR_SETS+78
N#define EE_U_AVT         SECTOR_SETS+80
N#define EE_TSIGN		SECTOR_SETS+82
N#define EE_DU			SECTOR_SETS+84
N#define EE_PAR			SECTOR_SETS+86
N#define EE_TBATMAX		SECTOR_SETS+88
N#define EE_TBATSIGN		SECTOR_SETS+90
N#define EE_TBOXMAX		SECTOR_SETS+92
N#define EE_TBOXREG		SECTOR_SETS+94
N#define EE_TBOXVENTMAX	SECTOR_SETS+96
N#define EE_TLOADDISABLE	SECTOR_SETS+98
N#define EE_TLOADENABLE	SECTOR_SETS+100
N#define EE_TBATDISABLE	SECTOR_SETS+102
N#define EE_TBATENABLE	SECTOR_SETS+104
N#define EE_TSYSMAX		SECTOR_SETS+106
N#define EE_RELE_VENT_LOGIC	SECTOR_SETS+108
N#define EE_TVENTON		SECTOR_SETS+110
N#define EE_TVENTOFF	SECTOR_SETS+112	
N#define EE_RELEVENTSIGN	 SECTOR_SETS+114
N#define EE_NPN_OUT	 SECTOR_SETS+116
N#define EE_NPN_SIGN	 SECTOR_SETS+118
N#define EE_UONPN	 SECTOR_SETS+120
N#define EE_UVNPN	 SECTOR_SETS+122
N#define EE_TZNPN	 SECTOR_SETS+124
N#define EE_TERMOKOMP	 	SECTOR_SETS+126
N#define EE_TBOXVENTON	 	SECTOR_SETS+128
N#define EE_TBOXVENTOFF	 	SECTOR_SETS+130
N#define EE_TBOXWARMON	 	SECTOR_SETS+132 
N#define EE_TBOXWARMOFF	 	SECTOR_SETS+134
N#define EE_NUMBYPASS	 	SECTOR_SETS+136
N#define EE_TWARMON			SECTOR_SETS+138
N#define EE_TWARMOFF			SECTOR_SETS+140
N#define EE_BAT_TYPE			SECTOR_SETS+142
N#define EE_UINMAX			SECTOR_SETS+144
N#define EE_UINMIN			SECTOR_SETS+146
N#define EE_UOUTMAX			SECTOR_SETS+148
N#define EE_UOUTMIN			SECTOR_SETS+150
N#define EE_TELECORE2015_KLIMAT_WARM_SIGNAL	SECTOR_SETS+144
N#define EE_TELECORE2015_KLIMAT_WARM_ON		SECTOR_SETS+146
N#define EE_TELECORE2015_KLIMAT_WARM_OFF		SECTOR_SETS+148
N#define EE_TELECORE2015_KLIMAT_CAP			SECTOR_SETS+150
N#define EE_TELECORE2015_KLIMAT_VENT_ON		SECTOR_SETS+152
N#define EE_TELECORE2015_KLIMAT_VENT_OFF		SECTOR_SETS+154
N#define EE_TELECORE2015_KLIMAT_VVENT_ON		SECTOR_SETS+156
N#define EE_TELECORE2015_KLIMAT_VVENT_OFF	SECTOR_SETS+158
N#define EE_TELECORE2015_KLIMAT_VENT_SIGNAL	SECTOR_SETS+160
N#define EE_SPEED_CHRG_CURR		 			SECTOR_SETS+162
N#define EE_SPEED_CHRG_VOLT		 			SECTOR_SETS+164
N#define EE_SPEED_CHRG_TIME					SECTOR_SETS+166
N#define EE_SPEED_CHRG_AVT_EN				SECTOR_SETS+168	
N#define EE_SPEED_CHRG_D_U					SECTOR_SETS+170
N#define EE_SPEED_CHRG_BLOCK_SRC				SECTOR_SETS+172
N#define EE_SPEED_CHRG_BLOCK_LOG				SECTOR_SETS+174
N#define EE_DU_LI_BAT						SECTOR_SETS+176
N#define EE_FORVARDBPSCHHOUR					SECTOR_SETS+178
N#define EE_FORVBPSHOURCNT					SECTOR_SETS+180
N#define EE_U_OUT_KONTR_MAX					SECTOR_SETS+182
N#define EE_U_OUT_KONTR_MIN					SECTOR_SETS+184
N#define EE_U_OUT_KONTR_DELAY				SECTOR_SETS+186
N#define EE_DOP_RELE_FUNC					SECTOR_SETS+188
N#define EE_IPS_BLOCK_SRC			   		SECTOR_SETS+190
N#define EE_IPS_BLOCK_LOG					SECTOR_SETS+192
N#define EE_NUMBAT_TELECORE					SECTOR_SETS+194
N#define EE_CNTRL_HNDL_TIME					SECTOR_SETS+196
N#define EE_USODERG_LI_BAT					SECTOR_SETS+198
N#define EE_TELECORE2017_KLIMAT_WARM_SIGNAL	EE_TELECORE2015_KLIMAT_WARM_SIGNAL
N#define EE_TELECORE2017_KLIMAT_VENT_SIGNAL	EE_TELECORE2015_KLIMAT_VENT_SIGNAL
N#define EE_TELECORE2017_KLIMAT_WARM_ON		EE_TELECORE2015_KLIMAT_WARM_ON
N#define EE_TELECORE2017_KLIMAT_WARM_OFF		EE_TELECORE2015_KLIMAT_WARM_OFF
N#define EE_TELECORE2017_KLIMAT_CAP			EE_TELECORE2015_KLIMAT_CAP
N#define EE_TELECORE2017_KLIMAT_VENT_ON0		SECTOR_SETS+200
N#define EE_TELECORE2017_KLIMAT_VENT_ON20	SECTOR_SETS+202
N#define EE_TELECORE2017_KLIMAT_VENT_ON40	SECTOR_SETS+204
N#define EE_TELECORE2017_KLIMAT_VENT_ON60	SECTOR_SETS+206
N#define EE_TELECORE2017_KLIMAT_VENT_ON80	SECTOR_SETS+208
N#define EE_TELECORE2017_KLIMAT_VENT_ON100	SECTOR_SETS+210
N#define EE_TELECORE2017_KLIMAT_DVENT_ON0	SECTOR_SETS+212
N#define EE_TELECORE2017_KLIMAT_DVENT_ON20	SECTOR_SETS+214
N#define EE_RELE_SET_MASK0					SECTOR_SETS+216
N#define EE_RELE_SET_MASK1					SECTOR_SETS+218
N#define EE_RELE_SET_MASK2					SECTOR_SETS+220
N#define EE_RELE_SET_MASK3					SECTOR_SETS+222
N#define EE_AUSW_MAIN 						SECTOR_SETS+224
N#define EE_AUSW_MAIN_NUMBER 				SECTOR_SETS+226 
N#define EE_AUSW_UKU_NUMBER					SECTOR_SETS+228
N
N#ifdef UKU_TELECORE2017
S#define EE_TELECORE2017_ULINECC			EE_UB0
S#define EE_TELECORE2017_Q				EE_MAIN_IST	
S#define EE_TELECORE2017_IZMAX1			EE_DU_LI_BAT
S#define EE_TELECORE2017_IZMAX2			EE_MNEMO_ON
S#define EE_TELECORE2017_K1				EE_UB20
S#define EE_TELECORE2017_K2				EE_KVZ	
S#define EE_TELECORE2017_K3				EE_IZMAX
S#define EE_TELECORE2017_T4				EE_NUMINV
N#endif
N
N#define SECTOR_AUSW  		SECTOR_KOEF+300
N
N
N
N/*#define EE_AUSW_UKU 		SECTOR_AUSW+4 
N#define EE_AUSW_UKU_SUB 		SECTOR_AUSW+6*/
N
N/*#define EE_AUSW_DAY			SECTOR_AUSW+10
N#define EE_AUSW_MONTH		SECTOR_AUSW+12
N#define EE_AUSW_YEAR		SECTOR_AUSW+14
N#define EE_AUSW_BPS1_NUMBER	SECTOR_AUSW+16		
N#define EE_AUSW_BPS2_NUMBER	SECTOR_AUSW+18
N#define EE_AUSW_RS232		SECTOR_AUSW+20
N#define EE_AUSW_PDH			SECTOR_AUSW+22
N#define EE_AUSW_SDH			SECTOR_AUSW+24
N#define EE_AUSW_ETH			SECTOR_AUSW+26 */
N
N#define SECTOR_SETS2  					SECTOR_KOEF+350
N#define EE_QSODERG_LI_BAT				SECTOR_SETS2
N#define EE_TVENTMAX						SECTOR_SETS2+2
N#define EE_ICA_CH 						SECTOR_SETS2+4
N#define EE_ICA_EN						SECTOR_SETS2+6
N#define EE_ICA_MODBUS_ADDRESS			SECTOR_SETS2+8
N#define EE_ICA_MODBUS_TCP_IP1			SECTOR_SETS2+10
N#define EE_ICA_MODBUS_TCP_IP2			SECTOR_SETS2+12
N#define EE_ICA_MODBUS_TCP_IP3			SECTOR_SETS2+14
N#define EE_ICA_MODBUS_TCP_IP4			SECTOR_SETS2+16
N#define EE_ICA_MODBUS_TCP_UNIT_ID		SECTOR_SETS2+18
N#define EE_PWM_START					SECTOR_SETS2+20
N#define EE_KB_ALGORITM					SECTOR_SETS2+22
N#define EE_REG_SPEED					SECTOR_SETS2+24
N
N#define SECTOR_BAT  		SECTOR_KOEF+400
N
N#define EE_BAT1_IS_ON         SECTOR_BAT
N#define EE_BAT1_DAY_OF_ON     SECTOR_BAT+2
N#define EE_BAT1_MONTH_OF_ON   SECTOR_BAT+4
N#define EE_BAT1_YEAR_OF_ON    SECTOR_BAT+6
N#define EE_BAT1_C_REAL        SECTOR_BAT+8
N#define EE_BAT1_RESURS        SECTOR_BAT+10
N#define EE_BAT1_ZAR_CNT      	SECTOR_BAT+12
N#define EE_BAT1_ZAR_CNT_KE   	SECTOR_BAT+14
N#define EE_BAT1_C_NOM         SECTOR_BAT+16
N
N
N#define EE_BAT2_IS_ON         SECTOR_BAT+30
N#define EE_BAT2_DAY_OF_ON     SECTOR_BAT+32
N#define EE_BAT2_MONTH_OF_ON   SECTOR_BAT+34
N#define EE_BAT2_YEAR_OF_ON    SECTOR_BAT+36
N#define EE_BAT2_C_REAL        SECTOR_BAT+38
N#define EE_BAT2_RESURS        SECTOR_BAT+40
N#define EE_BAT2_ZAR_CNT       SECTOR_BAT+42
N#define EE_BAT2_ZAR_CNT_KE    SECTOR_BAT+44
N#define EE_BAT2_C_NOM         SECTOR_BAT+48
N
N
N
N#define SECTOR_SPC	  		SECTOR_KOEF+480
N#define EE_SPC_STAT			SECTOR_SPC
N#define EE_VZ_CNT			SECTOR_SPC+2
N#define EE_SPC_BAT			SECTOR_SPC+4
N#define EE_SPC_PHASE		SECTOR_SPC+6
N#define EE_SPC_KE_DATE0		SECTOR_SPC+8
N#define EE_SPC_KE_DATE1		SECTOR_SPC+12
N#define EE_SPC_VZ_LENGT		SECTOR_SPC+14
N
N//#define KOEF_LONG	30
N
N#define SECTOR_EXT  		SECTOR_KOEF+500
N#define EE_TMAX_EXT_EN0		SECTOR_EXT
N#define EE_TMAX_EXT0		SECTOR_EXT+2
N#define EE_TMIN_EXT_EN0		SECTOR_EXT+4
N#define EE_TMIN_EXT0		SECTOR_EXT+6
N#define EE_T_EXT_REL_EN0		SECTOR_EXT+8
N#define EE_T_EXT_ZVUK_EN0	SECTOR_EXT+10
N#define EE_T_EXT_LCD_EN0		SECTOR_EXT+12
N#define EE_T_EXT_RS_EN0		SECTOR_EXT+14
N#define EE_TMAX_EXT_EN1		SECTOR_EXT+16
N#define EE_TMAX_EXT1		SECTOR_EXT+18
N#define EE_TMIN_EXT_EN1		SECTOR_EXT+20
N#define EE_TMIN_EXT1		SECTOR_EXT+22
N#define EE_T_EXT_REL_EN1		SECTOR_EXT+24
N#define EE_T_EXT_ZVUK_EN1	SECTOR_EXT+26
N#define EE_T_EXT_LCD_EN1		SECTOR_EXT+28
N#define EE_T_EXT_RS_EN1		SECTOR_EXT+30
N#define EE_TMAX_EXT_EN2		SECTOR_EXT+32
N#define EE_TMAX_EXT2		SECTOR_EXT+34
N#define EE_TMIN_EXT_EN2		SECTOR_EXT+36
N#define EE_TMIN_EXT2		SECTOR_EXT+38
N#define EE_T_EXT_REL_EN2		SECTOR_EXT+40
N#define EE_T_EXT_ZVUK_EN2	SECTOR_EXT+42
N#define EE_T_EXT_LCD_EN2		SECTOR_EXT+44
N#define EE_T_EXT_RS_EN2		SECTOR_EXT+46
N#define EE_SK_SIGN0			SECTOR_EXT+48
N#define EE_SK_REL_EN0		SECTOR_EXT+50
N#define EE_SK_ZVUK_EN0		SECTOR_EXT+52
N#define EE_SK_LCD_EN0		SECTOR_EXT+54
N#define EE_SK_RS_EN0		SECTOR_EXT+56
N#define EE_SK_SIGN1			SECTOR_EXT+58
N#define EE_SK_REL_EN1		SECTOR_EXT+60
N#define EE_SK_ZVUK_EN1		SECTOR_EXT+62
N#define EE_SK_LCD_EN1		SECTOR_EXT+64
N#define EE_SK_RS_EN1		SECTOR_EXT+66
N#define EE_SK_SIGN2			SECTOR_EXT+68
N#define EE_SK_REL_EN2		SECTOR_EXT+70
N#define EE_SK_ZVUK_EN2		SECTOR_EXT+72
N#define EE_SK_LCD_EN2		SECTOR_EXT+74
N#define EE_SK_RS_EN2		SECTOR_EXT+76
N#define EE_SK_SIGN3			SECTOR_EXT+78
N#define EE_SK_REL_EN3		SECTOR_EXT+80
N#define EE_SK_ZVUK_EN3		SECTOR_EXT+82
N#define EE_SK_LCD_EN3		SECTOR_EXT+84
N#define EE_SK_RS_EN3		SECTOR_EXT+86
N#define EE_NUMSK			SECTOR_EXT+88
N#define EE_NUMDT			SECTOR_EXT+90
N#define EE_POS_VENT			SECTOR_EXT+92
N#define EE_POWER_CNT_ADRESS   SECTOR_EXT+94
N#define EE_UBM_AV             SECTOR_EXT+96
N#define EE_NUMAVT			SECTOR_EXT+98
N#define EE_NUMMAKB			SECTOR_EXT+100
N#define EE_RELE_LOG			SECTOR_EXT+102
N
N
N#define SECTOR_ETH  		SECTOR_EXT+200
N#define EE_ETH_IS_ON		SECTOR_ETH
N#define EE_ETH_DHCP_ON		SECTOR_ETH+2
N#define EE_ETH_IP_1			SECTOR_ETH+4
N#define EE_ETH_IP_2			SECTOR_ETH+6
N#define EE_ETH_IP_3			SECTOR_ETH+8
N#define EE_ETH_IP_4			SECTOR_ETH+10
N#define EE_ETH_MASK_1		SECTOR_ETH+12
N#define EE_ETH_MASK_2		SECTOR_ETH+14
N#define EE_ETH_MASK_3		SECTOR_ETH+16
N#define EE_ETH_MASK_4		SECTOR_ETH+18
N#define EE_ETH_TRAP1_IP_1	SECTOR_ETH+20
N#define EE_ETH_TRAP1_IP_2	SECTOR_ETH+22
N#define EE_ETH_TRAP1_IP_3	SECTOR_ETH+24
N#define EE_ETH_TRAP1_IP_4	SECTOR_ETH+26
N#define EE_ETH_TRAP2_IP_1	SECTOR_ETH+28
N#define EE_ETH_TRAP2_IP_2	SECTOR_ETH+30
N#define EE_ETH_TRAP2_IP_3	SECTOR_ETH+32
N#define EE_ETH_TRAP2_IP_4	SECTOR_ETH+34
N#define EE_ETH_TRAP3_IP_1	SECTOR_ETH+36
N#define EE_ETH_TRAP3_IP_2	SECTOR_ETH+38
N#define EE_ETH_TRAP3_IP_3	SECTOR_ETH+40
N#define EE_ETH_TRAP3_IP_4	SECTOR_ETH+42
N#define EE_ETH_TRAP4_IP_1	SECTOR_ETH+44
N#define EE_ETH_TRAP4_IP_2	SECTOR_ETH+46
N#define EE_ETH_TRAP4_IP_3	SECTOR_ETH+48
N#define EE_ETH_TRAP4_IP_4	SECTOR_ETH+50
N#define EE_ETH_TRAP5_IP_1	SECTOR_ETH+52
N#define EE_ETH_TRAP5_IP_2	SECTOR_ETH+54
N#define EE_ETH_TRAP5_IP_3	SECTOR_ETH+56
N#define EE_ETH_TRAP5_IP_4	SECTOR_ETH+58
N#define EE_ETH_SNMP_PORT_READ	SECTOR_ETH+60
N#define EE_ETH_SNMP_PORT_WRITE	SECTOR_ETH+62
N#define EE_ETH_GW_1			SECTOR_ETH+64
N#define EE_ETH_GW_2			SECTOR_ETH+66
N#define EE_ETH_GW_3			SECTOR_ETH+68
N#define EE_ETH_GW_4			SECTOR_ETH+70
N#define EE_MODBUS_ADRESS		SECTOR_ETH+72
N#define EE_MODBUS_BAUDRATE	SECTOR_ETH+74
N#define EE_BAT_LINK			SECTOR_ETH+76
N#define EE_I_LOAD_MODE		SECTOR_SETS+78
N
N
N#define SECTOR_LOCATION  	SECTOR_ETH+200
N#define EE_LOCATION			SECTOR_LOCATION
N#define SECTOR_COMMUNITY  	SECTOR_ETH+270
N#define EE_COMMUNITY		SECTOR_COMMUNITY
N
N
N#define KE_PTR			996
N#define KE_CNT			998
N#define UNET_AVAR_PTR	1000
N#define UNET_AVAR_CNT	1002
N#define SRC1_AVAR_PTR	1004
N#define SRC1_AVAR_CNT	1006
N#define SRC2_AVAR_PTR	1008
N#define SRC2_AVAR_CNT	1010
N#define BAT_AVAR_PTR	1012
N#define BAT_AVAR_CNT	1014
N#define VZ_PTR			1016
N#define VZ_CNT			1018
N#define WRK_PTR		1020
N#define WRK_CNT		1022
N
N
N#define EVENT_LOG	1024 
N//массив данных журнала событий 32*64=2048
N// Структура данных журнала событий:
N// Байт 0 - род устройства:
N//					'B' - батарея
N//					'S' - бпсы
N//					'P' - питающая сеть
N//					'I' - инверторы
N//					'U' - УКУ
N//					'T' - Внешний датчик температуры
N//					'L' - Внешний логический вход
N// Байт 1 - порядковый номер устройства(начинается с нуля)
N// Байт 2 - род события:
N//					'A' - авария (для питающей сети) 
N//					'L' - авария связи (для БПСов и инверторов)
N//					'C' - авария отсутствия(для батареи и БПСов) 
N//					'U' - авария завышенного напряжения (для БПСов и инверторов) 
N//					'u' - авария заниженного напряжения (для БПСов и инверторов) 
N//					'T' - авария по температуре (для БПСов и инверторов) 
N//					'R' - перезагрузка или включение, только для УКУ
N// Байт 3 - год возникновения события
N// Байт 4 - месяц возникновения события
N// Байт 5 - день возникновения события
N// Байт 6 - час возникновения события
N// Байт 7 - минута возникновения события
N// Байт 8 - секунда возникновения события
N
N#define PTR_EVENT_LOG	EVENT_LOG+1024+512+1024 
N// указатель на события(показывает на последнее записанное) 
N#define CNT_EVENT_LOG	PTR_EVENT_LOG+2 
N// колличество событий (не более 64) 
N// массив данных аварий сети {(8*64)+(2*64)}
N// Структура данных аварий сети:
N// при возникновении аварии записывается 
N// первые 4 байта с полным временем возникновения аварии
N// другие 4 байта полностью обнуляются, при пропадании аварии  в них записывается
N// полное время устранения и в 2 байта данных записывается минимальное напряжение 
N// во время аварии.
N
N#define SRC1_AVAR	1664
N#define SRC1_AVAR_DAT	2176  
N// массив данных аварий источника №1 {(8*64)+(4*64)}
N// Структура данных аварий источника №1:
N// при возникновении аварии записывается 
N// первые 4 байта с полным временем возникновения аварии
N// другие 4 байта полностью обнуляются, при пропадании аварии  в них записывается
N// полное время устранения и в 4 байта данных записывается : 
N// 1 байт - вид аварии(0x55 - занижено напряжение,
N//                     0x66 - завышено напряжение,
N//                     0x77 - перегрев источника)
N
N#define SRC2_AVAR	2432
N#define SRC2_AVAR_DAT	2944  
N// массив данных аварий источника №1 {(8*64)+(4*64)}
N// Структура данных аварий источника №1:
N// при возникновении аварии записывается 
N// первые 4 байта с полным временем возникновения аварии
N// другие 4 байта полностью обнуляются, при пропадании аварии  в них записывается
N// полное время устранения и в 4 байта данных записывается : 
N// 1 байт - вид аварии(0x55 - занижено напряжение,
N//                     0x66 - завышено напряжение,
N//                     0x77 - перегрев источника)
N
N#define BAT_AVAR	3200
N#define BAT_AVAR_DAT	3712  
N// массив данных аварий батареи {(8*64)+(4*64)}
N// Структура данных аварий источника №1:
N// при возникновении аварии записывается 
N// первые 4 байта с полным временем возникновения аварии
N// другие 4 байта полностью обнуляются, при пропадании аварии  в них записывается
N// полное время устранения и в 4 байта данных записывается : 
N// 1 байт - вид аварии(0x55 - занижено напряжение,
N//                     0x66 - завышено напряжение,
N//                     0x77 - перегрев источника)
N
N#define VZ	3968
N#define VZ_L	4224  
N// массив данных выравнивающих зарядов {(4*64)+(2*64)}
N// Структура данных ыравнивающих зарядов:
N// при завершении процесса записывается 
N// первые 4 байта с полным временем завершения процесса
N// и в 2 байта данных записывается длительность процесса в часах 
N
N#define WRK	4352
N#define WRK_AH	5376  
N// массив данных разрядов батареи {(8*128)+(2*128)}
N// Структура данных разрядов батареи:
N// при завершении процесса записывается 
N// первые 4 байта с полным временем начала процесса
N// затем 4 байта с полным временем завершения процесса
N// и в 2 байта данных записывается колличество отданных амперчасов 
N
N#define KE	5632
N#define KE_AH	6144  
N// массив данных разрядов батареи {(8*64)+(2*64)}
N// Структура данных разрядов батареи:
N// при завершении процесса записывается 
N// первые 4 байта с полным временем начала процесса
N// затем 4 байта с полным временем завершения процесса
N// и в 2 байта данных записывается колличество отданных амперчасов 
N
Nextern const unsigned short ADR_EE_BAT_ZAR_CNT[2];
Nextern const unsigned short ADR_EE_BAT_ZAR_CNT_KE[2];
Nextern const unsigned short ADR_EE_BAT_C_NOM[2];
Nextern const unsigned short ADR_EE_BAT_YEAR_OF_ON[2];
Nextern const unsigned short ADR_EE_BAT_IS_ON[2];
Nextern const unsigned short ADR_EE_BAT_DAY_OF_ON[2];
Nextern const unsigned short ADR_EE_BAT_MONTH_OF_ON[2];
Nextern const unsigned short ADR_EE_BAT_RESURS[2];
Nextern const unsigned short ADR_EE_BAT_C_REAL[2];
Nextern const unsigned short ADR_EE_BAT_TYPE[2];
Nextern const unsigned short ADR_KUBAT[2];
Nextern const unsigned short ADR_KUBATM[2];
Nextern const unsigned short ADR_KI0BAT[2];
Nextern const unsigned short ADR_KI1BAT[2];
Nextern const unsigned short ADR_KTBAT[2];
Nextern const unsigned short ADR_EE_BAT_TYPE[2];
N
N
Nextern const unsigned short ADR_TMAX_EXT_EN[3];
Nextern const unsigned short ADR_TMAX_EXT[3];
Nextern const unsigned short ADR_TMIN_EXT_EN[3];
Nextern const unsigned short ADR_TMIN_EXT[3];
Nextern const unsigned short ADR_T_EXT_REL_EN[3];
Nextern const unsigned short ADR_T_EXT_ZVUK_EN[3];
Nextern const unsigned short ADR_T_EXT_LCD_EN[3];
Nextern const unsigned short ADR_T_EXT_RS_EN[3];
N
Nextern const unsigned short ADR_SK_SIGN[4];
Nextern const unsigned short ADR_SK_REL_EN[4];
Nextern const unsigned short ADR_SK_ZVUK_EN[4];
Nextern const unsigned short ADR_SK_LCD_EN[4];
Nextern const unsigned short ADR_SK_RS_EN[4];
N
Nextern const unsigned short ADR_EE_RELE_SET_MASK[4];
N
L 23 "main.c" 2
N#include "common_func.h"
L 1 "common_func.h" 1
N#ifndef _COMMON_FUNC_H_
N
N#define _COMMON_FUNC_H_
N
Nsigned short abs(signed short in);
Nvoid clr_scrn(void);
Nchar find(char xy);
Nvoid bin2bcd_int(unsigned int in);
Nvoid bcd2lcd_zero(char sig);
Nvoid int2lcd_m(signed short in,char xy,char des);
Nvoid int2lcd_mm(signed short in,char xy,char des);
Nvoid int2lcd_mmm(signed short in,char xy,char des);
Nvoid long2lcd_mmm(signed long in,char xy,char des);
Nvoid long2lcdyx_mmm(signed long in,char y,char x,char des);
Nvoid int2lcdyx(unsigned short in,char y,char x,char des);
Nvoid int2lcd(unsigned short in,char xy,char des);
Nvoid checkboxing(char xy,short in);
Nvoid long2lcdhyx(unsigned long in,char y,char x);
Nvoid char2lcdh(char in,char yx);
Nvoid char2lcdhyx(char in,char y,char x);
Nvoid int2lcdhyx(unsigned short in,char y,char x);
Nvoid char2lcdbyx(char in,char y,char x);
Nvoid pointer_set(char num_of_first_row);
Nvoid tree_down(signed char offset_ind,signed char offset_sub_ind);
Nvoid tree_up(char tind, char tsub_ind, char tindex_set, char tsub_ind1);
Nvoid bgnd_par(char const *ptr0,char const *ptr1,char const *ptr2,char const *ptr3);
Nvoid sub_bgnd(char const *adr,char xy,signed char offset);
Nvoid show_mess(char* p1, char* p2, char* p3, char* p4,int m_sec);
Nvoid event2ind(char num, char simbol);
Nchar ptr_carry(signed int in,unsigned char modul,signed int carry);
Nvoid event_data2ind(char num, char simbol);
Nvoid ip2lcd(	short in1,
N			short in2,
N			short in3,
N			short in4,
N			char xy,
N			char flash_pos);
Nvoid community2lcd(char* in,
N			char xy,
N			char flash_pos,
N			char flash_on);
N
N#endif
L 24 "main.c" 2
N#include "control.h"
L 1 "control.h" 1
N#ifndef _CONTROL_H_
N
N#define _CONTROL_H_
N
N
N//**********************************************
N//Работа с БПСами
Nextern char num_of_wrks_bps;
Nextern char bps_all_off_cnt,bps_mask_off_cnt,bps_mask_on_off_cnt;
Nextern char bps_hndl_2sec_cnt;
Nextern unsigned short bps_on_mask,bps_off_mask;
Nextern char num_necc_up,num_necc_down;
Nextern unsigned char sh_cnt0,b1Hz_sh;
N
N
Nextern short cntrl_stat_blok_cnt,cntrl_stat_blok_cnt_,cntrl_stat_blok_cnt_plus[2],cntrl_stat_blok_cnt_minus[2];
N
N//***********************************************
N//АЦП 
Nextern long adc_buff[16][16];
Nextern signed short adc_buff_max[12],adc_buff_min[12],unet_buff_max,unet_buff_min;
Nextern short adc_buff_[16];
Nextern char adc_self_ch_cnt,adc_ch_net;
Nextern char adc_cnt,adc_cnt1,adc_ch,adc_ch_cnt;
Nextern short zero_cnt;
Ntypedef enum {asCH=1,asNET_WAIT=2,asNET_RDY=3,asNET=4} enum_adc_stat;
Nextern enum_adc_stat adc_stat;
Nextern unsigned short net_buff[32],net_buff_,net_metr_buff_[3];
Nextern char net_buff_cnt;
Nextern short ADWR,period_cnt,non_zero_cnt;
Nextern char rele_stat;
Nextern char bRELE_OUT;
Nextern short plazma_adc_cnt;
Nextern signed short adc_self_ch_buff[3],adc_self_ch_disp[3];
Nextern long main_power_buffer[8],main_power_buffer_;
Nextern short main_power_buffer_cnt;
Nextern short adc_gorb_cnt,adc_zero_cnt;
Nextern char adc_window_flag;
Nextern short adc_window_cnt;
Nextern short adc_net_buff_cnt;
N
N
Nchar vz_start(char hour);
Nvoid vz_stop(void);
N
Nvoid samokalibr_init(void);
Nvoid samokalibr_hndl(void);
Nvoid kb_init(void);
Nvoid kb_hndl(void);
Nvoid ubat_old_drv(void);
Nvoid unet_drv(void);
Nvoid matemat(void);
Nvoid adc_init(void);
Nvoid adc_drv5(void);
Nvoid adc_drv_(void);
Nvoid avg_hndl(void);
N//void bp_on(char in);
N//void bp_off(char in);
Nvoid rele_hndl(void);
Nvoid bps_hndl(void);
Nvoid bps_drv(char in);
Nvoid bat_hndl(void);
Nvoid bat_drv(char in);
Nvoid u_necc_hndl(void);
Nvoid cntrl_hndl(void);
Nvoid zar_drv(void);
Nvoid num_necc_hndl(void);
Nvoid ke_start(char in);
Nvoid zar_drv(void);
Nvoid vent_hndl(void);
Nvoid avz_next_date_hndl(void);
Nvoid klimat_hndl(void);
Nvoid ext_drv(void);
Nvoid adc_drv7(void);
Nvoid avt_hndl(void);
Nvoid vent_resurs_hndl(void);
Nvoid ips_current_average_hndl(void);
N
N//***********************************************
N//Спецфункции
N
Ntypedef enum {spcOFF=0,spcKE, spcVZ}enum_spc_stat;
Ntypedef enum {kssNOT=0,kssNOT_VZ,kssYES=100,kssNOT_BAT,kssNOT_BAT_AV,kssNOT_BAT_AV_T,kssNOT_BAT_AV_ASS,kssNOT_BAT_ZAR,kssNOT_BAT_RAZR,kssNOT_KE1,kssNOT_KE2}enum_ke_start_stat;
Nextern enum_spc_stat spc_stat;
Nextern enum_ke_start_stat ke_start_stat;
Nextern char spc_bat;
Nextern char spc_phase;
Nextern unsigned short vz_cnt_s,vz_cnt_s_,vz_cnt_h,vz_cnt_h_;
Nextern short cnt_end_ke;
Nextern unsigned long ke_date[2];
Nextern short __ee_vz_cnt;
Nextern short __ee_spc_stat;
Nextern short __ee_spc_bat;
Nextern short __ee_spc_phase;
N
N//***********************************************
N//Управление ШИМом
Nextern signed short cntrl_stat;
Nextern signed short cntrl_stat_old;
Nextern signed short cntrl_stat_new;
Nextern signed short Ibmax;
Nextern unsigned char unh_cnt0,unh_cnt1,b1Hz_unh;
Nextern unsigned char	ch_cnt0,b1Hz_ch,i,iiii;
Nextern unsigned char	ch_cnt1,b1_30Hz_ch;
Nextern unsigned char	ch_cnt2,b1_10Hz_ch;
Nextern unsigned short IZMAX_;
Nextern unsigned short IZMAX_70;
Nextern unsigned short IZMAX_130;
Nextern unsigned short Ubpsmax;
Nextern unsigned short cntrl_stat_blck_cnt;
N
Nextern short plazma_sk;
Nextern char	plazma_inv[4];
Nextern char plazma_bat;
Nextern char plazma_cntrl_stat;
N#endif
N
Nextern signed int i_avg_max,i_avg_min,i_avg_summ,i_avg; 
Nextern signed int avg;
Nextern char bAVG;
Nextern const char sk_buff_TELECORE2015[4];
N
N//**********************************************
N//Контроль наличия батарей
Nextern signed short 	main_kb_cnt;
Nextern signed short 	kb_cnt_1lev;
Nextern signed short 	kb_cnt_2lev;
Nextern char 		kb_full_ver;
Nextern char kb_start[2],kb_start_ips;
Nextern signed short ibat_ips,ibat_ips_;
N
N//***********************************************
N//Ротация ведущего источника
Nextern char numOfForvardBps,numOfForvardBps_old;
Nextern char numOfForvardBps_minCnt;
Nextern short numOfForvardBps_hourCnt;
N
N//***********************************************
N// Параллельная работа в случае перегрева источника
Nextern char bPARALLEL_NOT_ENOUG;
Nextern char bPARALLEL_ENOUG;
Nextern char bPARALLEL;
N
Nextern char bAVG_BLOCK;
N
Nextern char cntrl_hndl_plazma;
N
Nvoid zar_superviser_drv(void);
Nvoid zar_superviser_start(void);
Nvoid vent_hndl(void);
Nvoid speedChargeHndl(void);
Nvoid speedChargeStartStop(void);
Nvoid numOfForvardBps_init(void);
Nvoid outVoltContrHndl(void);
N
N
L 25 "main.c" 2
N#include "mess.h"
L 1 "mess.h" 1
N
N
N
N
N
N#define 	MESS_BAT_ON_OFF	160
N#define   _MESS_BAT_MASK_BLOK_AFTER_2SEC		161
N#define	_MESS_BAT_MASK_ON					162
N#define	_MESS_BAT_MASK_OFF					163
N
N		
N#define	MESS_SPA_UART_SRAM	200 
N#define	MESS_SPA_UART_CMND	201 
N
N
N
Nvoid mess_hndl(void);
Nvoid mess_send(char _mess, short par0, short par1, char _time);
Nchar mess_find(char _mess);
Nchar mess_find_unvol(char _mess);
N
L 26 "main.c" 2
N#include "full_can.h"
L 1 "full_can.h" 1
N/**************************************************************************
NDO NOT CHANGE ANYTHING BELOW
N***************************************************************************/ 
N
N// Define CAN SFR address bases 
N#define CAN_REG_BASE                    (0xE0000000)
N#define ACCEPTANCE_FILTER_RAM_BASE      (CAN_REG_BASE + 0x00038000)
N#define ACCEPTANCE_FILTER_REGISTER_BASE (CAN_REG_BASE + 0x0003C000)
N#define CENTRAL_CAN_REGISTER_BASE       (CAN_REG_BASE + 0x00040000)              
N
N// Common CAN bit rates
N#define   CANBitrate125k_12MHz          0x001C001D
N#define   CANBitrate125k_60MHz          0x001C001D
N#define   CANBitrate250k_12MHz          0x001C000E
N#define   CANBitrate250k_60MHz          0x009C000E
N#define   CANBitrate62k_60MHz          	0x009C003b
N#define 	BITRATE62_5K25MHZ			0x009c0018
N#define 	BITRATE125K25MHZ			0x00940018
N
N/**************************************************************************
NUSER DEFINABLE PARAMETERS
N***************************************************************************/ 
N
N// Maximum number of CAN interfaces supported by this driver (1 to 4)
N// So far values 3 and 4 were not tested
N// The example code in "main" uses CAN ports 1 and 2 (MAX_CANPORTS 2)
N#define MAX_CANPORTS 2
N
N// Maximum number of total FullCAN Filters for ALL CAN interfaces
N#define MAX_FILTERS 2
N
N// Type definition to hold a FullCAN message
N// Compatible to FullCAN Mode Stored Messages in LPC User Manual
N
N
N// Counts number of filters (CAN message objects) used so far
N//extern short volatile gCANFilter = 0;
N
Nextern char ptr_can1_tx_wr,ptr_can1_tx_rd;
Nextern long can1_info[8];
Nextern long can1_id[8];
Nextern long can1_data[8];
Nextern long can1_datb[8];
N																							 
Nextern char ptr_can2_tx_wr,ptr_can2_tx_rd;
N
Nextern long can2_info[8];
Nextern long can2_id[8];
Nextern long can2_data[8];
Nextern long can2_datb[8];
N
Nextern unsigned short rotor_can[6];
N// FullCAN Message List
N//extern FULLCAN_MSG volatile gFullCANList[MAX_FILTERS];
N
Nextern char bR;
Nextern char RXBUFF[40],TXBUFF[40];
Nextern char bIN,bIN2;
Nextern char bd_dumm[25];
Nextern char bd[25];
Nextern char TX_len;
N//char bOUT;
Nextern char RXBUFF2[40],TXBUFF2[40];
Nextern char can_tx_cnt;
Nextern char can_tx_cnt2;
N//extern char bOUT_FREE=1;
N//extern char bOUT_FREE2=1;
Nextern char rotor_rotor_rotor[2];
Nextern char can_tx_cnt;
N
Nextern const char Table87[];
Nextern const char Table95[];
N
Nextern char can_debug_plazma[2][10];
Nextern char bOUT_FREE;
Nextern char can_rotor[10];
Nextern char plazma_can;
Nextern char plazma_can1,plazma_can2,plazma_can3,plazma_can4;
N
N
N
Ntypedef struct
N{
N  unsigned int Dat1; // Bits  0..10: CAN Message ID
N                     // Bits 13..15: CAN interface number (1..4)
N                     // Bits 16..19: DLC - Data Length Counter
N                     // Bits 24..25: Semaphore bits
N  unsigned int DatA; // CAN Message Data Bytes 0-3
N  unsigned int DatB; // CAN Message Data Bytes 4-7
N} FULLCAN_MSG; 
Nextern short volatile gCANFilter;
Nextern FULLCAN_MSG volatile gFullCANList[MAX_FILTERS];
Xextern FULLCAN_MSG volatile gFullCANList[2];
Nextern char can_reset_cnt;
N
N
N
Nchar CRC1_in(void);
Nchar CRC2_in(void);
Nchar CRC1_out(void);
Nchar CRC2_out(void);
Nvoid can1_out_adr(char* ptr,char num);
N__irq void can_isr_err (void);
Nvoid can1_out(char data0,char data1,char data2,char data3,char data4,char data5,char data6,char data7);
Xvoid mcp2515_transmit(char data0,char data1,char data2,char data3,char data4,char data5,char data6,char data7);
Nvoid can_adr_hndl(void);
Nvoid can_in_an(void);
Nvoid can_in_an2(void);
N__irq void can_isr_rx (void); 
N__irq void can_isr_tx (void); 
Nshort can1_init ( unsigned int can_btr);
Nshort can2_init ( unsigned int can_btr);
Nshort FullCAN_SetFilter (
N  unsigned short can_port, // CAN interface number
N  unsigned int CANID // 11-bit CAN ID
N  );
N
Nvoid CAN_IRQHandler(void);
Nvoid CAN_ISR_Rx1( void );
N
Nextern char can_debug_plazma[2][10];
Nextern char ccc_plazma[20];
N
L 27 "main.c" 2
N#include "watchdog.h"
L 1 "watchdog.h" 1
N
Nvoid watchdog_init(unsigned long f,unsigned long time_out);
Nvoid watchdog_reset(void);
N
N
N
N
N
L 28 "main.c" 2
N#include "ad7705.h"
L 1 "ad7705.h" 1
N
Nextern unsigned short ad7705_res1,ad7705_res2;
Nextern unsigned short ad7705_buff[2][16],ad7705_buff_[2];
Nextern unsigned short ad7705_res;
Nextern char b7705ch,ad7705_wrk_cnt;
Nextern unsigned short cnt_ad7705_vis,cnt_ad7705_vis_wrk;
Nextern signed short ad7705_plazma;
N
N
Nvoid spi1_ad7705_config(void);
Nvoid ad7705_reset(void);
Nvoid ad7705_write(char in);
Nvoid ad7705_read(char num);
Nvoid ad7705_drv(void);
N
N
N
L 29 "main.c" 2
N#include "beep.h"
L 1 "beep.h" 1
N
Nextern unsigned long beep_stat_temp,beep_stat;
Nextern char beep_stat_cnt;
Nextern char beep_cnt;
Nextern char bU_BAT2REL_AV_BAT;
N
Nvoid beep_drv(void);
Nvoid beep_init(long zvuk,char fl);
Nvoid beep_hndl(void);
L 30 "main.c" 2
N#include "avar_hndl.h"
L 1 "avar_hndl.h" 1
N
N
N//***********************************************
N//Аварии
Nextern unsigned avar_stat;	 	//"Отображение" всех аварийных в данный момент устройств в одном месте
Nextern unsigned avar_ind_stat; 	//"Отображение" всех не просмотренных аварийных устройств в одном месте
Nextern unsigned avar_stat_old;
Nextern unsigned avar_stat_new,avar_stat_offed;
N//Структура переменных
N//1бит  - питающая сеть
N//2бита - батареи
N//12бит - БПСы
N//5бит  - инверторы
N//4бита - внешние датчики температуры
N//4бита - внешние сухие контакты
N
N
Nvoid avar_hndl(void);
Nvoid avar_unet_hndl(char in);
Nvoid avar_uout_hndl(char in);
Nvoid reload_hndl(void);
Nvoid avar_bps_hndl(char bps, char v, char in);
Nvoid avar_bat_hndl(char bat, char in);
Nvoid avar_bat_as_hndl(char b, char in);
Nvoid ke_mem_hndl(char b,unsigned short in);
Nvoid vz_mem_hndl(unsigned short in);
Nvoid wrk_mem_hndl(char b);
Nvoid avar_bat_ips_hndl(char in);
N
N
N
L 31 "main.c" 2
N#include "memo.h"
L 1 "memo.h" 1
N
Nvoid memo_read (void);
N
N
N
N
N
N
L 32 "main.c" 2
N#include "simbols.h"
L 1 "simbols.h" 1
N
N
Nextern const char sAVNET[150];
Nextern const char sAVNET1[150];
Nextern const char sBPS1[30];
Nextern const char sBPS2[30];
Nextern const char sAVT[30];
Nextern const char sAVU[30];
Nextern const char caracter[1536];
L 33 "main.c" 2
N#include "graphic.h"
L 1 "graphic.h" 1
N
N
Nvoid draw(signed short x_b,signed short y_b,signed short x_o,signed short y_o,char inverse);
Nvoid draw_rectangle(signed short x_b,signed short y_b,signed short x_o,signed short y_o,char solid,char inverse);	   
Nvoid draw_ptr(char x_b,char y_b,char ptr,char vol);
Nvoid plot(signed short x_b,signed short y_b,unsigned long data,signed short len,char inverse);
Nvoid graphic_print(signed short x_b,signed short y_b,signed short x_l,signed short y_l,signed short x_d,signed short y_d,const char* adress,char inverse);
Nvoid graphic_print_text(signed short x_b,signed short y_b,const char* bgnd,signed short num,signed short data,signed short des,signed short pos,char inverse);
Nvoid graphic_print_text_text(signed short x_b,signed short y_b,const char* bgnd,signed short num,signed short data,signed short des,signed short pos,char inverse);
L 34 "main.c" 2
N#include "snmp_data_file.h" 
L 1 "snmp_data_file.h" 1
Nextern char snmp_community[10];
N
N//Информация об устройстве
Nextern signed short snmp_device_code;
Nextern signed 	   snmp_sernum;
Nextern signed short snmp_sernum_lsb;
Nextern signed short snmp_sernum_msb;
Nextern char 	   snmp_location[100];
Nextern signed short snmp_numofbat;
Nextern signed short snmp_numofbps;
Nextern signed short snmp_numofinv;
Nextern signed short snmp_numofavt;
Nextern signed short snmp_numofdt;
Nextern signed short snmp_numofsk;
Nextern signed short snmp_numofevents;
N
N//Состояние первичной сети
Nextern signed short snmp_mains_power_voltage;
Nextern signed short snmp_mains_power_frequency;
Nextern signed short snmp_mains_power_status;
Nextern signed short snmp_mains_power_alarm;
Nextern signed short snmp_mains_power_voltage_phaseA;
Nextern signed short snmp_mains_power_voltage_phaseB;
Nextern signed short snmp_mains_power_voltage_phaseC;
N
N//Состояние нагрузки
Nextern signed short snmp_load_voltage;
Nextern signed short snmp_load_current;
N
N//Состояние БПСов
Nextern signed short snmp_bps_number[8];
Nextern signed short snmp_bps_voltage[8];
Nextern signed short snmp_bps_current[8];
Nextern signed short snmp_bps_temperature[8];
Nextern signed short snmp_bps_stat[8];
N
N//Состояние инверторов
Nextern signed short snmp_inv_number[3];
Nextern signed short snmp_inv_voltage[3];
Nextern signed short snmp_inv_current[3];
Nextern signed short snmp_inv_temperature[3];
Nextern signed short snmp_inv_stat[3];
N
N//Состояние Батарей
Nextern signed short snmp_bat_number[2];
Nextern signed short snmp_bat_voltage[2];
Nextern signed short snmp_bat_part_voltage[2];
Nextern signed short snmp_bat_current[2];
Nextern signed short snmp_bat_temperature[2];
Nextern signed short snmp_bat_capacity[2];
Nextern signed short snmp_bat_charge[2];
Nextern signed short snmp_bat_status[2];
N
N//Мониторы состояния Батарей
Nextern signed short snmp_makb_number[4];
Nextern signed short snmp_makb_connect_status[4];
Nextern signed short snmp_makb_voltage0[4];
Nextern signed short snmp_makb_voltage1[4];
Nextern signed short snmp_makb_voltage2[4];
Nextern signed short snmp_makb_voltage3[4];
Nextern signed short snmp_makb_voltage4[4];
Nextern signed short snmp_makb_temper0[4];
Nextern signed short snmp_makb_temper1[4];
Nextern signed short snmp_makb_temper2[4];
Nextern signed short snmp_makb_temper3[4];
Nextern signed short snmp_makb_temper4[4];
Nextern signed short snmp_makb_temper0_stat[4];
Nextern signed short snmp_makb_temper1_stat[4];
Nextern signed short snmp_makb_temper2_stat[4];
Nextern signed short snmp_makb_temper3_stat[4];
Nextern signed short snmp_makb_temper4_stat[4];
Nextern signed short snmp_bat_voltage[2];
Nextern signed short snmp_bat_current[2];
Nextern signed short snmp_bat_temperature[2];
Nextern signed short snmp_bat_capacity[2];
Nextern signed short snmp_bat_charge[2];
Nextern signed short snmp_bat_status[2]; 
N
N//Спецфункции
N//Спецфункции
Nextern signed short snmp_spc_stat;
Nextern char snmp_spc_trap_message[100];
Nextern signed short snmp_spc_trap_value_0,snmp_spc_trap_value_1,snmp_spc_trap_value_2;
N
N//Состояние силовых вводов
Nextern signed short snmp_energy_vvod_phase_a;
Nextern signed short snmp_energy_vvod_phase_b;
Nextern signed short snmp_energy_vvod_phase_c;
Nextern signed short snmp_energy_pes_phase_a;
Nextern signed short snmp_energy_pes_phase_b;
Nextern signed short snmp_energy_pes_phase_c;
Nextern signed short snmp_energy_input_voltage;
N
N//Показания счетчика
Nextern signed long snmp_energy_total_energy;
Nextern signed short snmp_energy_current_energy;
N
N//Состояние сухих контактов
Nextern signed char snmp_sk_number[4];
Nextern signed char snmp_sk_aktiv[4];
Nextern signed char snmp_sk_alarm_aktiv[4];
Nextern signed char snmp_sk_alarm[4];
Nextern char snmp_sk_name[4][20];
N
N//Состояние датчиков температур
Nextern signed char snmp_dt_number[3];
Nextern signed short snmp_dt_temper[3];
Nextern signed char snmp_dt_error[3];
N
N//Состояние автоматов
Nextern signed char snmp_avt_number[12];
Nextern signed char snmp_avt_stat[12];
N
N//Команды
Nextern signed short snmp_command;
Nextern signed short snmp_command_parametr;
N
N//Журнал аварий
Nextern char snmp_log[64][128];
N
N//Установочные параметры
Nextern signed short snmp_main_bps;
Nextern signed short snmp_zv_en;
Nextern signed short snmp_alarm_auto_disable;
Nextern signed short snmp_bat_test_time;
Nextern signed short snmp_u_max;
Nextern signed short snmp_u_min;
Nextern signed short snmp_u_0_grad;
Nextern signed short snmp_u_20_grad;
Nextern signed short snmp_u_sign;
Nextern signed short snmp_u_min_power;
Nextern signed short snmp_u_withouth_bat;
Nextern signed short snmp_control_current;
Nextern signed short snmp_max_charge_current;
Nextern signed short snmp_max_current;
Nextern signed short snmp_min_current;
Nextern signed short snmp_uvz;
Nextern signed short snmp_max_current_koef;
Nextern signed short snmp_max_current_koef;
Nextern signed short snmp_up_charge_koef;
Nextern signed short snmp_powerup_psu_timeout;
Nextern signed short snmp_max_temperature;
Nextern signed short snmp_tsign_bat; 
Nextern signed short snmp_tmax_bat;
Nextern signed short snmp_tsign_bps;
Nextern signed short snmp_tmax_bps;
Nextern signed short snmp_bat_part_alarm;
Nextern signed short snmp_power_cnt_adress;
N
N//Климат-контроль
Nextern signed short snmp_klimat_box_temper;
Nextern signed short snmp_klimat_settings_box_alarm;
Nextern signed short snmp_klimat_settings_vent_on;
Nextern signed short snmp_klimat_settings_vent_off;
Nextern signed short snmp_klimat_settings_warm_on;
Nextern signed short snmp_klimat_settings_warm_off;
Nextern signed short snmp_klimat_settings_load_on;
Nextern signed short snmp_klimat_settings_load_off;
Nextern signed short snmp_klimat_settings_batt_on;
Nextern signed short snmp_klimat_settings_batt_off;
N
N//Внешние датчики температуры
Nextern signed short snmp_dt_ext;
Nextern signed short snmp_dt_msan;
Nextern signed short snmp_dt_epu;
N
N//Литиевые батареи
Nextern short snmp_lakb_number[7];				//Номер ЛАКБ
Nextern short snmp_lakb_voltage[7];				//Напряжение ЛАКБ
Nextern short snmp_lakb_max_cell_voltage[7];		//Максимальное напряжение ячейки ЛАКБ
Nextern short snmp_lakb_min_cell_voltage[7];		//Минимальное напряжение ячейки ЛАКБ
Nextern short snmp_lakb_max_cell_temperature[7];	//Максимальная температура ячейки ЛАКБ
Nextern short snmp_lakb_min_cell_temperature[7];	//Минимальная температура ячейки ЛАКБ
Nextern short snmp_lakb_ch_curr[7];				//Ток заряда ЛАКБ
Nextern short snmp_lakb_dsch_curr[7];			//Ток разряда ЛАКБ
Nextern short snmp_lakb_rat_cap[7];				//Номинальная емкость ЛАКБ
Nextern short snmp_lakb_soh[7];				//Остаточная емкость ЛАКБ
Nextern short snmp_lakb_soc[7];				//Заряд ЛАКБ
Nextern short snmp_lakb_cclv[7];  				//Максимальный ток заряда ЛАКБ
Nextern short snmp_lakb_rbt[7];				//Оцениваемое время работы ЛАКБ
Nextern short snmp_lakb_flags1[7];				//Первый флаг состояния ЛАКБ
Nextern short snmp_lakb_flags2[7];				//Второй флаг состояния ЛАКБ
Nextern char snmp_lakb_damp1[3][150];				//Первая строка передаваемого дампа
Nextern char snmp_lakb_damp2[100];				//Первая строка передаваемого дампа
Nextern signed char	snmp_lakb_cell_temperature_1[3];		//Температура 1-й ячейки ЛАКБ(ZTT)
Nextern signed char	snmp_lakb_cell_temperature_2[3];		//Температура 2-й ячейки ЛАКБ(ZTT)
Nextern signed char	snmp_lakb_cell_temperature_3[3];		//Температура 3-й ячейки ЛАКБ(ZTT)
Nextern signed char	snmp_lakb_cell_temperature_4[3];		//Температура 4-й ячейки ЛАКБ(ZTT)
Nextern signed char	snmp_lakb_cell_temperature_ambient[3];	//Температура окружающая ЛАКБ(ZTT)
Nextern signed char	snmp_lakb_cell_temperature_power[3];	//Температура силовой части ЛАКБ(ZTT)
N
N//Установки климатконтроля для TELECORE2017
Nextern signed char	snmp_warm_sign;				//^^номер первого бпса 
Nextern signed char	snmp_cool_sign;				//^^номер первого бпса 
Nextern signed char	snmp_warm_on_temper;		//^^номер первого бпса 
Nextern signed char	snmp_warm_off_temper;		//^^номер первого бпса 
Nextern signed char	snmp_warm_q;				//^^номер первого бпса 
Nextern signed char	snmp_cool_100_temper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_80_temper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_60_temper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_40_temper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_20_temper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_100_dtemper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_80_dtemper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_60_dtemper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_40_dtemper;		//^^номер первого бпса 
Nextern signed char	snmp_cool_20_dtemper;		//^^номер первого бпса 
Nextern signed char 	snmp_warm_stat;				//^^
N  
N//-----------------------------------------------
Nvoid snmp_data (void);
Nvoid snmp_sernum_write (int mode); 
Nvoid snmp_location_write (int mode);
Nvoid snmp_command_execute (int mode);
Nvoid event2snmp(char num);
Nvoid snmp_main_bps_write (int mode);
Nvoid snmp_zv_on_write (int mode);
Nvoid snmp_alarm_auto_disable_write (int mode);
Nvoid snmp_bat_test_time_write (int mode);
Nvoid snmp_u_max_write (int mode);
Nvoid snmp_u_min_write (int mode);
Nvoid snmp_u_0_grad_write (int mode);
Nvoid snmp_u_20_grad_write (int mode);
Nvoid snmp_u_sign_write (int mode);
Nvoid snmp_u_min_power_write (int mode);
Nvoid snmp_u_withouth_bat_write (int mode);
Nvoid snmp_control_current_write (int mode);
Nvoid snmp_max_charge_current_write (int mode);
Nvoid snmp_max_current_write (int mode);
Nvoid snmp_min_current_write (int mode);
Nvoid snmp_up_charge_koef_write (int mode);
Nvoid snmp_powerup_psu_timeout_write (int mode);
Nvoid snmp_max_temperature_write (int mode);
Nvoid event2snmp(char num);
Nvoid snmp_trap_send(char* str, signed short in0, signed short in1, signed short in2);
Nvoid snmp_alarm_aktiv_write1(int mode);
Nvoid snmp_alarm_aktiv_write2(int mode);
Nvoid snmp_alarm_aktiv_write3(int mode);
Nvoid snmp_alarm_aktiv_write4(int mode);
Nvoid snmp_klimat_settings_box_alarm_write(int mode);
Nvoid snmp_klimat_settings_vent_on_write(int mode);
Nvoid snmp_klimat_settings_vent_off_write(int mode);
Nvoid snmp_klimat_settings_warm_on_write(int mode);
Nvoid snmp_klimat_settings_warm_off_write(int mode);
Nvoid snmp_klimat_settings_load_on_write(int mode);
Nvoid snmp_klimat_settings_load_off_write(int mode);
Nvoid snmp_klimat_settings_batt_on_write(int mode);
Nvoid snmp_klimat_settings_batt_off_write(int mode);
Nvoid snmp_tsign_bat_write(int mode);
Nvoid snmp_tmax_bat_write(int mode);
Nvoid snmp_tsign_bps_write(int mode);
Nvoid snmp_tmax_bps_write(int mode);
Nvoid snmp_bat_part_alarm_write(int mode);
Nvoid snmp_power_cnt_adress_write(int mode);
Nvoid snmp_uvz_write(int mode);
Nvoid snmp_warm_sign_write(int mode);
Nvoid snmp_cool_sign_write(int mode);
Nvoid snmp_warm_on_temper_write(int mode);
Nvoid snmp_warm_off_temper_write(int mode);
Nvoid snmp_warm_q_write(int mode);
Nvoid snmp_cool_100_temper_write(int mode);
Nvoid snmp_cool_80_temper_write(int mode);
Nvoid snmp_cool_60_temper_write(int mode);
Nvoid snmp_cool_40_temper_write(int mode);
Nvoid snmp_cool_20_temper_write(int mode);
Nvoid snmp_cool_100_dtemper_write(int mode);
Nvoid snmp_cool_80_dtemper_write(int mode);
Nvoid snmp_cool_60_dtemper_write(int mode);
Nvoid snmp_cool_40_dtemper_write(int mode);
Nvoid snmp_cool_20_dtemper_write(int mode);
N
N
N
N
N
N 
L 35 "main.c" 2
N#include "net_config.h"
L 1 "C:\Keil\ARM\RV31\INC\net_config.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    NET_CONFIG.H
N *      Purpose: Common TCPnet Definitions
N *      Rev.:    V4.13
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2010 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __NET_CONFIG_H__
N#define __NET_CONFIG_H__
N
N#include <RTL.h>
N
N/* Definitions */
N#define ETH_ADRLEN      6         /* Ethernet Address Length in bytes        */
N#define IP_ADRLEN       4         /* IP Address Length in bytes              */
N#define OS_HEADER_LEN   4         /* TCPnet 'os_frame' header size           */
N                                  /* Frame Header length common for all      */
N#define PHY_HEADER_LEN  (2*ETH_ADRLEN + 2) /* network interfaces.            */
N#define ETH_MTU         1514      /* Ethernet Frame Max Transfer Unit        */
N#define PPP_PROT_IP     0x0021    /* PPP Protocol type: IP                   */
N#define TCP_DEF_WINSIZE 4380      /* TCP default window size                 */
N
N/* Network Interfaces */
N#define NETIF_ETH       0         /* Network interface: Ethernet             */
N#define NETIF_PPP       1         /* Network interface: PPP                  */
N#define NETIF_SLIP      2         /* Network interface: Slip                 */
N
N/* Telnet Definitions */
N#define TNET_LBUFSZ     96        /* Command Line buffer size (bytes)        */
N#define TNET_HISTSZ     128       /* Command History buffer size (bytes)     */
N#define TNET_FIFOSZ     128       /* Input character Fifo buffer (bytes)     */
N
N/* SNMP-MIB Definitions */
N#define MIB_INTEGER     0x02      /* MIB entry type INTEGER                  */
N#define MIB_OCTET_STR   0x04      /* MIB entry type OCTET_STRING             */
N#define MIB_OBJECT_ID   0x06      /* MIB entry type OBJECT_IDENTIFIER        */
N#define MIB_IP_ADDR     0x40      /* MIB entry type IP ADDRESS (U8[4])       */
N#define MIB_COUNTER     0x41      /* MIB entry type COUNTER (U32)            */
N#define MIB_GAUGE       0x42      /* MIB entry type GAUGE (U32)              */
N#define MIB_TIME_TICKS  0x43      /* MIB entry type TIME_TICKS               */
N#define MIB_ATR_RO      0x80      /* MIB entry attribute READ_ONLY           */
N#define MIB_OIDSZ       13        /* Max.size of Object ID value             */
N#define MIB_STRSZ       110       /* Max.size of Octet String variable       */
N#define MIB_READ        0         /* MIB entry Read access                   */
N#define MIB_WRITE       1         /* MIB entry Write access                  */
N
N/* SNMP-MIB Macros */
N#define MIB_STR(s)      sizeof(s)-1, s
N#define MIB_INT(o)      sizeof(o), (void *)&o
N#define MIB_IP(ip)      4, (void *)&ip 
N#define OID0(f,s)       (f*40 + s) 
N
N/* Debug Module Definitions */
N#define MODULE_MEM      0         /* Dynamic Memory Module ID                */
N#define MODULE_ETH      1         /* Ethernet Module ID                      */
N#define MODULE_PPP      2         /* PPP Module ID                           */
N#define MODULE_SLIP     3         /* SLIP Module ID                          */
N#define MODULE_ARP      4         /* ARP Module ID                           */
N#define MODULE_IP       5         /* IP Module ID                            */
N#define MODULE_ICMP     6         /* ICMP Module ID                          */
N#define MODULE_IGMP     7         /* IGMP Module ID                          */
N#define MODULE_UDP      8         /* UDP Module ID                           */
N#define MODULE_TCP      9         /* TCP Module ID                           */
N#define MODULE_NBNS     10        /* NBNS Module ID                          */
N#define MODULE_DHCP     11        /* DHCP Module ID                          */
N#define MODULE_DNS      12        /* DNS Module ID                           */
N#define MODULE_SNMP     13        /* SNMP Module ID                          */
N#define MODULE_APP      14        /* Application Modules ID                  */
N
N/*---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus               // EC++
Sextern "C"  {
N#endif
N
Ntypedef struct os_frame {         /* << TCPnet system frame buffer struct >> */
N  U16 length;                     /* Total Length of data in frame           */
N  U16 index;                      /* Buffer Position Index                   */
N  U8  data[1];                    /* Buffer data (protocol headers + data)   */
N} OS_FRAME;
N
N
Ntypedef struct arp_info {         /* << ARP Cache Entry info >>              */
N  U8  State;                      /* ARP Cache entry current state           */
N  U8  Type;                       /* Cache Entry type                        */
N  U8  Retries;                    /* Number of Retries left                  */
N  U8  Tout;                       /* Cache Entry Timeout                     */
N  U8  HwAdr[ETH_ADRLEN];          /* Ethernet Hardware Address               */
X  U8  HwAdr[6];           
N  U8  IpAdr[IP_ADRLEN];           /* Ethernet IP Address                     */
X  U8  IpAdr[4];            
N} ARP_INFO;
N
N
Ntypedef struct igmp_info {        /* << IGMP Group info >>                   */
N  U8  State;                      /* Group membership current state          */
N  U8  Tout;                       /* Timeout Timer for sending reports       */
N  U8  GrpIpAdr[IP_ADRLEN];        /* Group IP address                        */
X  U8  GrpIpAdr[4];         
N} IGMP_INFO;
N
N
Ntypedef struct udp_info {         /* << UDP Socket info >>                   */
N  U8  State;                      /* UDP Socket entry current state          */
N  U8  McastTtl;                   /* MultiCast Time To Live                  */
N  U16 LocPort;                    /* Local UDP port of Socket                */
N  U8  Tos;                        /* UDP Type of Service                     */
N  U8  Opt;                        /* UDP Socket Options                      */
N                                  /* Application Event CallBack function     */
N  U16 (*cb_func)(U8 socket, U8 *rem_ip, U16 port, U8 *buf, U16 len);
N} UDP_INFO;
N
N
Ntypedef struct tcp_info {         /* << TCP Socket info >>                   */
N  U8  State;                      /* TCP Socket entry current state          */
N  U8  Type;                       /* TCP Socket type                         */
N  U8  Flags;                      /* State machine flags                     */
N  U8  Tos;                        /* Type of service allocated               */
N  U8  RemIpAdr[IP_ADRLEN];        /* Remote IP address                       */
X  U8  RemIpAdr[4];         
N  U16 RemPort;                    /* Remote TCP port                         */
N  U16 LocPort;                    /* Local TCP port                          */
N  U16 MaxSegSize;                 /* Transmit Max. Segment Size              */
N  U16 WinSize;                    /* Receive Window Size                     */
N  U32 SendSeq;                    /* Current Send Sequence Number not acked  */
N  U32 SendSeqNext;                /* Next Send Sequence Number               */
N  U32 RecSeqNext;                 /* Next Receive Sequence Number            */
N  U16 Tout;                       /* Socket idle timeout (in seconds)        */
N  U16 AliveTimer;                 /* Keep Alive timer value                  */
N  U16 RetryTimer;                 /* Retransmission timer value              */
N  U8  TxFlags;                    /* TCP Transmit Flags                      */
N  U8  Retries;                    /* Number of retries left before aborting  */
N  OS_FRAME *ReTransFrm;           /* Retransmission frame                    */
N                                  /* Application Event-CallBack function     */
N  U16 (*cb_func)(U8 socket, U8 event, U8 *p1, U16 p2);
N} TCP_INFO;
N
N
Ntypedef struct http_info {        /* << HTTP Session info >>                 */
N  U8  State;                      /* HTTP Session current state              */
N  U8  Socket;                     /* binded TCP Socket                       */
N  U16 Flags;                      /* State machine Flags                     */
N  U8  FType;                      /* File Type: html, jpeg, gif,...          */
N  U8  PostSt;                     /* POST method Processing Status           */
N  U16 DelimSz;                    /* Boundary delimiter size                 */
N  U32 CGIvar;                     /* CGI session private variable (cgi_func) */
N  U32 DLen;                       /* Data length (number of bytes to send)   */
N  U32 Count;                      /* Total number of bytes sent              */
N  U16 BCnt;                       /* Number of bytes sent in last packet     */
N  U8  Lang[6];                    /* Selected Web Language: en-us, de, fr .. */
N  U32 LMDate;                     /* Last Modified Date (UTC format)         */
N  U8 *Script;                     /* Script Buffer pointer                   */
N  U8 *pDelim;                     /* Multipart Boundary delimiter value      */
N  void *sFile;                    /* Script Interpreter File pointer         */
N  void *dFile;                    /* Data File pointer                       */
N} HTTP_INFO;
N
N
Ntypedef struct http_file {        /* << HTTP Internal File info >>           */
N  const U32 Id;                   /* File Name Id (CRC32 value of file name) */
N  const U8 *Start;                /* File Start Address in ROM               */
N} HTTP_FILE;
N
N
Ntypedef struct tnet_info {        /* << Telnet Session info >>               */
N  U8  State;                      /* Telnet Session current state            */
N  U8  Socket;                     /* binded TCP Socket                       */
N  U8  Flags;                      /* State machine Flags                     */
N  U8  BCnt;                       /* Received Data byte count                */
N  U16 Tout;                       /* Timeout delay counter                   */
N  U8  Widx;                       /* Fifo buffer Write index                 */
N  U8  Ridx;                       /* Fifo buffer Read index                  */
N  U32 SVar;                       /* Session private var. (tnet_process_cmd) */
N  U8  LBuf[TNET_LBUFSZ];          /* Data Line Buffer                        */
X  U8  LBuf[96];           
N  U8  Fifo[TNET_FIFOSZ];          /* Fifo Buffer for received line/keycodes  */
X  U8  Fifo[128];           
N  U8  hNext;                      /* History command next position           */
N  U8  hCurr;                      /* History command current position        */
N  U8  Hist[TNET_HISTSZ];          /* Command History buffer                  */
X  U8  Hist[128];           
N} TNET_INFO;
N
N
Ntypedef struct tftp_info {        /* << TFTP Session info >>                 */
N  U8  State;                      /* TFTP Session current state              */
N  U8  Retries;                    /* Number of retries                       */
N  U8  Flags;                      /* State machine Flags                     */
N  U16 Timer;                      /* Timeout Timer value                     */
N  U8  RemIpAdr[IP_ADRLEN];        /* Remote IP address                       */
X  U8  RemIpAdr[4];         
N  U16 RemPort;                    /* Remote UDP port                         */
N  U16 BlockNr;                    /* Block Number                            */
N  void *File;                     /* File Handle pointer                     */
N  U32 FPos;                       /* File Position indicator                 */
N} TFTP_INFO;
N
N
Ntypedef struct ftp_info {         /* << FTP Session info >>                  */
N  U8  State;                      /* FTP Session current state               */
N  U8  Socket;                     /* binded TCP Control Socket               */
N  U8  Flags;                      /* State machine Flags                     */
N  U8  Resp;                       /* FTP Server Response Code                */
N  U8  RemIpAdr[IP_ADRLEN];        /* Client IP address                       */
X  U8  RemIpAdr[4];         
N  U16 DPort;                      /* TCP Data port (Server or Client)        */
N  U8  DSocket;                    /* TCP Data Socket                         */
N  U8  PathLen;                    /* Size of the Path string                 */
N  U8 *Path;                       /* Current Working Directory               */
N  U8 *Name;                       /* Absolute File/Folder Path Name          */
N  void *File;                     /* File Handle pointer                     */
N} FTP_INFO;
N
N
Ntypedef struct dns_cache {        /* << DNS Cache Entry info >>              */
N  U32 HostId;                     /* Host Id (CRC32 value of host name)      */
N  U32 Ttl;                        /* Cache Entry Time To Live                */
N  U8  IpAdr[IP_ADRLEN];           /* Ethernet IP Address                     */
X  U8  IpAdr[4];            
N} DNS_CACHE;
N
N
Ntypedef struct localm {           /* << Local Machine info >>                */
N  U8 IpAdr[IP_ADRLEN];            /* Local IP Address                        */
X  U8 IpAdr[4];             
N  U8 DefGW[IP_ADRLEN];            /* Default GateWay                         */
X  U8 DefGW[4];             
N  U8 NetMask[IP_ADRLEN];          /* Net Mask                                */
X  U8 NetMask[4];           
N  U8 PriDNS[IP_ADRLEN];           /* Primary DNS Server                      */
X  U8 PriDNS[4];            
N  U8 SecDNS[IP_ADRLEN];           /* Secondary DNS Server                    */
X  U8 SecDNS[4];            
N} LOCALM;
N
N
Ntypedef struct remotem {          /* << Remote Machine Info >>               */
N  U8 IpAdr[IP_ADRLEN];            /* Remote IP address                       */
X  U8 IpAdr[4];             
N  U8 HwAdr[ETH_ADRLEN];           /* Remote Hardware Address                 */
X  U8 HwAdr[6];            
N} REMOTEM;
N
N
Ntypedef struct mib_entry {        /* << SNMP-MIB Entry Info >>               */
N  U8   Type;                      /* Object Type                             */
N  U8   OidLen;                    /* Object ID length                        */
N  U8   Oid[MIB_OIDSZ];            /* Object ID value                         */
X  U8   Oid[13];             
N  U8   ValSz;                     /* Size of a Variable                      */
N  void *Val;                      /* Pointer to a variable                   */
N  void (*cb_func)(int mode);      /* Write/Read event callback function      */
N} MIB_ENTRY;
N
N
Ntypedef enum {                    /* << Fatal System Error Codes >>          */
N  ERR_MEM_ALLOC,
N  ERR_MEM_FREE,
N  ERR_MEM_CORRUPT,
N  ERR_UDP_ALLOC,
N  ERR_TCP_ALLOC,
N  ERR_TCP_STATE
N} ERROR_CODE;
N
N
N/*----------------------------------------------------------------------------
N *      Functions
N *---------------------------------------------------------------------------*/
N
N/* Net_Config.c */
Nextern void init_system (void);
Nextern void run_system (void);
Nextern void process_hl_igmp (OS_FRAME *frame);
Nextern void process_hl_udp (OS_FRAME *frame);
Nextern void process_hl_tcp (OS_FRAME *frame);
Nextern BOOL dispatch_frame (OS_FRAME *frame, U8 netif);
Nextern BOOL eth_chk_adr (OS_FRAME *frame);
Nextern U8  *eth_get_adr (U8 *ipadr);
N__weak void arp_notify (void);
Nextern void sys_error (ERROR_CODE code);
N
N/* at_Mem.c */
Nextern OS_FRAME *alloc_mem (U32 byte_size);
Nextern void free_mem (OS_FRAME *mem_ptr);
N
N/* at_Ethernet.c */
Nextern void init_eth_link (void);
Nextern void run_eth_link (void);
Nextern void put_in_queue (OS_FRAME *frame);
Nextern BOOL eth_send_frame (OS_FRAME *frame);
N
N/* at_Ppp.c */
Nextern void init_ppp_link (void);
Nextern void run_ppp_link (void);
Nextern BOOL ppp_send_frame (OS_FRAME *frame, U16 prot);
N
N/* at_Slip.c */
Nextern void init_slip_link (void);
Nextern void run_slip_link (void);
Nextern BOOL slip_send_frame (OS_FRAME *frame);
N
N/* at_Lib.c */
Nextern int  mem_copy (void *dp, void *sp, int len);
Nextern void mem_rcopy (void *dp, void *sp, int len);
Nextern BOOL mem_comp (void *sp1, void *sp2, int len);
Nextern void mem_set (void *dp, U8 val, int len);
Nextern BOOL mem_test (void *sp, U8 val, int len);
Nextern BOOL str_scomp (U8 *sp, U8 const *cp);
Nextern int  str_copy (U8 *dp, U8 *sp);
Nextern void str_up_case (U8 *dp, U8 *sp);
Nextern U16  SwapB (U16 w16);
Nextern U16  get_u16 (U8 *p16);
Nextern U32  get_u32 (U8 *p32);
Nextern void set_u32 (U8 *p32, U32 val);
N
N/* at_Arp.c */
Nextern void arp_send_req (U32 entry);
N
N/* at_Igmp.c */
Nextern void init_igmp (void);
Nextern void run_igmp_host (void);
Nextern void process_igmp (OS_FRAME *frame);
N
N/* at_Udp.c */
Nextern void init_udp (void);
Nextern void process_udp (OS_FRAME *frame);
N
N/* at_Tcp.c */
Nextern void init_tcp (void);
Nextern void tcp_poll_sockets (void);
Nextern void process_tcp (OS_FRAME *frame_r);
N
N/* at_Http.c */
Nextern void init_http (void);
Nextern void run_http_server (void);
Nextern void *http_fopen (U8 *name);
Nextern void http_fclose (void *file);
Nextern U16  http_fread (void *file, U8 *buf, U16 len);
Nextern BOOL http_fgets (void *file, U8 *buf, U16 size);
Nextern U32  http_finfo (U8 *name);
Nextern void cgi_process_var (U8 *qstr);
Nextern void cgi_process_data (U8 code, U8 *dat, U16 len);
Nextern U16  cgi_func (U8 *env, U8 *buf, U16 buflen, U32 *pcgi);
Nextern U8  *cgx_content_type (void);
Nextern BOOL http_accept_host (U8 *rem_ip, U16 rem_port);
Nextern U8  *http_get_var (U8 *env, void *ansi, U16 maxlen);
Nextern U8  *http_get_lang (void);
Nextern void http_get_info (REMOTEM *info);
Nextern U8   http_get_session (void);
Nextern U8  *http_get_content_type (void);
Nextern U32  http_date (RL_TIME *time);
N
N/* at_Telnet.c */
Nextern void init_tnet (void);
Nextern void run_tnet_server (void);
Nextern U16  tnet_cbfunc (U8 code, U8 *buf, U16 buflen);
Nextern U16  tnet_process_cmd (U8 *cmd, U8 *buf, U16 buflen, U32 *pvar);
Nextern BOOL tnet_ccmp (U8 *buf, U8 *cmd);
Nextern void tnet_set_delay (U16 cnt);
Nextern void tnet_get_info (REMOTEM *info);
Nextern U8   tnet_get_session (void);
Nextern BOOL tnet_msg_poll (U8 session);
N
N/* at_Tftp.c */
Nextern void init_tftp (void);
Nextern void run_tftp_server (void);
Nextern void *tftp_fopen (U8 *fname, U8 *mode);
Nextern void tftp_fclose (void *file);
Nextern U16  tftp_fread (void *file, U32 fpos, U8 *buf);
Nextern U16  tftp_fwrite (void *file, U8 *buf, U16 len);
N
N/* at_Ftp.c */
Nextern void init_ftp (void);
Nextern void run_ftp_server (void);
Nextern void *ftp_fopen (U8 *fname, U8 *mode);
Nextern void ftp_fclose (void *file);
Nextern U16  ftp_fread (void *file, U8 *buf, U16 len);
Nextern U16  ftp_fwrite (void *file, U8 *buf, U16 len);
Nextern BOOL ftp_fdelete (U8 *fname);
Nextern BOOL ftp_frename (U8 *fname, U8 *newn);
Nextern U16  ftp_ffind (U8 code, U8 *buf, U8 *mask, U16 len);
N
N/* at_Dhcp.c */
Nextern void init_dhcp (void);
Nextern void run_dhcp_client (void);
N
N/* at_Nbns.c */
Nextern void init_nbns (void);
N
N/* at_Dns.c */
Nextern void init_dns (void);
Nextern void run_dns_client (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8, U8 *));
N
N/* at_Smtp.c */
Nextern void init_smtp (void);
Nextern void run_smtp_client (void);
Nextern U16  smtp_cbfunc (U8 code, U8 *buf, U16 buflen, U32 *pvar);
Nextern BOOL smtp_accept_auth (U8 *srv_ip);
N
N/* Ethernet Device Driver */
Nextern void init_ethernet (void);
Nextern void send_frame (OS_FRAME *frame);
Nextern void poll_ethernet (void);
Nextern void int_enable_eth (void);
Nextern void int_disable_eth (void);
N
N/* Serial Device Driver */
Nextern void init_serial (void);
Nextern int  com_getchar (void);
Nextern BOOL com_putchar (U8 c);
Nextern BOOL com_tx_active (void);
N
N/* Modem Device Driver */
Nextern void init_modem (void);
Nextern void modem_dial (U8 *dialnum);
Nextern void modem_hangup (void);
Nextern void modem_listen (void);
Nextern BOOL modem_online (void);
Nextern BOOL modem_process (U8 ch);
Nextern void modem_run (void);
N
N#ifdef __cplusplus               // EC++
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
N#endif
N
L 36 "main.c" 2
N#include "uart0.h"
L 1 "uart0.h" 1
N
N#define RX_BUFFER_SIZE0 1024
N#define TX_BUFFER_SIZE0 1024
N
N#define BUFSIZE    		1024
N
N#define IER_RBR		0x01
N#define IER_THRE		0x02
N#define IER_RLS		0x04
N
N#define PT	(UIB0[1]&0x80)
N#define C_D	(UIB0[1]&0x40)
N#define FR	(UIB0[1]&0x20)
N
N#define IIR_PEND	0x01
N#define IIR_RLS		0x03
N#define IIR_RDA		0x02
N#define IIR_CTI		0x06
N#define IIR_THRE	0x01
N
N#define LSR_RDR		0x01
N#define LSR_OE		0x02
N#define LSR_PE		0x04
N#define LSR_FE		0x08
N#define LSR_BI		0x10
N#define LSR_THRE	0x20
N#define LSR_TEMT	0x40
N#define LSR_RXFE	0x80
N
N#define VIC_UART0	6
N
Nextern char bRXIN0;
Nextern char UIB0[100];
Nextern char flag0;
Nextern char rx_buffer0[RX_BUFFER_SIZE0];
Xextern char rx_buffer0[1024];
Nextern unsigned char tx_buffer0[TX_BUFFER_SIZE0];
Xextern unsigned char tx_buffer0[1024];
Nextern unsigned short rx_wr_index0,rx_rd_index0,rx_counter0;
Nextern unsigned short tx_wr_index0,tx_rd_index0,tx_counter0;
Nextern char rx_buffer_overflow0;
Nextern char plazma_uart0;
Nextern char memo_out[50];
Nextern char data_rs[50];
Nextern char data_rs0[50];
Nextern const char Table87[];
Nextern const char Table95[]; 
N
Nchar crc_87(char* ptr,char num);
Nchar crc_95(char* ptr,char num);
Nvoid putchar0(char c);
Nvoid uart_out0 (char num,char data0,char data1,char data2,char data3,char data4,char data5);
Nvoid uart_out_adr0 (char *ptr, char len);
Nvoid uart0_init(void);
Nchar getchar0(void);
N__irq void uart0_interrupt(void);
Nvoid uart_in_an0(void);
Nsigned short index_offset0 (signed short index,signed short offset);
Nchar control_check0(signed short index);
Nvoid uart_in0(void);
Nvoid uart_out_adr_block (unsigned long adress,char *ptr, char len);
Nvoid rs232_data_out(void);
Nvoid rs232_data_out_tki(void);
Nvoid uart_out_buff0 (char *ptr, char len);
Nvoid rs232_data_out_1(void);
Nuint32_t UARTInit( uint32_t PortNum, uint32_t baudrate );
N
L 37 "main.c" 2
N#include <rtl.h>
N#include "modbus.h"
L 1 "modbus.h" 1
N
Nextern unsigned char modbus_buf[20];
Nextern short modbus_crc16;
Nextern char modbus_timeout_cnt;
Nextern char bMODBUS_TIMEOUT;
Nextern unsigned char modbus_rx_buffer[30];	//Буфер, куда складывает принимаемые даннные обработчик прерывания по приему УАРТа
Nextern unsigned char modbus_an_buffer[30];	//Буфер, куда они потом копируются для анализа
Nextern unsigned char modbus_rx_buffer_ptr;	//Указатель на текущую позицию принимающего буфера
Nextern unsigned char modbus_rx_counter;		//Количество принятых байт, используется при анализе целостности посылки и при расшифровке
N
Nextern short modbus_plazma;				//Отладка
Nextern short modbus_plazma1;				//Отладка
Nextern short modbus_plazma2;				//Отладка
Nextern short modbus_plazma3;				//Отладка
N
Nextern unsigned short modbus_rx_arg0;		//встроенный в посылку первый аргумент
Nextern unsigned short modbus_rx_arg1;		//встроенный в посылку второй аргумент
Nextern unsigned short modbus_rx_arg2;		//встроенный в посылку третий аргумент
Nextern unsigned short modbus_rx_arg3;		//встроенный в посылку четвертый аргумент
N
Nextern char modbus_tx_buff[100];
N
N//extern char modbus_registers[200];
N//-----------------------------------------------
Nunsigned short CRC16_2(char* buf, short len);
N//-----------------------------------------------
N//void modbus_registers_transmit(unsigned char adr,unsigned char func,unsigned short reg_adr,unsigned short reg_quantity);
N//-----------------------------------------------
N//void modbus_register_transmit(unsigned char adr,unsigned char func,unsigned short reg_adr);
N//-----------------------------------------------
Nvoid modbus_hold_registers_transmit(unsigned char adr,unsigned char func,unsigned short reg_adr,unsigned short reg_quantity, char prot);
N//-----------------------------------------------
Nvoid modbus_input_registers_transmit(unsigned char adr,unsigned char func,unsigned short reg_adr,unsigned short reg_quantity, char prot);
N//-----------------------------------------------
N//void modbus_hold_register_transmit(unsigned char adr,unsigned char func,unsigned short reg_adr);
N
N
N
L 39 "main.c" 2
N#include "sacred_sun.h"
L 1 "sacred_sun.h" 1
N
Nextern char portForSacredSunBatteryIsInitiated;
Nextern char sacredSunBatteryHndlPhase;
Nextern char liBatteryInBuff[300];
Nextern char sacredSunRequestPhase;
Nextern short sacredSunSilentCnt;
N
Nvoid sacred_san_bat_hndl(void);
Nshort ascii2halFhex(char in);
L 40 "main.c" 2
N#include "ztt.h"
L 1 "ztt.h" 1
N
Nextern char portZTTSunBatteryIsInitiated;
Nextern char zTTBatteryHndlPhase;
Nextern char liBatteryInBuff[300];
Nextern char zTTRequestPhase;
Nextern short zTTSilentCnt[3];
Nextern char zTTButteryCnter;
Nextern char zTTBatteryHndlCmnd;
N
Nvoid ztt_bat_hndl(void);
L 41 "main.c" 2
N#include "mcp2515.h"
L 1 "mcp2515.h" 1
N
N#define MCP2515_CS 1
N#define MCP2515_CS_ON       LPC_GPIO0->FIODIR|=(1UL<<MCP2515_CS);LPC_GPIO0->FIOCLR|=(1UL<<MCP2515_CS);
N#define MCP2515_CS_OFF      LPC_GPIO0->FIODIR|=(1UL<<MCP2515_CS);LPC_GPIO0->FIOSET|=(1UL<<MCP2515_CS);
N
N
N
N
N//#if(KAN_XTAL==8)
N//#define CNF1_init	0xc3 /*0b11000011*/  //tq=500ns   //8MHz
N//#define CNF2_init	0xfb /*0b11111011*/  //Ps1=7tq,Pr=2tq 
N//#define CNF3_init	0x02 /*0b00000010*/  //Ps2=6tq   
N//#elif(KAN_XTAL==10)
N#define CNF1_init	0xc3 /*0b11000011*/  //tq=500ns   //10MHz
N#define CNF2_init	0xfe /*0b11111110*/  //Ps1=7tq,Pr=2tq 
N#define CNF3_init	0x03 /*0b00000011*/  //Ps2=6tq
N//#elif(KAN_XTAL==20)
N//#define CNF1_init	0xc7 /*0b11000111*/  //tq=500ns   //20MHz
N//#define CNF2_init	0xfe /*0b11111110*/  //Ps1=7tq,Pr=2tq 
N//#define CNF3_init	0x03 /*0b00000011*/  //Ps2=6tq
N//#endif
N
N
N
N
N
N#define RXF0SIDH	0x00
N#define RXF0SIDL	0x01
N#define RXF0EID8	0x02
N#define RXF0EID0	0x03
N#define RXF1SIDH	0x04
N#define RXF1SIDL	0x05
N#define RXF1EID8	0x06
N#define RXF1EID0	0x07
N#define RXF2SIDH	0x08
N#define RXF2SIDL	0x09
N#define RXF2EID8	0x0a
N#define RXF2EID0	0x0b
N#define BFPCTRL	0x0c
N#define TXRTSCTRL	0x0d
N#define CANSTAT	0x0e
N#define CANCTRL	0x0f
N
N#define RXF3SIDH	0x10
N#define RXF3SIDL	0x11
N#define RXF3EID8	0x12
N#define RXF3EID0	0x13
N#define RXF4SIDH	0x14
N#define RXF4SIDL	0x15
N#define RXF4EID8	0x16
N#define RXF4EID0	0x17
N#define RXF5SIDH	0x18
N#define RXF5SIDL	0x19
N#define RXF5EID8	0x1a
N#define RXF5EID0	0x1b
N#define TEC		0x1c
N#define REC		0x1d 
N
N#define RXM0SIDH	0x20
N#define RXM0SIDL	0x21
N#define RXM0EID8	0x22
N#define RXM0EID0	0x23
N#define RXM1SIDH	0x24
N#define RXM1SIDL	0x25
N#define RXM1EID8	0x26
N#define RXM1EID0	0x27
N#define CNF3		0x28 
N#define CNF2		0x29
N#define CNF1		0x2a
N#define CANINTE	0x2b
N#define CANINTF	0x2c
N#define EFLG		0x2d
N
N#define TXB0CTRL	0x30
N#define TXB0SIDH	0x31
N#define TXB0SIDL	0x32
N#define TXB0EID8	0x33
N#define TXB0EID0	0x34
N#define TXB0DLC	0x35
N#define TXB0D0		0x36
N#define TXB0D1		0x37
N#define TXB0D2		0x38 
N#define TXB0D3		0x39
N#define TXB0D4		0x3a
N#define TXB0D5		0x3b
N#define TXB0D6		0x3c
N#define TXB0D7		0x3d
N
N#define TXB1CTRL	0x40
N#define TXB1SIDH	0x41
N#define TXB1SIDL	0x42
N#define TXB1EID8	0x43
N#define TXB1EID0	0x44
N#define TXB1DLC	0x45
N#define TXB1D0		0x46
N#define TXB1D1		0x47
N#define TXB1D2		0x48 
N#define TXB1D3		0x49
N#define TXB1D4		0x4a
N#define TXB1D5		0x4b
N#define TXB1D6		0x4c
N#define TXB1D7		0x4d
N
N#define TXB2CTRL	0x50
N#define TXB2SIDH	0x51
N#define TXB2SIDL	0x52
N#define TXB2EID8	0x53
N#define TXB2EID0	0x54
N#define TXB2DLC	0x55
N#define TXB2D0		0x56
N#define TXB2D1		0x57
N#define TXB2D2		0x58 
N#define TXB2D3		0x59
N#define TXB2D4		0x5a
N#define TXB2D5		0x5b
N#define TXB2D6		0x5c
N#define TXB2D7		0x5d
N
N#define RXB0CTRL	0x60
N#define RXB0SIDH	0x61
N#define RXB0SIDL	0x62
N#define RXB0EID8	0x63
N#define RXB0EID0	0x64
N#define RXB0DLC	0x65
N#define RXB0D0		0x66
N#define RXB0D1		0x67
N#define RXB0D2		0x68 
N#define RXB0D3		0x69
N#define RXB0D4		0x6a
N#define RXB0D5		0x6b
N#define RXB0D6		0x6c
N#define RXB0D7		0x6d
N
N#define RXB1CTRL	0x70
N#define RXB1SIDH	0x71
N#define RXB1SIDL	0x72
N#define RXB1EID8	0x73
N#define RXB1EID0	0x74
N#define RXB1DLC	0x75
N#define RXB1D0		0x76
N#define RXB1D1		0x77
N#define RXB1D2		0x78 
N#define RXB1D3		0x79
N#define RXB1D4		0x7a
N#define RXB1D5		0x7b
N#define RXB1D6		0x7c
N#define RXB1D7		0x7d
N
Nextern char mcp2515_can_st,mcp2515_can_st_old;
Nextern char MCP2515_RXBUFF[40];
Nextern char bMCP2515_IN;
Nextern char mcp2515_out_buff[8][8];
Nextern char mcp2515_buff_wr_ptr;
Nextern char mcp2515_buff_rd_ptr;
N
N
N//-----------------------------------------------
Nvoid mcp2515_reset(void);
N//-----------------------------------------------
Nchar mcp2515_write(char addr,char in);
N//-----------------------------------------------
Nchar mcp2515_read(char addr);
N//-----------------------------------------------
Nvoid mcp2515_bit_modify(char addr,char mask,char data);
N//-----------------------------------------------
Nchar mcp2515_read_status(void);
N//-----------------------------------------------
Nvoid mcp2515_rts(char in);
N//-----------------------------------------------
Nvoid can_mcp2515_init(void);
N//-----------------------------------------------
Nvoid can_mcp2515_hndl(void);
N
L 42 "main.c" 2
N//#include "sc16is7xx.h"
N#include "modbus_tcp.h"
L 1 "modbus_tcp.h" 1
N
Nextern char plazma_modbus_tcp[20];
N
NU16 tcp_callback (U8 soc, U8 evt, U8 *ptr, U16 par);
N
Nextern char modbus_tcp_func;
Nextern char modbus_tcp_unit;
Nextern short modbus_tcp_rx_arg0;
Nextern short modbus_tcp_rx_arg1;
N
N#define MODBUS_TCP_PROT	1
N
Nextern char* modbus_tcp_out_ptr;
N
NU16 tcp_callback (U8 soc, U8 evt, U8 *ptr, U16 par);
N
L 44 "main.c" 2
N
Nextern U8 own_hw_adr[];
Nextern U8  snmp_Community[];
NBOOL tick;
Nextern LOCALM localm[];
N#define MY_IP localm[NETIF_ETH].IpAdr
N#define DHCP_TOUT   50
N
N//***********************************************
N//Таймер
Nchar b10000Hz,b1000Hz,b2000Hz,b100Hz,b50Hz,b10Hz,b5Hz,b2Hz,b1Hz,b1min;
Nshort t0cnt,t0cnt0,t0cnt1,t0cnt2,t0cnt3,t0cnt4,t0cnt5,t0cnt6,t0_cnt7,t0_cnt_min,t0cntMin;
Nchar bFL5,bFL2,bFL,bFL_,bTPS;
Nsigned short main_10Hz_cnt=0;
Nsigned short main_1Hz_cnt=0;
N
N 
N//***********************************************
N//Структура ИБЭПа
Nchar cnt_of_slave=3;
N//char cnt_of_wrks;   //колличество работающих источников , для индикации
N
N
N
N//**********************************************
N//Коэффициенты, отображаемые из EEPROM
Nsigned short Ktsrc[2];
Nsigned short Kusrc[2];
Nsigned short Kisrc[2];
Nsigned short Ki0src[2];
Nsigned short Kubat[2];
Nsigned short Kubatm[2];
Nunsigned short Kibat0[2];
Nsigned short Kibat1[2];
Nsigned short Ktbat[2];
Nsigned short Kunet;
Nsigned short Kunet_ext[3];
Nsigned short Ktext[3];
Nsigned short Kuload;
Nsigned short KunetA;
Nsigned short KunetB;
Nsigned short KunetC;
Nsigned short Kubps;
Nsigned short Kuout;
Nsigned short Kuvd;
N
Nsigned short MAIN_IST;
Nsigned short UMAX;
Nsigned short UOUT;
Nsigned short UOUT_;
Nsigned short UAVT;
Nsigned short TMAX;
Nsigned short TSIGN;
Nsigned short TSYSMAX;
Nsigned short AV_OFF_AVT;
Nsigned short USIGN;
Nsigned short UMN;
Nsigned short ZV_ON;
Nsigned short UINMAX;
Nsigned short UINMIN;
Nsigned short UOUTMAX;
Nsigned short UOUTMIN;
N
Nsigned short IKB;
N//signed short KVZ;
N
Nsigned short IMAX;
Nsigned short IMIN;
Nsigned short APV_ON;
Nsigned short IZMAX;
Nsigned short U0B;
Nsigned short TZAS;
Nsigned short VZ_HR;
Nsigned short TBAT;
Nsigned short U_AVT;
Nsigned short DU;
N//signed short PAR;
N
Nsigned short RELE_SET_MASK[4]={1,2,3,4};
N
Nsigned short TBATMAX;
Nsigned short TBATSIGN;
Nsigned short UBM_AV;
Nsigned short RELE_LOG;
Nsigned short TBOXMAX;
Nsigned short TBOXREG;
Nsigned short TBOXVENTMAX;
Nsigned short TLOADDISABLE;
Nsigned short TLOADENABLE;
Nsigned short TBATDISABLE;
Nsigned short TBATENABLE;
Nsigned short TVENTON;
Nsigned short TVENTOFF;
Nsigned short TWARMON;
Nsigned short TWARMOFF;
Nenum_releventsign RELEVENTSIGN;
Nsigned short TZNPN;
Nsigned short UONPN;
Nsigned short UVNPN;
Nenum_npn_out NPN_OUT;
Nenum_npn_sign NPN_SIGN;
Nsigned short TERMOKOMPENS;
Nsigned short TBOXVENTON; 
Nsigned short TBOXVENTOFF;
Nsigned short TBOXWARMON; 
Nsigned short TBOXWARMOFF;
Nsigned short BAT_TYPE;	//Тип батареи. 0 - обычная свинцовая, 1-литиевая COSLIGHT, 2-литиевая SACRED SUN , 3-литиевая ZTT
Nsigned short DU_LI_BAT;	//Параметр, определяющий напряжение содержания литиевой батареи
Nsigned short FORVARDBPSCHHOUR;	//Периодичностьсмены ведущего источника в часах. Если 0 - функция выключена и ведущий первый источник
Nsigned short NUMBAT;
Nsigned short NUMBAT_TELECORE;
Nsigned short NUMIST;
Nsigned short NUMINV;
Nsigned short NUMDT;
Nsigned short NUMSK;
Nsigned short NUMEXT;
Nsigned short NUMAVT;
Nsigned short NUMMAKB;
Nsigned short NUMBYPASS;
Nsigned short U_OUT_KONTR_MAX;
Nsigned short U_OUT_KONTR_MIN;
Nsigned short U_OUT_KONTR_DELAY;
Nsigned short DOP_RELE_FUNC;
Nsigned short CNTRL_HNDL_TIME;	//Постоянная времени регулирования источников для Телекора
Nsigned short USODERG_LI_BAT;	//Напряжение содержания литиевой батареи
Nsigned short QSODERG_LI_BAT;	//Заряд при котором начинает действовать напряжение содержания литиевой батареи
Nsigned short TVENTMAX;			//Максимальный ресурс вентилятора
Nsigned short ICA_EN;			//Включенность режима выравнивания токов ИПС
Nsigned short ICA_CH;			//Канал связи для выравнивания токов, 0 - MODBUS, 1 - MODBUS-TCP
Nsigned short ICA_MODBUS_ADDRESS;//Адрес ведомого для выравнивания токов по шине MODBUS-RTU
Nsigned short ICA_MODBUS_TCP_IP1,ICA_MODBUS_TCP_IP2,ICA_MODBUS_TCP_IP3,ICA_MODBUS_TCP_IP4;	//IP ведомого для выравнивания токов по шине MODBUS-TCP
Nsigned short ICA_MODBUS_TCP_UNIT_ID;	//UNIT ID ведомого для выравнивания токов по шине MODBUS-TCP
Nsigned short PWM_START;			//Начальный шим для ЭЛТЕХа
Nsigned short KB_ALGORITM;		//2-х или 3-х ступеннчатый алгоритм проверки цепи батареи
Nsigned short REG_SPEED;			//скорость регулирования, 1- стандартная, 2,3,4,5- замедленная в 2,3,4,5 раз
Nenum_apv_on APV_ON1,APV_ON2;
Nsigned short APV_ON2_TIME;
N
Nenum_bat_is_on BAT_IS_ON[2];
Nsigned short BAT_DAY_OF_ON[2];
Nsigned short BAT_MONTH_OF_ON[2];
Nsigned short BAT_YEAR_OF_ON[2];
Nsigned short BAT_C_NOM[2];
Nsigned short BAT_RESURS[2];
Nsigned short BAT_C_REAL[2];
N//signed short BAT_TYPE[2];
N
Nunsigned short AUSW_MAIN;
Nunsigned long AUSW_MAIN_NUMBER;
Nunsigned short AUSW_DAY;
Nunsigned short AUSW_MONTH;
Nunsigned short AUSW_YEAR;
Nunsigned short AUSW_UKU;
Nunsigned short AUSW_UKU_SUB;
Nunsigned long AUSW_UKU_NUMBER;
Nunsigned long	AUSW_BPS1_NUMBER;
Nunsigned long  AUSW_BPS2_NUMBER;
Nunsigned short AUSW_RS232;
Nunsigned short AUSW_PDH;
Nunsigned short AUSW_SDH;
Nunsigned short AUSW_ETH;
N
Nsigned short TMAX_EXT_EN[3];
Nsigned short TMAX_EXT[3];
Nsigned short TMIN_EXT_EN[3];
Nsigned short TMIN_EXT[3];
Nsigned short T_EXT_REL_EN[3];
Nsigned short T_EXT_ZVUK_EN[3];
Nsigned short T_EXT_LCD_EN[3];
Nsigned short T_EXT_RS_EN[3];
N
Nsigned short SK_SIGN[4];
Nsigned short SK_REL_EN[4];
Nsigned short SK_ZVUK_EN[4];
Nsigned short SK_LCD_EN[4];
Nsigned short SK_RS_EN[4];
N
Nenum_avz AVZ;
N
Nunsigned short HOUR_AVZ;
Nunsigned short MIN_AVZ;
Nunsigned short SEC_AVZ;
Nunsigned short DATE_AVZ;
Nunsigned short MONTH_AVZ;
Nunsigned short YEAR_AVZ;
Nunsigned short AVZ_TIME;
N
Nenum_mnemo_on MNEMO_ON;
Nunsigned short MNEMO_TIME;
N
Nsigned short POWER_CNT_ADRESS;
N
Nsigned short ETH_IS_ON;
Nsigned short ETH_DHCP_ON;
Nsigned short ETH_IP_1;
Nsigned short ETH_IP_2;
Nsigned short ETH_IP_3;
Nsigned short ETH_IP_4;
Nsigned short ETH_MASK_1;
Nsigned short ETH_MASK_2;
Nsigned short ETH_MASK_3;
Nsigned short ETH_MASK_4;
Nsigned short ETH_TRAP1_IP_1;
Nsigned short ETH_TRAP1_IP_2;
Nsigned short ETH_TRAP1_IP_3;
Nsigned short ETH_TRAP1_IP_4;
Nsigned short ETH_TRAP2_IP_1;
Nsigned short ETH_TRAP2_IP_2;
Nsigned short ETH_TRAP2_IP_3;
Nsigned short ETH_TRAP2_IP_4;
Nsigned short ETH_TRAP3_IP_1;
Nsigned short ETH_TRAP3_IP_2;
Nsigned short ETH_TRAP3_IP_3;
Nsigned short ETH_TRAP3_IP_4;
Nsigned short ETH_TRAP4_IP_1;
Nsigned short ETH_TRAP4_IP_2;
Nsigned short ETH_TRAP4_IP_3;
Nsigned short ETH_TRAP4_IP_4;
Nsigned short ETH_TRAP5_IP_1;
Nsigned short ETH_TRAP5_IP_2;
Nsigned short ETH_TRAP5_IP_3;
Nsigned short ETH_TRAP5_IP_4;
N
Nsigned short ETH_SNMP_PORT_READ;
Nsigned short ETH_SNMP_PORT_WRITE;
N
Nsigned short ETH_GW_1;
Nsigned short ETH_GW_2;
Nsigned short ETH_GW_3;
Nsigned short ETH_GW_4;
N
Nsigned short RELE_VENT_LOGIC;
N
Nsigned short MODBUS_ADRESS;
Nsigned short MODBUS_BAUDRATE;
Nsigned short BAT_LINK;
Nsigned short I_LOAD_MODE;	//способ измерения выходного тока - по шунту или как сумму токов источников
N
N
N
N//***********************************************
N//Состояние батарей
NBAT_STAT bat[2],bat_ips;
Nsigned short		bat_u_old_cnt;
Nsigned short 		Ib_ips_termokompensat;
N
N//***********************************************
N//Мониторы АКБ
NMAKB_STAT makb[4];
N
N//***********************************************
N//Литиевые АКБ
NLAKB_STAT lakb[3];
Nchar lakb_damp[1][42];
Nchar bLAKB_KONF_CH=0;
Nchar bLAKB_KONF_CH_old=0;
Nchar lakb_ison_mass[7];
Nshort lakb_mn_ind_cnt;
Nchar bLAKB_KONF_CH_EN;
N//char bRS485ERR;
Nshort LBAT_STRUKT;
Nchar lakb_error_cnt;		//счетчик неправильного показания ннапряжения батареи
Nshort numOfPacks,numOfPacks_;
Nshort numOfCells, numOfTemperCells, baseOfData;
Nshort lakb_stat_comm_error;	//аварийность канала связи с литиевыми батареями. 0 означает исправность платы расширения и наличие связи со всеми литиевыми батареями
Nshort lakbNotErrorNum;		//колличество литиевых батарей с исправной связью
Nshort lakbKanErrorCnt;		//Счетчик аварийности канала связи с платой расширения
Nshort lakbKanErrorStat;		//Состояние аварийности канала связи с платой расширения
N
N//#ifdef UKU_TELECORE2015
N//***********************************************
N//Состояние литиевой батареи  
NLI_BAT_STAT li_bat;
N//#endif
N
N//***********************************************
N//Телеметрия по внутренней шине
Nchar can_slot[12][16];
N
N
N//***********************************************
N//Состояние источников
NBPS_STAT bps[29];
N
N//***********************************************
N//Состояние инверторов
N#ifdef UKU_220_V2
SINV_STAT inv[3];
N#endif
N#ifndef UKU_220_V2
NINV_STAT inv[20];
N#endif
Nchar first_inv_slot=MINIM_INV_ADRESS;
Xchar first_inv_slot=20;
N
N//***********************************************
N//Состояние байпаса
NBYPS_STAT byps;
N
N//***********************************************
N//Состояние нагрузки
Nsigned short load_U;
Nsigned short load_I;
N
N//***********************************************
N//Состояние выхода
Nsigned short bps_U;
Nsigned short out_U;
Nsigned short in_U;
Nsigned short out_I;
Nsigned short vd_U;
Nsigned short bps_I;
Nsigned short sys_T;
N
N
N//***********************************************
N//Индикация
N
Nchar lcd_buffer[LCD_SIZE+100]={"Hello World"};
Xchar lcd_buffer[200+100]={"Hello World"};
Nsigned char parol[3];
Nchar phase;
Nchar lcd_bitmap[1024];
Nchar dig[5];
Nchar dumm_ind[20];
Nstuct_ind a_ind,b_ind[10],c_ind;
Nchar dumm_ind_[20];
Nchar zero_on;
Nchar mnemo_cnt=50;
Nchar simax;
Nshort av_j_si_max;
Nconst char ABCDEF[]={"0123456789ABCDEF"};
Nconst char sm_mont[13][4]={"   ","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"}; //
Nsigned short ptr_ind=0;
N
Nsigned short ind_pointer=0;
N
N//***********************************************
N//Состояние первичной сети
Nsigned short net_U,net_Ustore,net_Ua,net_Ub,net_Uc;
Nchar bFF,bFF_;
Nsigned short net_F,hz_out,hz_out_cnt,net_F3;
Nsigned char unet_drv_cnt;
Nchar net_av;
N
N//***********************************************
N//Состояние внешних датчиков
N//signed short tout[4];
Nchar tout_max_cnt[4],tout_min_cnt[4];
Nenum_tout_stat tout_stat[4];
Nsigned short t_ext[3];
N
Nsigned char sk_cnt_dumm[4],sk_cnt[4],sk_av_cnt[4];
Nenum_sk_stat sk_stat[4]={ssOFF,ssOFF,ssOFF,ssOFF};
Nenum_sk_av_stat sk_av_stat[4]={sasOFF,sasOFF,sasOFF,sasOFF},sk_av_stat_old[4];
Nsigned short t_box,t_box_warm,t_box_vent;
Nchar ND_EXT[3];
N//***********************************************
N//Звуки
Nextern char beep_cnt;
NBOOL bSILENT;
N
N
N
N
N
N
N
N
Nsigned short u_necc,u_necc_,u_necc_up,u_necc_dn;
Nsigned short main_cnt_5Hz;
Nsigned short num_necc;
Nsigned short num_necc_Imax;
Nsigned short num_necc_Imin;
Nsigned short cnt_num_necc;
N//char bSAME_IST_ON;
Nsigned mat_temper;
N
N//***********************************************
N//АПВ
Nunsigned main_apv_cnt,hour_apv_cnt[2],reset_apv_cnt[2];
Nunsigned short apv_cnt_sec[2],apv_cnt[2];
N
N//***********************************************
N//Текстовые константы
Nconst char sm_[]	={"                    "};
Nconst char sm_exit[]={" Выход              "};
Nconst char sm_time[]={" 0%:0^:0& 0</>  /0{ "};
N
N
N
N
N
N//**********************************************
N//Работа с кнопками 
Nchar but;                            
Nunsigned long but_n,but_s;
Nchar but0_cnt;
Nchar but1_cnt;
Nchar but_onL_temp;
N
N//***********************************************
N//Межблоковая связь
Nsigned char cnt_net_drv;
N
N//***********************************************
N//КАН 
Nextern char ptr_can1_tx_wr,ptr_can1_tx_rd;
Nextern char ptr_can2_tx_wr,ptr_can2_tx_rd;
Nextern unsigned short rotor_can[6];
Nextern char RXBUFF[40],TXBUFF[40];
N
N
N
N
N
N//***********************************************
N//Работа с кнопками
Nchar speed,l_but,n_but;
N
N//***********************************************
N//Неразобранное
Nenum {wrkON=0x55,wrkOFF=0xAA}wrk;
Nchar cnt_wrk;
Nsigned short ibat_integr;
Nunsigned short av_beep,av_rele,av_stat;
Nchar default_temp;
Nchar ND_out[3];
N
N//***********************************************
N//Тест
Nenum_tst_state tst_state[15];
N
N//***********************************************
N//АЦП
N//extern short adc_buff[16][16],adc_buff_[16];
Nextern char adc_cnt,adc_cnt1,adc_ch;
N
N//***********************************************
N
Nchar flag=0;
N
N
Nextern signed short bat_ver_cnt;
Nsigned short Isumm;
Nsigned short Isumm_;
N
N#include <LPC17xx.H>                        /* LPC21xx definitions */
L 1 "C:\Keil\ARM\INC\NXP\LPC17xx\LPC17xx.H" 1
N/******************************************************************************
N * @file:    LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File for 
N *           NXP LPC17xx Device Series 
N * @version: V1.09
N * @date:    17. March 2010
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2008 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __LPC17xx_H__
N#define __LPC17xx_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC17xx Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  SPI_IRQn                      = 13,       /*!< SPI Interrupt                                    */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  RIT_IRQn                      = 29,       /*!< Repetitive Interrupt Timer Interrupt             */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /* USB Activity interrupt                             */
N  CANActivity_IRQn              = 34,       /* CAN Activity interrupt                             */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include <core_cm3.h>                       /* Cortex-M3 processor and core peripherals           */
L 1 "C:\Keil\ARM\RV31\INC\core_cm3.h" 1
N/******************************************************************************
N * @file:    core_cm3.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version: V1.20
N * @date:    22. May 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N/**
N *  Lint configuration \n
N *  ----------------------- \n
N *
N *  The following Lint messages will be suppressed and not shown: \n
N *  \n
N *    --- Error 10: --- \n
N *    register uint32_t __regBasePri         __asm("basepri"); \n
N *    Error 10: Expecting ';' \n
N *     \n
N *    --- Error 530: --- \n
N *    return(__regBasePri); \n
N *    Warning 530: Symbol '__regBasePri' (line 264) not initialized \n
N *     \n
N *    --- Error 550: --- \n
N *      __regBasePri = (basePri & 0x1ff); \n
N *    } \n
N *    Warning 550: Symbol '__regBasePri' (line 271) not accessed \n
N *     \n
N *    --- Error 754: --- \n
N *    uint32_t RESERVED0[24]; \n
N *    Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 750: --- \n
N *    #define __CM3_CORE_H__ \n
N *    Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 528: --- \n
N *    static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *    Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 751: --- \n
N *    } InterruptType_Type; \n
N *    Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced \n
N * \n
N * \n
N *    Note:  To re-enable a Message, insert a space before 'lint' * \n
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N#include <stdint.h>                           /* Include standard types */
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S#define     __I     volatile                  /*!< defines 'read only' permissions      */
N#else
N#define     __I     volatile const            /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N
N
N/* System Reset */
N#define NVIC_VECTRESET              0         /*!< Vector Reset Bit             */
N#define NVIC_SYSRESETREQ            2         /*!< System Reset Request         */
N#define NVIC_AIRCR_VECTKEY    (0x5FA << 16)   /*!< AIRCR Key for write access   */
N#define NVIC_AIRCR_ENDIANESS        15        /*!< Endianess                    */
N
N/* Core Debug */
N#define CoreDebug_DEMCR_TRCENA (1 << 24)      /*!< DEMCR TRCENA enable          */
N#define ITM_TCR_ITMENA              1         /*!< ITM enable                   */
N
N
N
N
N/* memory mapping struct for Nested Vectored Interrupt Controller (NVIC) */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Interrupt Set Enable Register            */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Interrupt Active bit Register            */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Interrupt Priority Register, 8Bit wide   */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Software Trigger Interrupt Register      */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N
N
N/* memory mapping struct for System Control Block */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< CPU ID Base Register                                     */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Interrupt Control State Register                         */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Vector Table Offset Register                             */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Application Interrupt / Reset Control Register           */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< System Control Register                                  */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Configuration Control Register                           */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< System Handlers Priority Registers (4-7, 8-11, 12-15)    */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< System Handler Control and State Register                */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Configurable Fault Status Register                       */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Hard Fault Status Register                               */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Debug Fault Status Register                              */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Mem Manage Address Register                              */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Bus Fault Address Register                               */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Auxiliary Fault Status Register                          */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Processor Feature Register                               */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Debug Feature Register                                   */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Auxiliary Feature Register                               */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Memory Model Feature Register                            */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< ISA Feature Register                                     */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N
N/* memory mapping struct for SysTick */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N
N/* memory mapping structur for ITM */
Ntypedef struct
N{
N  __O  union  
X  volatile  union  
N  {
N    __O  uint8_t    u8;                       /*!< ITM Stimulus Port 8-bit               */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< ITM Stimulus Port 16-bit              */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< ITM Stimulus Port 32-bit              */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< ITM Stimulus Port Registers           */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< ITM Trace Enable Register             */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< ITM Trace Privilege Register          */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< ITM Trace Control Register            */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< ITM Integration Write Register        */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< ITM Integration Read Register         */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< ITM Lock Access Register              */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< ITM Lock Status Register              */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< ITM Product ID Registers              */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;
X  volatile const  uint32_t PID5;
N  __I  uint32_t PID6;
X  volatile const  uint32_t PID6;
N  __I  uint32_t PID7;
X  volatile const  uint32_t PID7;
N  __I  uint32_t PID0;
X  volatile const  uint32_t PID0;
N  __I  uint32_t PID1;
X  volatile const  uint32_t PID1;
N  __I  uint32_t PID2;
X  volatile const  uint32_t PID2;
N  __I  uint32_t PID3;
X  volatile const  uint32_t PID3;
N  __I  uint32_t CID0;
X  volatile const  uint32_t CID0;
N  __I  uint32_t CID1;
X  volatile const  uint32_t CID1;
N  __I  uint32_t CID2;
X  volatile const  uint32_t CID2;
N  __I  uint32_t CID3;
X  volatile const  uint32_t CID3;
N} ITM_Type;
N
N
N/* memory mapped struct for Interrupt Type */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Interrupt Control Type Register  */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Auxiliary Control Register       */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N
N/* Memory Protection Unit */
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< MPU Type Register                               */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< MPU Control Register                            */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< MPU Region RNRber Register                      */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< MPU Region Base Address Register                */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< MPU Region Attribute and Size Register          */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< MPU Alias 1 Region Base Address Register        */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< MPU Alias 1 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< MPU Alias 2 Region Base Address Register        */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< MPU Alias 2 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< MPU Alias 3 Region Base Address Register        */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< MPU Alias 3 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N#endif
N
N
N/* Core Debug Register */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Debug Halting Control and Status Register       */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Debug Core Register Selector Register           */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Debug Core Register Data Register               */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Debug Exception and Monitor Control Register    */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address    */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                     */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address              */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address                 */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                    */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address    */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register              */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct             */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct         */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct            */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct             */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct      */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit               */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit               */
N#endif
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler           */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler       */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @param  none
N * @return uint32_t ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  uint32_t Process Stack Pointer
N * @return none
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @param  none
N * @return uint32_t Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  uint32_t Main Stack Pointer
N * @return none
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param  uint16_t value to reverse
N * @return uint32_t reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/*
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param  int16_t value to reverse
N * @return int32_t reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (410644 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * @param  none
S * @return none
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @param  none
S * @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * @param  none
N * @return none
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @param  none
N * @return uint32_t BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  uint32_t BasePriority
N * @return none
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0x1ff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @param  none
N * @return uint32_t PriMask
N *
N * Return the state of the priority mask bit from the priority mask
N * register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  uint32_t PriMask
N * @return none
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @param  none
N * @return uint32_t FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  uint32_t faultMask value
N * @return none
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @param  none
N * @return uint32_t Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  uint32_t Control value
N * @return none
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation()          /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @param  none
S*  @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/*
S * Reverse byte order in signed short value with sign extension to integer
S *
S * @param  int16_t value to reverse
S * @return int32_t reversed value
S *
S * @brief  Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N
N/* ##########################   NVIC functions  #################################### */
N
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  uint32_t priority_grouping is priority grouping field
N * @return none 
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field 
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  
N  reg_value  = SCB->AIRCR;                                                    /* read old register configuration    */
X  reg_value  = ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                     
N  reg_value &= ~((0xFFFFU << 16) | (0x0F << 8));                              /* clear bits to change               */
N  reg_value  = ((reg_value | NVIC_AIRCR_VECTKEY | (PriorityGroupTmp << 8)));  /* Insert write key and priorty group */
X  reg_value  = ((reg_value | (0x5FA << 16) | (PriorityGroupTmp << 8)));   
N  SCB->AIRCR = reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR = reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @param  none
N * @return uint32_t   priority grouping field 
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR >> 8) & 0x07);                                          /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR >> 8) & 0x07);                                           
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn_Type IRQn specifies the interrupt number
N * @return none 
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn_Type IRQn is the positive number of the external interrupt
N * @return none
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn_Type IRQn is the number of the device specifc interrupt
N * @return uint32_t 1 if pending interrupt else 0
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn_Type  IRQn is the Number of the interrupt
N * @return uint32_t   1 if active else 0
N *
N * Read the active register in NVIC and returns 1 if its status is active, 
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @param  priority is the priority for the interrupt
N * @return none
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt. \n
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return uint32_t  priority is the priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  uint32_t PriorityGroup   is the used priority group
N * @param  uint32_t PreemptPriority is the preemptive priority value (starting from 0)
N * @param  uint32_t SubPriority     is the sub priority value (starting from 0)
N * @return uint32_t                    the priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N 
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  uint32_t   Priority       the priority for the interrupt
N * @param  uint32_t   PrioGroup   is the used priority group
N * @param  uint32_t* pPreemptPrio is the preemptive priority value (starting from 0)
N * @param  uint32_t* pSubPrio     is the sub priority value (starting from 0)
N * @return none
N *
N * Decode an interrupt priority value with the given priority group to 
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N  
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/* SysTick constants */
N#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
N#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
N#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
N#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount                                                      */
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param  uint32_t ticks is the number of ticks between two interrupts
N * @return  none
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SYSTICK_MAXCOUNT)  return (1);                                             /* Reload value impossible */
X  if (ticks > ((1<<24) -1))  return (1);                                              
N
N  SysTick->LOAD  =  (ticks & SYSTICK_MAXCOUNT) - 1;                                      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  =  (ticks & ((1<<24) -1)) - 1;                                       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);                            /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);                             
N  SysTick->VAL   =  (0x00);                                                              /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   =  (0x00);                                                               
N  SysTick->CTRL = (1 << SYSTICK_CLKSOURCE) | (1<<SYSTICK_ENABLE) | (1<<SYSTICK_TICKINT); /* Enable SysTick IRQ and SysTick Timer */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = (1 << 2) | (1<<0) | (1<<1);  
N  return (0);                                                                            /* Function successful */
N}
N
N#endif
N
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * @param   none
N * @return  none
N *
N * Initialize a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB->AIRCR & (0x700)) | (1<<NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16) | (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (0x700)) | (1<<2));  
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N
N/* ##################################    Debug Output  function  ############################################ */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param   uint32_t character to output
N * @return  uint32_t input character
N *
N * The function outputs a character via the ITM channel 0. 
N * The function returns when no debugger is connected that has booked the output.  
N * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (ch == '\n') ITM_SendChar('\r');
N  
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA)  &&
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1 << 24))  &&
N      (ITM->TCR & ITM_TCR_ITMENA)                  &&
X      (((ITM_Type *) (0xE0000000))->TCR & 1)                  &&
N      (ITM->TER & (1UL << 0))  ) 
X      (((ITM_Type *) (0xE0000000))->TER & (1UL << 0))  ) 
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }  
N  return (ch);
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CM3_CORE_H__ */
N
N/*lint -restore */
L 97 "C:\Keil\ARM\INC\NXP\LPC17xx\LPC17xx.H" 2
N#include "system_LPC17xx.h"                 /* System Header                                      */
L 1 "C:\Keil\ARM\INC\NXP\LPC17xx\system_LPC17xx.h" 1
N/******************************************************************************
N * @file:    system_LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Device Peripheral Access Layer Header File
N *           for the NXP LPC17xx Device Series 
N * @version: V1.01
N * @date:    22. Jul. 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC17xx_H
N#define __SYSTEM_LPC17xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
Nextern uint32_t SystemFrequency;    /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemFrequency variable.
N */
Nextern void SystemInit (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_LPC17xx_H */
L 98 "C:\Keil\ARM\INC\NXP\LPC17xx\LPC17xx.H" 2
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;               /* Flash Accelerator Module           */
X  volatile uint32_t FLASHCFG;                
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                /* Clocking and Power Control         */
X  volatile uint32_t PLL0CON;                 
N  __IO uint32_t PLL0CFG;
X  volatile uint32_t PLL0CFG;
N  __I  uint32_t PLL0STAT;
X  volatile const  uint32_t PLL0STAT;
N  __O  uint32_t PLL0FEED;
X  volatile  uint32_t PLL0FEED;
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;
X  volatile uint32_t PLL1CON;
N  __IO uint32_t PLL1CFG;
X  volatile uint32_t PLL1CFG;
N  __I  uint32_t PLL1STAT;
X  volatile const  uint32_t PLL1STAT;
N  __O  uint32_t PLL1FEED;
X  volatile  uint32_t PLL1FEED;
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;
X  volatile uint32_t PCON;
N  __IO uint32_t PCONP;
X  volatile uint32_t PCONP;
N       uint32_t RESERVED3[15];
N  __IO uint32_t CCLKCFG;
X  volatile uint32_t CCLKCFG;
N  __IO uint32_t USBCLKCFG;
X  volatile uint32_t USBCLKCFG;
N  __IO uint32_t CLKSRCSEL;
X  volatile uint32_t CLKSRCSEL;
N  __IO uint32_t	CANSLEEPCLR;
X  volatile uint32_t	CANSLEEPCLR;
N  __IO uint32_t	CANWAKEFLAGS;
X  volatile uint32_t	CANWAKEFLAGS;
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                 /* External Interrupts                */
X  volatile uint32_t EXTINT;                  
N       uint32_t RESERVED5;
N  __IO uint32_t EXTMODE;
X  volatile uint32_t EXTMODE;
N  __IO uint32_t EXTPOLAR;
X  volatile uint32_t EXTPOLAR;
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                   /* Reset                              */
X  volatile uint32_t RSID;                    
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                    /* Syscon Miscellaneous Registers     */
X  volatile uint32_t SCS;                     
N  __IO uint32_t IRCTRIM;                /* Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                 
N  __IO uint32_t PCLKSEL0;
X  volatile uint32_t PCLKSEL0;
N  __IO uint32_t PCLKSEL1;
X  volatile uint32_t PCLKSEL1;
N       uint32_t RESERVED8[4];
N  __IO uint32_t USBIntSt;               /* USB Device/OTG Interrupt Register  */
X  volatile uint32_t USBIntSt;                
N  __IO uint32_t DMAREQSEL;
X  volatile uint32_t DMAREQSEL;
N  __IO uint32_t CLKOUTCFG;              /* Clock Output Configuration         */
X  volatile uint32_t CLKOUTCFG;               
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t PINSEL0;
X  volatile uint32_t PINSEL0;
N  __IO uint32_t PINSEL1;
X  volatile uint32_t PINSEL1;
N  __IO uint32_t PINSEL2;
X  volatile uint32_t PINSEL2;
N  __IO uint32_t PINSEL3;
X  volatile uint32_t PINSEL3;
N  __IO uint32_t PINSEL4;
X  volatile uint32_t PINSEL4;
N  __IO uint32_t PINSEL5;
X  volatile uint32_t PINSEL5;
N  __IO uint32_t PINSEL6;
X  volatile uint32_t PINSEL6;
N  __IO uint32_t PINSEL7;
X  volatile uint32_t PINSEL7;
N  __IO uint32_t PINSEL8;
X  volatile uint32_t PINSEL8;
N  __IO uint32_t PINSEL9;
X  volatile uint32_t PINSEL9;
N  __IO uint32_t PINSEL10;
X  volatile uint32_t PINSEL10;
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE0;
X  volatile uint32_t PINMODE0;
N  __IO uint32_t PINMODE1;
X  volatile uint32_t PINMODE1;
N  __IO uint32_t PINMODE2;
X  volatile uint32_t PINMODE2;
N  __IO uint32_t PINMODE3;
X  volatile uint32_t PINMODE3;
N  __IO uint32_t PINMODE4;
X  volatile uint32_t PINMODE4;
N  __IO uint32_t PINMODE5;
X  volatile uint32_t PINMODE5;
N  __IO uint32_t PINMODE6;
X  volatile uint32_t PINMODE6;
N  __IO uint32_t PINMODE7;
X  volatile uint32_t PINMODE7;
N  __IO uint32_t PINMODE8;
X  volatile uint32_t PINMODE8;
N  __IO uint32_t PINMODE9;
X  volatile uint32_t PINMODE9;
N  __IO uint32_t PINMODE_OD0;
X  volatile uint32_t PINMODE_OD0;
N  __IO uint32_t PINMODE_OD1;
X  volatile uint32_t PINMODE_OD1;
N  __IO uint32_t PINMODE_OD2;
X  volatile uint32_t PINMODE_OD2;
N  __IO uint32_t PINMODE_OD3;
X  volatile uint32_t PINMODE_OD3;
N  __IO uint32_t PINMODE_OD4;
X  volatile uint32_t PINMODE_OD4;
N  __IO uint32_t I2CPADCFG;
X  volatile uint32_t I2CPADCFG;
N} LPC_PINCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  union {
N    __IO uint32_t FIODIR;
X    volatile uint32_t FIODIR;
N    struct {
N      __IO uint16_t FIODIRL;
X      volatile uint16_t FIODIRL;
N      __IO uint16_t FIODIRH;
X      volatile uint16_t FIODIRH;
N    };
N    struct {
N      __IO uint8_t  FIODIR0;
X      volatile uint8_t  FIODIR0;
N      __IO uint8_t  FIODIR1;
X      volatile uint8_t  FIODIR1;
N      __IO uint8_t  FIODIR2;
X      volatile uint8_t  FIODIR2;
N      __IO uint8_t  FIODIR3;
X      volatile uint8_t  FIODIR3;
N    };
N  };
N  uint32_t RESERVED0[3];
N  union {
N    __IO uint32_t FIOMASK;
X    volatile uint32_t FIOMASK;
N    struct {
N      __IO uint16_t FIOMASKL;
X      volatile uint16_t FIOMASKL;
N      __IO uint16_t FIOMASKH;
X      volatile uint16_t FIOMASKH;
N    };
N    struct {
N      __IO uint8_t  FIOMASK0;
X      volatile uint8_t  FIOMASK0;
N      __IO uint8_t  FIOMASK1;
X      volatile uint8_t  FIOMASK1;
N      __IO uint8_t  FIOMASK2;
X      volatile uint8_t  FIOMASK2;
N      __IO uint8_t  FIOMASK3;
X      volatile uint8_t  FIOMASK3;
N    };
N  };
N  union {
N    __IO uint32_t FIOPIN;
X    volatile uint32_t FIOPIN;
N    struct {
N      __IO uint16_t FIOPINL;
X      volatile uint16_t FIOPINL;
N      __IO uint16_t FIOPINH;
X      volatile uint16_t FIOPINH;
N    };
N    struct {
N      __IO uint8_t  FIOPIN0;
X      volatile uint8_t  FIOPIN0;
N      __IO uint8_t  FIOPIN1;
X      volatile uint8_t  FIOPIN1;
N      __IO uint8_t  FIOPIN2;
X      volatile uint8_t  FIOPIN2;
N      __IO uint8_t  FIOPIN3;
X      volatile uint8_t  FIOPIN3;
N    };
N  };
N  union {
N    __IO uint32_t FIOSET;
X    volatile uint32_t FIOSET;
N    struct {
N      __IO uint16_t FIOSETL;
X      volatile uint16_t FIOSETL;
N      __IO uint16_t FIOSETH;
X      volatile uint16_t FIOSETH;
N    };
N    struct {
N      __IO uint8_t  FIOSET0;
X      volatile uint8_t  FIOSET0;
N      __IO uint8_t  FIOSET1;
X      volatile uint8_t  FIOSET1;
N      __IO uint8_t  FIOSET2;
X      volatile uint8_t  FIOSET2;
N      __IO uint8_t  FIOSET3;
X      volatile uint8_t  FIOSET3;
N    };
N  };
N  union {
N    __O  uint32_t FIOCLR;
X    volatile  uint32_t FIOCLR;
N    struct {
N      __O  uint16_t FIOCLRL;
X      volatile  uint16_t FIOCLRL;
N      __O  uint16_t FIOCLRH;
X      volatile  uint16_t FIOCLRH;
N    };
N    struct {
N      __O  uint8_t  FIOCLR0;
X      volatile  uint8_t  FIOCLR0;
N      __O  uint8_t  FIOCLR1;
X      volatile  uint8_t  FIOCLR1;
N      __O  uint8_t  FIOCLR2;
X      volatile  uint8_t  FIOCLR2;
N      __O  uint8_t  FIOCLR3;
X      volatile  uint8_t  FIOCLR3;
N    };
N  };
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;
X  volatile uint32_t EMR;
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N  __I  uint32_t CR2;
X  volatile const  uint32_t CR2;
N  __I  uint32_t CR3;
X  volatile const  uint32_t CR3;
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;
X  volatile uint32_t MR4;
N  __IO uint32_t MR5;
X  volatile uint32_t MR5;
N  __IO uint32_t MR6;
X  volatile uint32_t MR6;
N  __IO uint32_t PCR;
X  volatile uint32_t PCR;
N  __IO uint32_t LER;
X  volatile uint32_t LER;
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART0_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART1_TypeDef;
N
N/*------------- Serial Peripheral Interface (SPI) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t SPCR;
X  volatile uint32_t SPCR;
N  __I  uint32_t SPSR;
X  volatile const  uint32_t SPSR;
N  __IO uint32_t SPDR;
X  volatile uint32_t SPDR;
N  __IO uint32_t SPCCR;
X  volatile uint32_t SPCCR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t SPINT;
X  volatile uint32_t SPINT;
N} LPC_SPI_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2CONSET;
X  volatile uint32_t I2CONSET;
N  __I  uint32_t I2STAT;
X  volatile const  uint32_t I2STAT;
N  __IO uint32_t I2DAT;
X  volatile uint32_t I2DAT;
N  __IO uint32_t I2ADR0;
X  volatile uint32_t I2ADR0;
N  __IO uint32_t I2SCLH;
X  volatile uint32_t I2SCLH;
N  __IO uint32_t I2SCLL;
X  volatile uint32_t I2SCLL;
N  __O  uint32_t I2CONCLR;
X  volatile  uint32_t I2CONCLR;
N  __IO uint32_t MMCTRL;
X  volatile uint32_t MMCTRL;
N  __IO uint32_t I2ADR1;
X  volatile uint32_t I2ADR1;
N  __IO uint32_t I2ADR2;
X  volatile uint32_t I2ADR2;
N  __IO uint32_t I2ADR3;
X  volatile uint32_t I2ADR3;
N  __I  uint32_t I2DATA_BUFFER;
X  volatile const  uint32_t I2DATA_BUFFER;
N  __IO uint32_t I2MASK0;
X  volatile uint32_t I2MASK0;
N  __IO uint32_t I2MASK1;
X  volatile uint32_t I2MASK1;
N  __IO uint32_t I2MASK2;
X  volatile uint32_t I2MASK2;
N  __IO uint32_t I2MASK3;
X  volatile uint32_t I2MASK3;
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2SDAO;
X  volatile uint32_t I2SDAO;
N  __IO uint32_t I2SDAI;
X  volatile uint32_t I2SDAI;
N  __O  uint32_t I2STXFIFO;
X  volatile  uint32_t I2STXFIFO;
N  __I  uint32_t I2SRXFIFO;
X  volatile const  uint32_t I2SRXFIFO;
N  __I  uint32_t I2SSTATE;
X  volatile const  uint32_t I2SSTATE;
N  __IO uint32_t I2SDMA1;
X  volatile uint32_t I2SDMA1;
N  __IO uint32_t I2SDMA2;
X  volatile uint32_t I2SDMA2;
N  __IO uint32_t I2SIRQ;
X  volatile uint32_t I2SIRQ;
N  __IO uint32_t I2STXRATE;
X  volatile uint32_t I2STXRATE;
N  __IO uint32_t I2SRXRATE;
X  volatile uint32_t I2SRXRATE;
N  __IO uint32_t I2STXBITRATE;
X  volatile uint32_t I2STXBITRATE;
N  __IO uint32_t I2SRXBITRATE;
X  volatile uint32_t I2SRXBITRATE;
N  __IO uint32_t I2STXMODE;
X  volatile uint32_t I2STXMODE;
N  __IO uint32_t I2SRXMODE;
X  volatile uint32_t I2SRXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t RICOMPVAL;
X  volatile uint32_t RICOMPVAL;
N  __IO uint32_t RIMASK;
X  volatile uint32_t RIMASK;
N  __IO uint8_t  RICTRL;
X  volatile uint8_t  RICTRL;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t RICOUNTER;
X  volatile uint32_t RICOUNTER;
N} LPC_RIT_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  WDMOD;
X  volatile uint8_t  WDMOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t WDTC;
X  volatile uint32_t WDTC;
N  __O  uint8_t  WDFEED;
X  volatile  uint8_t  WDFEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t WDTV;
X  volatile const  uint32_t WDTV;
N  __IO uint32_t WDCLKSEL;
X  volatile uint32_t WDCLKSEL;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t ADCR;
X  volatile uint32_t ADCR;
N  __IO uint32_t ADGDR;
X  volatile uint32_t ADGDR;
N       uint32_t RESERVED0;
N  __IO uint32_t ADINTEN;
X  volatile uint32_t ADINTEN;
N  __I  uint32_t ADDR0;
X  volatile const  uint32_t ADDR0;
N  __I  uint32_t ADDR1;
X  volatile const  uint32_t ADDR1;
N  __I  uint32_t ADDR2;
X  volatile const  uint32_t ADDR2;
N  __I  uint32_t ADDR3;
X  volatile const  uint32_t ADDR3;
N  __I  uint32_t ADDR4;
X  volatile const  uint32_t ADDR4;
N  __I  uint32_t ADDR5;
X  volatile const  uint32_t ADDR5;
N  __I  uint32_t ADDR6;
X  volatile const  uint32_t ADDR6;
N  __I  uint32_t ADDR7;
X  volatile const  uint32_t ADDR7;
N  __I  uint32_t ADSTAT;
X  volatile const  uint32_t ADSTAT;
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DACR;
X  volatile uint32_t DACR;
N  __IO uint32_t DACCTRL;
X  volatile uint32_t DACCTRL;
N  __IO uint16_t DACCNTVAL;
X  volatile uint16_t DACCNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t MCCON;
X  volatile const  uint32_t MCCON;
N  __O  uint32_t MCCON_SET;
X  volatile  uint32_t MCCON_SET;
N  __O  uint32_t MCCON_CLR;
X  volatile  uint32_t MCCON_CLR;
N  __I  uint32_t MCCAPCON;
X  volatile const  uint32_t MCCAPCON;
N  __O  uint32_t MCCAPCON_SET;
X  volatile  uint32_t MCCAPCON_SET;
N  __O  uint32_t MCCAPCON_CLR;
X  volatile  uint32_t MCCAPCON_CLR;
N  __IO uint32_t MCTIM0;
X  volatile uint32_t MCTIM0;
N  __IO uint32_t MCTIM1;
X  volatile uint32_t MCTIM1;
N  __IO uint32_t MCTIM2;
X  volatile uint32_t MCTIM2;
N  __IO uint32_t MCPER0;
X  volatile uint32_t MCPER0;
N  __IO uint32_t MCPER1;
X  volatile uint32_t MCPER1;
N  __IO uint32_t MCPER2;
X  volatile uint32_t MCPER2;
N  __IO uint32_t MCPW0;
X  volatile uint32_t MCPW0;
N  __IO uint32_t MCPW1;
X  volatile uint32_t MCPW1;
N  __IO uint32_t MCPW2;
X  volatile uint32_t MCPW2;
N  __IO uint32_t MCDEADTIME;
X  volatile uint32_t MCDEADTIME;
N  __IO uint32_t MCCCP;
X  volatile uint32_t MCCCP;
N  __IO uint32_t MCCR0;
X  volatile uint32_t MCCR0;
N  __IO uint32_t MCCR1;
X  volatile uint32_t MCCR1;
N  __IO uint32_t MCCR2;
X  volatile uint32_t MCCR2;
N  __I  uint32_t MCINTEN;
X  volatile const  uint32_t MCINTEN;
N  __O  uint32_t MCINTEN_SET;
X  volatile  uint32_t MCINTEN_SET;
N  __O  uint32_t MCINTEN_CLR;
X  volatile  uint32_t MCINTEN_CLR;
N  __I  uint32_t MCCNTCON;
X  volatile const  uint32_t MCCNTCON;
N  __O  uint32_t MCCNTCON_SET;
X  volatile  uint32_t MCCNTCON_SET;
N  __O  uint32_t MCCNTCON_CLR;
X  volatile  uint32_t MCCNTCON_CLR;
N  __I  uint32_t MCINTFLAG;
X  volatile const  uint32_t MCINTFLAG;
N  __O  uint32_t MCINTFLAG_SET;
X  volatile  uint32_t MCINTFLAG_SET;
N  __O  uint32_t MCINTFLAG_CLR;
X  volatile  uint32_t MCINTFLAG_CLR;
N  __O  uint32_t MCCAP_CLR;
X  volatile  uint32_t MCCAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t QEICON;
X  volatile  uint32_t QEICON;
N  __I  uint32_t QEISTAT;
X  volatile const  uint32_t QEISTAT;
N  __IO uint32_t QEICONF;
X  volatile uint32_t QEICONF;
N  __I  uint32_t QEIPOS;
X  volatile const  uint32_t QEIPOS;
N  __IO uint32_t QEIMAXPOS;
X  volatile uint32_t QEIMAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP;
X  volatile uint32_t INXCMP;
N  __IO uint32_t QEILOAD;
X  volatile uint32_t QEILOAD;
N  __I  uint32_t QEITIME;
X  volatile const  uint32_t QEITIME;
N  __I  uint32_t QEIVEL;
X  volatile const  uint32_t QEIVEL;
N  __I  uint32_t QEICAP;
X  volatile const  uint32_t QEICAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N       uint32_t RESERVED0[998];
N  __O  uint32_t QEIIEC;
X  volatile  uint32_t QEIIEC;
N  __O  uint32_t QEIIES;
X  volatile  uint32_t QEIIES;
N  __I  uint32_t QEIINTSTAT;
X  volatile const  uint32_t QEIINTSTAT;
N  __I  uint32_t QEIIE;
X  volatile const  uint32_t QEIIE;
N  __O  uint32_t QEICLR;
X  volatile  uint32_t QEICLR;
N  __O  uint32_t QEISET;
X  volatile  uint32_t QEISET;
N} LPC_QEI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t CANTxSR;
X  volatile const  uint32_t CANTxSR;
N  __I  uint32_t CANRxSR;
X  volatile const  uint32_t CANRxSR;
N  __I  uint32_t CANMSR;
X  volatile const  uint32_t CANMSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t DMACIntStat;
X  volatile const  uint32_t DMACIntStat;
N  __I  uint32_t DMACIntTCStat;
X  volatile const  uint32_t DMACIntTCStat;
N  __O  uint32_t DMACIntTCClear;
X  volatile  uint32_t DMACIntTCClear;
N  __I  uint32_t DMACIntErrStat;
X  volatile const  uint32_t DMACIntErrStat;
N  __O  uint32_t DMACIntErrClr;
X  volatile  uint32_t DMACIntErrClr;
N  __I  uint32_t DMACRawIntTCStat;
X  volatile const  uint32_t DMACRawIntTCStat;
N  __I  uint32_t DMACRawIntErrStat;
X  volatile const  uint32_t DMACRawIntErrStat;
N  __I  uint32_t DMACEnbldChns;
X  volatile const  uint32_t DMACEnbldChns;
N  __IO uint32_t DMACSoftBReq;
X  volatile uint32_t DMACSoftBReq;
N  __IO uint32_t DMACSoftSReq;
X  volatile uint32_t DMACSoftSReq;
N  __IO uint32_t DMACSoftLBReq;
X  volatile uint32_t DMACSoftLBReq;
N  __IO uint32_t DMACSoftLSReq;
X  volatile uint32_t DMACSoftLSReq;
N  __IO uint32_t DMACConfig;
X  volatile uint32_t DMACConfig;
N  __IO uint32_t DMACSync;
X  volatile uint32_t DMACSync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t DMACCSrcAddr;
X  volatile uint32_t DMACCSrcAddr;
N  __IO uint32_t DMACCDestAddr;
X  volatile uint32_t DMACCDestAddr;
N  __IO uint32_t DMACCLLI;
X  volatile uint32_t DMACCLLI;
N  __IO uint32_t DMACCControl;
X  volatile uint32_t DMACCControl;
N  __IO uint32_t DMACCConfig;
X  volatile uint32_t DMACCConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t HcRevision;             /* USB Host Registers                 */
X  volatile const  uint32_t HcRevision;              
N  __IO uint32_t HcControl;
X  volatile uint32_t HcControl;
N  __IO uint32_t HcCommandStatus;
X  volatile uint32_t HcCommandStatus;
N  __IO uint32_t HcInterruptStatus;
X  volatile uint32_t HcInterruptStatus;
N  __IO uint32_t HcInterruptEnable;
X  volatile uint32_t HcInterruptEnable;
N  __IO uint32_t HcInterruptDisable;
X  volatile uint32_t HcInterruptDisable;
N  __IO uint32_t HcHCCA;
X  volatile uint32_t HcHCCA;
N  __I  uint32_t HcPeriodCurrentED;
X  volatile const  uint32_t HcPeriodCurrentED;
N  __IO uint32_t HcControlHeadED;
X  volatile uint32_t HcControlHeadED;
N  __IO uint32_t HcControlCurrentED;
X  volatile uint32_t HcControlCurrentED;
N  __IO uint32_t HcBulkHeadED;
X  volatile uint32_t HcBulkHeadED;
N  __IO uint32_t HcBulkCurrentED;
X  volatile uint32_t HcBulkCurrentED;
N  __I  uint32_t HcDoneHead;
X  volatile const  uint32_t HcDoneHead;
N  __IO uint32_t HcFmInterval;
X  volatile uint32_t HcFmInterval;
N  __I  uint32_t HcFmRemaining;
X  volatile const  uint32_t HcFmRemaining;
N  __I  uint32_t HcFmNumber;
X  volatile const  uint32_t HcFmNumber;
N  __IO uint32_t HcPeriodicStart;
X  volatile uint32_t HcPeriodicStart;
N  __IO uint32_t HcLSTreshold;
X  volatile uint32_t HcLSTreshold;
N  __IO uint32_t HcRhDescriptorA;
X  volatile uint32_t HcRhDescriptorA;
N  __IO uint32_t HcRhDescriptorB;
X  volatile uint32_t HcRhDescriptorB;
N  __IO uint32_t HcRhStatus;
X  volatile uint32_t HcRhStatus;
N  __IO uint32_t HcRhPortStatus1;
X  volatile uint32_t HcRhPortStatus1;
N  __IO uint32_t HcRhPortStatus2;
X  volatile uint32_t HcRhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t OTGIntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t OTGIntSt;                
N  __IO uint32_t OTGIntEn;
X  volatile uint32_t OTGIntEn;
N  __O  uint32_t OTGIntSet;
X  volatile  uint32_t OTGIntSet;
N  __O  uint32_t OTGIntClr;
X  volatile  uint32_t OTGIntClr;
N  __IO uint32_t OTGStCtrl;
X  volatile uint32_t OTGStCtrl;
N  __IO uint32_t OTGTmr;
X  volatile uint32_t OTGTmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t USBDevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t USBDevIntSt;             
N  __IO uint32_t USBDevIntEn;
X  volatile uint32_t USBDevIntEn;
N  __O  uint32_t USBDevIntClr;
X  volatile  uint32_t USBDevIntClr;
N  __O  uint32_t USBDevIntSet;
X  volatile  uint32_t USBDevIntSet;
N
N  __O  uint32_t USBCmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t USBCmdCode;              
N  __I  uint32_t USBCmdData;
X  volatile const  uint32_t USBCmdData;
N
N  __I  uint32_t USBRxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t USBRxData;               
N  __O  uint32_t USBTxData;
X  volatile  uint32_t USBTxData;
N  __I  uint32_t USBRxPLen;
X  volatile const  uint32_t USBRxPLen;
N  __O  uint32_t USBTxPLen;
X  volatile  uint32_t USBTxPLen;
N  __IO uint32_t USBCtrl;
X  volatile uint32_t USBCtrl;
N  __O  uint32_t USBDevIntPri;
X  volatile  uint32_t USBDevIntPri;
N
N  __I  uint32_t USBEpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t USBEpIntSt;              
N  __IO uint32_t USBEpIntEn;
X  volatile uint32_t USBEpIntEn;
N  __O  uint32_t USBEpIntClr;
X  volatile  uint32_t USBEpIntClr;
N  __O  uint32_t USBEpIntSet;
X  volatile  uint32_t USBEpIntSet;
N  __O  uint32_t USBEpIntPri;
X  volatile  uint32_t USBEpIntPri;
N
N  __IO uint32_t USBReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t USBReEp;                 
N  __O  uint32_t USBEpInd;
X  volatile  uint32_t USBEpInd;
N  __IO uint32_t USBMaxPSize;
X  volatile uint32_t USBMaxPSize;
N
N  __I  uint32_t USBDMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t USBDMARSt;               
N  __O  uint32_t USBDMARClr;
X  volatile  uint32_t USBDMARClr;
N  __O  uint32_t USBDMARSet;
X  volatile  uint32_t USBDMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t USBUDCAH;
X  volatile uint32_t USBUDCAH;
N  __I  uint32_t USBEpDMASt;
X  volatile const  uint32_t USBEpDMASt;
N  __O  uint32_t USBEpDMAEn;
X  volatile  uint32_t USBEpDMAEn;
N  __O  uint32_t USBEpDMADis;
X  volatile  uint32_t USBEpDMADis;
N  __I  uint32_t USBDMAIntSt;
X  volatile const  uint32_t USBDMAIntSt;
N  __IO uint32_t USBDMAIntEn;
X  volatile uint32_t USBDMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t USBEoTIntSt;
X  volatile const  uint32_t USBEoTIntSt;
N  __O  uint32_t USBEoTIntClr;
X  volatile  uint32_t USBEoTIntClr;
N  __O  uint32_t USBEoTIntSet;
X  volatile  uint32_t USBEoTIntSet;
N  __I  uint32_t USBNDDRIntSt;
X  volatile const  uint32_t USBNDDRIntSt;
N  __O  uint32_t USBNDDRIntClr;
X  volatile  uint32_t USBNDDRIntClr;
N  __O  uint32_t USBNDDRIntSet;
X  volatile  uint32_t USBNDDRIntSet;
N  __I  uint32_t USBSysErrIntSt;
X  volatile const  uint32_t USBSysErrIntSt;
N  __O  uint32_t USBSysErrIntClr;
X  volatile  uint32_t USBSysErrIntClr;
N  __O  uint32_t USBSysErrIntSet;
X  volatile  uint32_t USBSysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __I  uint32_t I2C_STS;
X  volatile const  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __IO uint32_t RxFilterWoLStatus;
X  volatile uint32_t RxFilterWoLStatus;
N  __IO uint32_t RxFilterWoLClear;
X  volatile uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_GPIO_BASE         (0x2009C000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N
N/* GPIOs                                                                      */
N#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
N#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
N#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
N#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
N#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
N#define LPC_UART0             ((LPC_UART0_TypeDef     *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N
N#endif  // __LPC17xx_H__
L 490 "main.c" 2
N
N
N
N/*
Nextern void lcd_init(void);
Nextern void lcd_on(void);
Nextern void lcd_clear(void);
N*/
N
Nextern short plazma_adc_cnt;
Nextern char net_buff_cnt;
Nextern unsigned short net_buff[32],net_buff_;
Nextern char rele_stat/*,rele_stat_*/;
Nextern char bRXIN0;
N
N
Nchar cntrl_plazma;
Nextern char bOUT_FREE2;
Nextern char /*av_net,*//*av_bat[2],*/av_bps[12],av_inv[6],av_dt[4],av_sk[4];
N
Nchar content[63];
N
N//const short ptr_bat_zar_cnt[2]={EE_ZAR1_CNT,EE_ZAR2_CNT};
N
N
N//unsigned short YEAR_AVZ,MONTH_AVZ,DATE_AVZ,HOUR_AVZ,MIN_AVZ,SEC_AVZ;
N
N
N//**********************************************
N//Самокалиброввка
Nextern signed short samokalibr_cnt;
N
N//**********************************************
N//Сообщения
Nextern char mess[MESS_DEEP],mess_old[MESS_DEEP],mess_cnt[MESS_DEEP];
Xextern char mess[10],mess_old[10],mess_cnt[10];
Nextern short mess_par0[MESS_DEEP],mess_par1[MESS_DEEP],mess_data[2];
Xextern short mess_par0[10],mess_par1[10],mess_data[2];
N
N
N//**********************************************
N//Контроль наличия батарей
Nextern signed short 	main_kb_cnt;
Nextern signed short 	kb_cnt_1lev;
Nextern signed short 	kb_cnt_2lev;
Nextern char 			kb_full_ver;
Nextern char 			kb_start[2],kb_start_ips;
N
N//***********************************************
N//Управление ШИМом
Nextern signed short cntrl_stat;
Nextern signed short cntrl_stat_old;
Nextern signed short cntrl_stat_new;
Nextern signed short Ibmax;
N
N
N//-----------------------------------------------
N//Контроль заряда
Nchar sign_U[2],sign_I[2];
Nchar superviser_cnt;
N
N
Nchar plazma_plazma_plazma;
N
Nchar bRESET=0;
Nchar bRESET_EXT=0;
Nchar ext_can_cnt;
Nchar bRESET_INT_WDT=0;
Nchar bRESET_EXT_WDT=0;
N//-----------------------------------------------
N//Состояние вводов
Nsigned short vvod_pos;
N
N//-----------------------------------------------
N//Плата расширения
Nunsigned short adc_buff_ext_[3];
Nunsigned short Uvv[3];
Nunsigned short Uvv0;
Nshort pos_vent;
Nshort t_ext_can;
Nchar t_ext_can_nd;
N
N
N//-----------------------------------------------
N//Плата расширения 2
Nchar eb2_data[30];
Nshort eb2_data_short[10];
Nshort Uvv_eb2[3],Upes_eb2[3];
Nshort Kvv_eb2[3],Kpes_eb2[3];
N//-----------------------------------------------
N//Работа со щетчиком
Nsigned long power_summary;
Nsigned short power_current;
Nsigned long power_summary_tempo,power_summary_tempo_old;
Nsigned short power_current_tempo,power_current_tempo_old;
Nchar powerSummaryCnt;
Nchar powerCurrentCnt;
N
N//-----------------------------------------------
N//Климатконтроль и вентиляторы
Nsigned short main_vent_pos;
Nsigned char t_box_cnt=0;
Nenum_mixer_vent_stat mixer_vent_stat=mvsOFF;
NINT_BOX_TEMPER ibt;
Nenum_tbatdisable_stat tbatdisable_stat=tbdsON;
Nenum_tloaddisable_stat tloaddisable_stat=tldsON;
Nenum_av_tbox_stat av_tbox_stat=atsOFF;
Nsigned short av_tbox_cnt;
Nchar tbatdisable_cmnd=20,tloaddisable_cmnd=22;
Nshort tbatdisable_cnt,tloaddisable_cnt;
N#ifdef UKU_KONTUR
Sshort t_box_vent_on_cnt;
Sshort t_box_warm_on_cnt;
Senum_vent_stat vent_stat_k=vsON;
Senum_warm_stat warm_stat_k=wsON;
N#endif
N
N#ifdef UKU_TELECORE2015 
Sshort t_box_vent_on_cnt;
Sshort t_box_warm_on_cnt;
Sshort t_box_vvent_on_cnt;
Senum_vent_stat vent_stat_k=vsON,vvent_stat_k=vsON;
Senum_warm_stat warm_stat_k=wsON;
Ssigned short TELECORE2015_KLIMAT_WARM_ON_temp;
N#endif
N
N#ifdef UKU_TELECORE2017 
Sshort t_box_vent_on_cnt;
Sshort t_box_warm_on_cnt;
Sshort t_box_vvent_on_cnt;
Senum_vent_stat vent_stat_k=vsON,vvent_stat_k=vsON;
Senum_warm_stat warm_stat_k=wsON;
Ssigned short TELECORE2017_KLIMAT_WARM_ON_temp;
S
Ssigned char t_box_warm_minus20_cnt;
Ssigned char t_box_warm_plus65_cnt;
Ssigned char t_box_cool_plus70_cnt;
N#endif
N
N//-----------------------------------------------
N//Состояние контролируемых автоматов нагрузки 
Nenum_avt_stat avt_stat[12],avt_stat_old[12];
N
N//short sys_plazma,sys_plazma1;
N
Nchar snmp_plazma;
N
N
Nshort plazma_but_an;
N
Nchar bCAN_OFF;
N
N
Nchar max_net_slot;
N
N//-----------------------------------------------
N//Показания АЦП на плате измерения тока батареи
Nsigned long ibat_metr_buff_[2];
Nshort bIBAT_SMKLBR;
Nchar ibat_metr_cnt=0;
N
N
N//-----------------------------------------------
N//Климатконтроль TELECORE2015	
N#ifdef UKU_TELECORE2015
Ssigned short TELECORE2015_KLIMAT_WARM_SIGNAL;
Ssigned short TELECORE2015_KLIMAT_VENT_SIGNAL;
Ssigned short TELECORE2015_KLIMAT_WARM_ON;
Ssigned short TELECORE2015_KLIMAT_WARM_OFF;
Ssigned short TELECORE2015_KLIMAT_CAP;
Ssigned short TELECORE2015_KLIMAT_VENT_ON;
Ssigned short TELECORE2015_KLIMAT_VENT_OFF;
Ssigned short TELECORE2015_KLIMAT_VVENT_ON;
Ssigned short TELECORE2015_KLIMAT_VVENT_OFF;
N#endif  
N
N//-----------------------------------------------
N//Управление низкоприоритетной нагрузкой
Nsigned short npn_tz_cnt;
Nenum_npn_stat npn_stat=npnsON;
N
N
Nchar ips_bat_av_vzvod=0;
Nchar ips_bat_av_stat=0;
N
Nchar rel_warm_plazma;
Nchar can_byps_plazma0,can_byps_plazma1;
N
Nchar bCAN_INV;
Nchar plazma_can_inv[3];
N
Nunsigned short bat_drv_rx_cnt;
Nchar bat_drv_rx_buff[512];
Nchar bat_drv_rx_in;
N
Nshort plazma_bat_drv0,plazma_bat_drv1,bat_drv_cnt_cnt;
Nshort can_plazma;
N
N//-----------------------------------------------
N//Ускоренный заряд
Nsigned short speedChrgCurr;			//максимальный ток ускоренного заряда, отображение из ЕЕПРОМ
Nsigned short speedChrgVolt;			//максимальное напряжение ускоренного заряда, отображение из ЕЕПРОМ
Nsigned short speedChrgTimeInHour; 		//максимальное время ускоренного заряда в часах, отображение из ЕЕПРОМ
Nsigned short speedChrgAvtEn;	    		//Автоматическое включение Ускоренного заряда включено/выключено
Nsigned short speedChrgDU;	    		//Просадка напряжения необходимая для включения ускоренного заряда
Nsigned short speedChIsOn;			//Текущее состояние ускоренного заряда вкл/выкл
Nsigned long  speedChTimeCnt;			//Счетчик времени прямой ускоренного заряда
Nsigned short speedChrgBlckSrc;		//Источник сигнала блокировки, 0-выкл., 1-СК1, 2-СК2
Nsigned short speedChrgBlckLog;		//Логика сигнала блокировки, 1 - блокировка по замкнутому СК, 0 - по разомкнутому
Nsigned short speedChrgBlckStat;		//Сигнал блокировки для выравнивающего и ускоренного заряда.
Nchar  	   speedChrgShowCnt;		//Счетчик показа информационного сообщения
N
N//-----------------------------------------------
N//Блокировка ИПС
Nsigned short ipsBlckSrc;
Nsigned short ipsBlckLog;
Nsigned short ipsBlckStat;
N
N
N//-----------------------------------------------
N//Контроль выходного напряжения
Nsigned short outVoltContrHndlCnt;		//Счетчик, считает в плюс в случае выполнения условия аварии
Nsigned short outVoltContrHndlCnt_;		//Счетчик, считает в плюс в случае отсутствия выполнения условия аварии
Nchar uout_av;
N
N//-----------------------------------------------
N//Контроль работы вольтдобавки
Nchar bVDISWORK;
Nchar vd_is_work_cnt;
N
Nshort plazma_numOfCells;
Nshort plazma_numOfTemperCells;
Nshort plazma_numOfPacks;
N
N#ifdef MCP2515_CAN
N#define can1_out	mcp2515_transmit
N#endif
N
N
Nchar plazma_ztt[2];
Nchar plazma1809;
N
NU8 socket_tcp;
N
N//-----------------------------------------------
N//Ресурс вентиляторов
N//char vent_resurs_temp[4];
N
N//-----------------------------------------------
N//Выравнивание токов ИПС
Nchar ica_plazma[10];
Nchar ica_timer_cnt;
Nsigned short ica_my_current;
Nsigned short ica_your_current;
Nsigned short ica_u_necc;
NU8 tcp_soc_avg;
NU8 tcp_connect_stat;
N
N//-----------------------------------------------
N//Авария по перегрузке
Nshort overloadHndlCnt;
Nchar overloadAvar;
N
N//-----------------------------------------------
N//Авария по выходному напряжению
Nshort uAvarHndlOutUMaxCnt,uAvarHndlOutUMinCnt;
Nchar uOutAvar;
N
N//-----------------------------------------------
N//Авария по входному напряжению
Nshort uAvarHndlInUMaxCnt,uAvarHndlInUMinCnt;
Nchar uInAvar;
N
N//-----------------------------------------------
N//Авария по температуре системы
Nshort sysTAvarHndlCnt;
Nchar sysTAvar;
N
Nshort pvlk;
Nchar klbr_en;
N
N//***********************************************
N//Состояния аварий для реле
Nshort rele_av_flags;
Nshort avar_vd_stat;
N// Бит 0 - авария одного из БПС
N// Бит 1 - перегрузка системы по току
N// Бит 2 - перегрев системы
N// Бит 3 - выходное напряжение завышено
N// Бит 4 - выходное напряжение занижено
N// Бит 5 - входное напряжение завышено
N// Бит 6 - входное напряжение занижено
N// Бит 7 - авария связи по шине KAN
N// Бит 8 - вольтдобавка в работе
N
N//-----------------------------------------------
Nvoid rtc_init (void) 
N{
NLPC_RTC->CCR=0x11;
X((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->CCR=0x11;
N}
N
N//-----------------------------------------------
Nstatic void timer_poll () 
N{
Nif (SysTick->CTRL & 0x10000) 
Xif (((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL & 0x10000) 
N     {
N     timer_tick ();
N     tick = __TRUE;
X     tick = 1;
N     }
N}
N
N//-----------------------------------------------
Nvoid inv_search(void)
N{
Nchar i;
N
Nfirst_inv_slot=8;
Nfor(i=0;i<12;i++)
N	{
N	if(bps[i]._device==dINV)
N		{
N		first_inv_slot=i;
N		break;
N
N		}
N	}
N}
N
N//-----------------------------------------------
Nsigned short abs_pal(signed short in)
N{
Nif(in<0)return -in;
Nelse return in;
N}
N
N//-----------------------------------------------
Nvoid init_ETH(void)
N{
Nlocalm[NETIF_ETH].IpAdr[0]=lc640_read_int(EE_ETH_IP_1);
Xlocalm[0].IpAdr[0]=lc640_read_int(0x10+500+200+4);
Nlocalm[NETIF_ETH].IpAdr[1]=lc640_read_int(EE_ETH_IP_2);
Xlocalm[0].IpAdr[1]=lc640_read_int(0x10+500+200+6);
Nlocalm[NETIF_ETH].IpAdr[2]=lc640_read_int(EE_ETH_IP_3);
Xlocalm[0].IpAdr[2]=lc640_read_int(0x10+500+200+8);
Nlocalm[NETIF_ETH].IpAdr[3]=lc640_read_int(EE_ETH_IP_4);
Xlocalm[0].IpAdr[3]=lc640_read_int(0x10+500+200+10);
N
Nlocalm[NETIF_ETH].NetMask[0]=lc640_read_int(EE_ETH_MASK_1);
Xlocalm[0].NetMask[0]=lc640_read_int(0x10+500+200+12);
Nlocalm[NETIF_ETH].NetMask[1]=lc640_read_int(EE_ETH_MASK_2);
Xlocalm[0].NetMask[1]=lc640_read_int(0x10+500+200+14);
Nlocalm[NETIF_ETH].NetMask[2]=lc640_read_int(EE_ETH_MASK_3);
Xlocalm[0].NetMask[2]=lc640_read_int(0x10+500+200+16);
Nlocalm[NETIF_ETH].NetMask[3]=lc640_read_int(EE_ETH_MASK_4);
Xlocalm[0].NetMask[3]=lc640_read_int(0x10+500+200+18);
N
Nlocalm[NETIF_ETH].DefGW[0]=lc640_read_int(EE_ETH_GW_1);
Xlocalm[0].DefGW[0]=lc640_read_int(0x10+500+200+64);
Nlocalm[NETIF_ETH].DefGW[1]=lc640_read_int(EE_ETH_GW_2);
Xlocalm[0].DefGW[1]=lc640_read_int(0x10+500+200+66);
Nlocalm[NETIF_ETH].DefGW[2]=lc640_read_int(EE_ETH_GW_3);
Xlocalm[0].DefGW[2]=lc640_read_int(0x10+500+200+68);
Nlocalm[NETIF_ETH].DefGW[3]=lc640_read_int(EE_ETH_GW_4);
Xlocalm[0].DefGW[3]=lc640_read_int(0x10+500+200+70);
N
N}
N
N
N//-----------------------------------------------
Nvoid ADC_IRQHandler(void) {
NLPC_ADC->ADCR &=  ~(7<<24);
X((LPC_ADC_TypeDef *) ((0x40000000UL) + 0x34000) )->ADCR &=  ~(7<<24);
N
N
N
Nadc_self_ch_buff[adc_self_ch_cnt]=(LPC_ADC->ADGDR>>4) & 0xFFF;/* Read Conversion Result             */
Xadc_self_ch_buff[adc_self_ch_cnt]=(((LPC_ADC_TypeDef *) ((0x40000000UL) + 0x34000) )->ADGDR>>4) & 0xFFF; 
Nadc_self_ch_cnt++;
Nif(adc_self_ch_cnt<3)
N	{
N	LPC_ADC->ADCR |=  (1<<24);
X	((LPC_ADC_TypeDef *) ((0x40000000UL) + 0x34000) )->ADCR |=  (1<<24);
N	}
Nelse
N	{
N
N 
N	//SET_REG(LPC_ADC->ADCR,1,24,3);
N	}
N
N/*			adc_buff_[0]=AD_last;
N			if(AD_last<adc_buff_min[adc_ch])adc_buff_min[adc_ch]=AD_last;
N			if(AD_last>adc_buff_max[adc_ch])adc_buff_max[adc_ch]=AD_last;*/
N}
N
N//-----------------------------------------------
Nvoid def_set(int umax__,int ub0__,int ub20__,int usign__,int imax__,int uob__,int numi,int _uvz)
N{
N;
Nlc640_write_int(EE_NUMIST,numi);
Xlc640_write_int(0x10+100+36,numi);
Nlc640_write_int(EE_NUMINV,0);
Xlc640_write_int(0x10+100+38,0);
N//lc640_write_int(EE_NUMDT,0);
N//lc640_write_int(EE_NUMSK,0);
Nlc640_write_int(EE_MAIN_IST,0);
Xlc640_write_int(0x10+100+2,0);
Nlc640_write_int(EE_PAR,1);
Xlc640_write_int(0x10+100+86,1);
Nlc640_write_int(EE_TBAT,60);
Xlc640_write_int(0x10+100+78,60);
Nlc640_write_int(EE_UMAX,umax__);
Xlc640_write_int(0x10+100+4,umax__);
Nlc640_write_int(EE_DU,ub20__/2);
Xlc640_write_int(0x10+100+84,ub20__/2);
N//lc640_write_int(EE_UB0,ub0__);
N//lc640_write_int(EE_UB20,ub20__);
Nlc640_write_int(EE_TSIGN,70);
Xlc640_write_int(0x10+100+82,70);
Nlc640_write_int(EE_TMAX,80);
Xlc640_write_int(0x10+100+10,80);
N//lc640_write_int(EE_C_BAT,180);
Nlc640_write_int(EE_USIGN,usign__);
Xlc640_write_int(0x10+100+14,usign__);
Nlc640_write_int(EE_UMN,187);
Xlc640_write_int(0x10+100+16,187);
Nlc640_write_int(EE_ZV_ON,0);
Xlc640_write_int(0x10+100+18,0);
Nlc640_write_int(EE_IKB,10);
Xlc640_write_int(0x10+100+20,10);
N//lc640_write_int(EE_KVZ,1030);
N//lc640_write_int(EE_UVZ,_uvz);
Nlc640_write_int(EE_IMAX,imax__);
Xlc640_write_int(0x10+100+24,imax__);
Nlc640_write_int(EE_IMIN,(imax__*8)/10);
Xlc640_write_int(0x10+100+26,(imax__*8)/10);
N//lc640_write_int(EE_APV_ON,apvON);
Nlc640_write_int(EE_APV_ON1,apvON);
Xlc640_write_int(0x10+100+44,apvON);
Nlc640_write_int(EE_APV_ON2,apvON);
Xlc640_write_int(0x10+100+46,apvON);
Nlc640_write_int(EE_APV_ON2_TIME,1);
Xlc640_write_int(0x10+100+48,1);
Nlc640_write_int(EE_IZMAX,160);
Xlc640_write_int(0x10+100+30,160);
Nlc640_write_int(EE_U0B,uob__);
Xlc640_write_int(0x10+100+32,uob__);
Nlc640_write_int(EE_TZAS,3);
Xlc640_write_int(0x10+100+34,3);
Nlc640_write_int(EE_TBATMAX,50);  
Xlc640_write_int(0x10+100+88,50);  
Nlc640_write_int(EE_TBATSIGN,40);
Xlc640_write_int(0x10+100+90,40);
Nlc640_write_int(EE_MNEMO_ON,mnON);
Xlc640_write_int(0x10+100+72,mnON);
Nlc640_write_int(EE_MNEMO_TIME,30);	
Xlc640_write_int(0x10+100+74,30);	
Nlc640_write_int(EE_AV_OFF_AVT,1);
Xlc640_write_int(0x10+100+12,1);
N//lc640_write_int(EE_APV_ON1,apvOFF);
N
N
N
Nlc640_write_int(EE_TBOXMAX,70);
Xlc640_write_int(0x10+100+92,70);
Nlc640_write_int(EE_TBOXVENTMAX,60);
Xlc640_write_int(0x10+100+96,60);
Nlc640_write_int(EE_TBOXREG,25);
Xlc640_write_int(0x10+100+94,25);
Nlc640_write_int(EE_TLOADDISABLE,80);
Xlc640_write_int(0x10+100+98,80);
Nlc640_write_int(EE_TLOADENABLE,70);
Xlc640_write_int(0x10+100+100,70);
Nlc640_write_int(EE_TBATDISABLE,91);
Xlc640_write_int(0x10+100+102,91);
Nlc640_write_int(EE_TBATENABLE,80);
Xlc640_write_int(0x10+100+104,80);
N
Nlc640_write_int(ADR_SK_SIGN[0],0);
Nlc640_write_int(ADR_SK_REL_EN[0],0);
Nlc640_write_int(ADR_SK_LCD_EN[0],0xffff);
N
Nlc640_write_int(ADR_SK_SIGN[1],0);
Nlc640_write_int(ADR_SK_REL_EN[1],0);
Nlc640_write_int(ADR_SK_LCD_EN[1],0xffff);
N
Nlc640_write_int(ADR_SK_SIGN[2],0);
Nlc640_write_int(ADR_SK_REL_EN[2],0);
Nlc640_write_int(ADR_SK_LCD_EN[2],0xffff);
N
Nlc640_write_int(ADR_SK_SIGN[3],0);
Nlc640_write_int(ADR_SK_REL_EN[3],0);
Nlc640_write_int(ADR_SK_LCD_EN[3],0xffff);
N
Nlc640_write_int(EE_UBM_AV,10);
Xlc640_write_int(0x10+500+96,10);
N
Nlc640_write_int(EE_POS_VENT,11);
Xlc640_write_int(0x10+500+92,11);
N}
N
N
N//-----------------------------------------------
Nvoid def_ips_set(short voltage)
N{
Nif(voltage==24)
N	{
N	def_set(300,voltage,voltage,22,150,240,7,0);
N	}
Nif(voltage==48)
N	{
N	def_set(600,voltage,voltage,44,100,480,7,0);
N	}
Nif(voltage==60)
N	{
N	def_set(750,voltage,voltage,55,100,600,7,0);
N	}
N
Nif(voltage==220)
N	{
N	def_set(2450,2366,2315,187,100,2200,2,2346);
N
N	lc640_write_int(EE_NUMIST,2);
X	lc640_write_int(0x10+100+36,2);
N	lc640_write_int(EE_NUMINV,0);
X	lc640_write_int(0x10+100+38,0);
N//lc640_write_int(EE_NUMDT,0);
N//lc640_write_int(EE_NUMSK,0);
N	lc640_write_int(EE_MAIN_IST,0);
X	lc640_write_int(0x10+100+2,0);
N	lc640_write_int(EE_PAR,1);
X	lc640_write_int(0x10+100+86,1);
N	lc640_write_int(EE_TBAT,60);
X	lc640_write_int(0x10+100+78,60);
N	lc640_write_int(EE_UMAX,2450);
X	lc640_write_int(0x10+100+4,2450);
N	lc640_write_int(EE_DU,2315/2);
X	lc640_write_int(0x10+100+84,2315/2);
N	//lc640_write_int(EE_UB0,2366);
N	//lc640_write_int(EE_UB20,2315);
N	lc640_write_int(EE_TSIGN,70);
X	lc640_write_int(0x10+100+82,70);
N	lc640_write_int(EE_TMAX,80);
X	lc640_write_int(0x10+100+10,80);
N//lc640_write_int(EE_C_BAT,180);
N	lc640_write_int(EE_USIGN,187);
X	lc640_write_int(0x10+100+14,187);
N	lc640_write_int(EE_UMN,187);
X	lc640_write_int(0x10+100+16,187);
N	lc640_write_int(EE_ZV_ON,0);
X	lc640_write_int(0x10+100+18,0);
N	lc640_write_int(EE_IKB,20);
X	lc640_write_int(0x10+100+20,20);
N//lc640_write_int(EE_KVZ,1030);
N	//lc640_write_int(EE_UVZ,2346);
N	lc640_write_int(EE_IMAX,80);
X	lc640_write_int(0x10+100+24,80);
N	lc640_write_int(EE_IMIN,50);
X	lc640_write_int(0x10+100+26,50);
N//lc640_write_int(EE_APV_ON,apvON);
N	lc640_write_int(EE_APV_ON1,apvON);
X	lc640_write_int(0x10+100+44,apvON);
N	lc640_write_int(EE_APV_ON2,apvON);
X	lc640_write_int(0x10+100+46,apvON);
N	lc640_write_int(EE_APV_ON2_TIME,1);
X	lc640_write_int(0x10+100+48,1);
N	lc640_write_int(EE_IZMAX,160);
X	lc640_write_int(0x10+100+30,160);
N	lc640_write_int(EE_U0B,2200);
X	lc640_write_int(0x10+100+32,2200);
N	lc640_write_int(EE_TZAS,3);
X	lc640_write_int(0x10+100+34,3);
N	lc640_write_int(EE_TBATMAX,50);  
X	lc640_write_int(0x10+100+88,50);  
N	lc640_write_int(EE_TBATSIGN,40);
X	lc640_write_int(0x10+100+90,40);
N	lc640_write_int(EE_MNEMO_ON,mnON);
X	lc640_write_int(0x10+100+72,mnON);
N	lc640_write_int(EE_MNEMO_TIME,30);	
X	lc640_write_int(0x10+100+74,30);	
N	lc640_write_int(EE_AV_OFF_AVT,1);
X	lc640_write_int(0x10+100+12,1);
N//lc640_write_int(EE_APV_ON1,apvOFF);
N
N
N
N	lc640_write_int(EE_TBOXMAX,70);
X	lc640_write_int(0x10+100+92,70);
N	lc640_write_int(EE_TBOXVENTMAX,60);
X	lc640_write_int(0x10+100+96,60);
N	lc640_write_int(EE_TBOXREG,25);
X	lc640_write_int(0x10+100+94,25);
N	lc640_write_int(EE_TLOADDISABLE,80);
X	lc640_write_int(0x10+100+98,80);
N	lc640_write_int(EE_TLOADENABLE,70);
X	lc640_write_int(0x10+100+100,70);
N	lc640_write_int(EE_TBATDISABLE,91);
X	lc640_write_int(0x10+100+102,91);
N	lc640_write_int(EE_TBATENABLE,80);
X	lc640_write_int(0x10+100+104,80);
N
N	lc640_write_int(ADR_SK_SIGN[0],0);
N	lc640_write_int(ADR_SK_REL_EN[0],0);
N	lc640_write_int(ADR_SK_LCD_EN[0],0xffff);
N
N	lc640_write_int(ADR_SK_SIGN[1],0);
N	lc640_write_int(ADR_SK_REL_EN[1],0);
N	lc640_write_int(ADR_SK_LCD_EN[1],0xffff);
N
N	lc640_write_int(ADR_SK_SIGN[2],0);
N	lc640_write_int(ADR_SK_REL_EN[2],0);
N	lc640_write_int(ADR_SK_LCD_EN[2],0xffff);
N
N	lc640_write_int(ADR_SK_SIGN[3],0);
N	lc640_write_int(ADR_SK_REL_EN[3],0);
N	lc640_write_int(ADR_SK_LCD_EN[3],0xffff);
N
N	lc640_write_int(EE_UBM_AV,10);
X	lc640_write_int(0x10+500+96,10);
N
N	lc640_write_int(EE_POS_VENT,11);
X	lc640_write_int(0x10+500+92,11);
N
N
N	lc640_write_int(EE_DU,2315-1870);
X	lc640_write_int(0x10+100+84,2315-1870);
N	lc640_write_int(EE_U_AVT,2200);
X	lc640_write_int(0x10+100+80,2200);
N	lc640_write_int(EE_IZMAX,20);
X	lc640_write_int(0x10+100+30,20);
N	lc640_write_int(EE_AUSW_MAIN,22033);
X	lc640_write_int(0x10+100+224,22033);
N	lc640_write_int(EE_PAR,1);
X	lc640_write_int(0x10+100+86,1);
N	lc640_write_int(EE_MNEMO_ON,mnOFF);
X	lc640_write_int(0x10+100+72,mnOFF);
N	}
N
Nif(voltage==110)
N	{
N	def_set(1350,1270,1225,99,20,1220,2,1290);
N
N	lc640_write_int(EE_NUMIST,2);
X	lc640_write_int(0x10+100+36,2);
N	lc640_write_int(EE_NUMINV,0);
X	lc640_write_int(0x10+100+38,0);
N//lc640_write_int(EE_NUMDT,0);
N//lc640_write_int(EE_NUMSK,0);
N	lc640_write_int(EE_MAIN_IST,0);
X	lc640_write_int(0x10+100+2,0);
N	lc640_write_int(EE_PAR,1);
X	lc640_write_int(0x10+100+86,1);
N	lc640_write_int(EE_TBAT,60);
X	lc640_write_int(0x10+100+78,60);
N	lc640_write_int(EE_UMAX,1350);
X	lc640_write_int(0x10+100+4,1350);
N	lc640_write_int(EE_DU,1350/2);
X	lc640_write_int(0x10+100+84,1350/2);
N	//lc640_write_int(EE_UB0,1270);
N	//lc640_write_int(EE_UB20,1225);
N	lc640_write_int(EE_TSIGN,70);
X	lc640_write_int(0x10+100+82,70);
N	lc640_write_int(EE_TMAX,80);
X	lc640_write_int(0x10+100+10,80);
N//lc640_write_int(EE_C_BAT,180);
N	lc640_write_int(EE_USIGN,99);
X	lc640_write_int(0x10+100+14,99);
N	lc640_write_int(EE_UMN,187);
X	lc640_write_int(0x10+100+16,187);
N	lc640_write_int(EE_ZV_ON,0);
X	lc640_write_int(0x10+100+18,0);
N	lc640_write_int(EE_IKB,20);
X	lc640_write_int(0x10+100+20,20);
N//lc640_write_int(EE_KVZ,1030);
N	//lc640_write_int(EE_UVZ,1290);
N	lc640_write_int(EE_IMAX,80);
X	lc640_write_int(0x10+100+24,80);
N	lc640_write_int(EE_IMIN,50);
X	lc640_write_int(0x10+100+26,50);
N//lc640_write_int(EE_APV_ON,apvON);
N	lc640_write_int(EE_APV_ON1,apvON);
X	lc640_write_int(0x10+100+44,apvON);
N	lc640_write_int(EE_APV_ON2,apvON);
X	lc640_write_int(0x10+100+46,apvON);
N	lc640_write_int(EE_APV_ON2_TIME,1);
X	lc640_write_int(0x10+100+48,1);
N	lc640_write_int(EE_IZMAX,160);
X	lc640_write_int(0x10+100+30,160);
N	lc640_write_int(EE_U0B,1220);
X	lc640_write_int(0x10+100+32,1220);
N	lc640_write_int(EE_TZAS,3);
X	lc640_write_int(0x10+100+34,3);
N	lc640_write_int(EE_TBATMAX,50);  
X	lc640_write_int(0x10+100+88,50);  
N	lc640_write_int(EE_TBATSIGN,40);
X	lc640_write_int(0x10+100+90,40);
N	lc640_write_int(EE_MNEMO_ON,mnON);
X	lc640_write_int(0x10+100+72,mnON);
N	lc640_write_int(EE_MNEMO_TIME,30);	
X	lc640_write_int(0x10+100+74,30);	
N	lc640_write_int(EE_AV_OFF_AVT,1);
X	lc640_write_int(0x10+100+12,1);
N//lc640_write_int(EE_APV_ON1,apvOFF);
N
N
N
N	lc640_write_int(EE_TBOXMAX,70);
X	lc640_write_int(0x10+100+92,70);
N	lc640_write_int(EE_TBOXVENTMAX,60);
X	lc640_write_int(0x10+100+96,60);
N	lc640_write_int(EE_TBOXREG,25);
X	lc640_write_int(0x10+100+94,25);
N	lc640_write_int(EE_TLOADDISABLE,80);
X	lc640_write_int(0x10+100+98,80);
N	lc640_write_int(EE_TLOADENABLE,70);
X	lc640_write_int(0x10+100+100,70);
N	lc640_write_int(EE_TBATDISABLE,91);
X	lc640_write_int(0x10+100+102,91);
N	lc640_write_int(EE_TBATENABLE,80);
X	lc640_write_int(0x10+100+104,80);
N
N	lc640_write_int(ADR_SK_SIGN[0],0);
N	lc640_write_int(ADR_SK_REL_EN[0],0);
N	lc640_write_int(ADR_SK_LCD_EN[0],0xffff);
N
N	lc640_write_int(ADR_SK_SIGN[1],0);
N	lc640_write_int(ADR_SK_REL_EN[1],0);
N	lc640_write_int(ADR_SK_LCD_EN[1],0xffff);
N
N	lc640_write_int(ADR_SK_SIGN[2],0);
N	lc640_write_int(ADR_SK_REL_EN[2],0);
N	lc640_write_int(ADR_SK_LCD_EN[2],0xffff);
N
N	lc640_write_int(ADR_SK_SIGN[3],0);
N	lc640_write_int(ADR_SK_REL_EN[3],0);
N	lc640_write_int(ADR_SK_LCD_EN[3],0xffff);
N
N	lc640_write_int(EE_UBM_AV,10);
X	lc640_write_int(0x10+500+96,10);
N
N	lc640_write_int(EE_POS_VENT,11);
X	lc640_write_int(0x10+500+92,11);
N
N
N	lc640_write_int(EE_DU,1220-600);
X	lc640_write_int(0x10+100+84,1220-600);
N	lc640_write_int(EE_U_AVT,1220);
X	lc640_write_int(0x10+100+80,1220);
N	lc640_write_int(EE_IZMAX,20);
X	lc640_write_int(0x10+100+30,20);
N	lc640_write_int(EE_AUSW_MAIN,22033);
X	lc640_write_int(0x10+100+224,22033);
N	lc640_write_int(EE_PAR,1);
X	lc640_write_int(0x10+100+86,1);
N	lc640_write_int(EE_MNEMO_ON,mnOFF);
X	lc640_write_int(0x10+100+72,mnOFF);
N	}
N
Nlc640_write_int(ADR_EE_BAT_IS_ON[0],bisOFF);
Nlc640_write_int(ADR_EE_BAT_DAY_OF_ON[0],LPC_RTC->DOM);
Xlc640_write_int(ADR_EE_BAT_DAY_OF_ON[0],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM);
Nlc640_write_int(ADR_EE_BAT_MONTH_OF_ON[0],LPC_RTC->MONTH);
Xlc640_write_int(ADR_EE_BAT_MONTH_OF_ON[0],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH);
Nlc640_write_int(ADR_EE_BAT_YEAR_OF_ON[0],LPC_RTC->YEAR);
Xlc640_write_int(ADR_EE_BAT_YEAR_OF_ON[0],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR);
Nlc640_write_int(ADR_EE_BAT_C_NOM[0],0);
Nlc640_write_int(ADR_EE_BAT_RESURS[0],0);
N
Nlc640_write_int(ADR_EE_BAT_IS_ON[1],bisOFF);
Nlc640_write_int(ADR_EE_BAT_DAY_OF_ON[1],LPC_RTC->DOM);
Xlc640_write_int(ADR_EE_BAT_DAY_OF_ON[1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM);
Nlc640_write_int(ADR_EE_BAT_MONTH_OF_ON[1],LPC_RTC->MONTH);
Xlc640_write_int(ADR_EE_BAT_MONTH_OF_ON[1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH);
Nlc640_write_int(ADR_EE_BAT_YEAR_OF_ON[1],LPC_RTC->YEAR);
Xlc640_write_int(ADR_EE_BAT_YEAR_OF_ON[1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR);
Nlc640_write_int(ADR_EE_BAT_C_NOM[1],0);
Nlc640_write_int(ADR_EE_BAT_RESURS[1],0);
N
N
Nlc640_write_int(EE_SPEED_CHRG_VOLT,2400);
Xlc640_write_int(0x10+100+164,2400);
Nlc640_write_int(EE_SPEED_CHRG_CURR,20);
Xlc640_write_int(0x10+100+162,20);
Nlc640_write_int(EE_SPEED_CHRG_TIME,1);
Xlc640_write_int(0x10+100+166,1);
Nlc640_write_int(EE_SPEED_CHRG_AVT_EN,0);
Xlc640_write_int(0x10+100+168,0);
Nlc640_write_int(EE_SPEED_CHRG_BLOCK_SRC,0);
Xlc640_write_int(0x10+100+172,0);
Nlc640_write_int(EE_SPEED_CHRG_BLOCK_LOG,0);
Xlc640_write_int(0x10+100+174,0);
Nlc640_write_int(EE_SPEED_CHRG_D_U,40);
Xlc640_write_int(0x10+100+170,40);
Nlc640_write_int(EE_U_OUT_KONTR_MAX,1310);
Xlc640_write_int(0x10+100+182,1310);
Nlc640_write_int(EE_U_OUT_KONTR_MIN,1100);
Xlc640_write_int(0x10+100+184,1100);
N
N
N}
N
N//-----------------------------------------------
Nvoid can_reset_hndl(void)
N{
Nif((lc640_read_int(EE_CAN_RESET_CNT)<0)||(lc640_read_int(EE_CAN_RESET_CNT)>2))	lc640_write_int(EE_CAN_RESET_CNT,0);
Xif((lc640_read_int(0x06)<0)||(lc640_read_int(0x06)>2))	lc640_write_int(0x06,0);
N
Ncan_reset_cnt++;
N
Nif((can_reset_cnt>=10)&&(!(avar_stat&0x0001))&&(!bRESET))
N	{
N	if(lc640_read_int(EE_CAN_RESET_CNT)<2)
X	if(lc640_read_int(0x06)<2)
N		{
N		lc640_write_int(EE_CAN_RESET_CNT,lc640_read_int(EE_CAN_RESET_CNT)+1);
X		lc640_write_int(0x06,lc640_read_int(0x06)+1);
N		bRESET=1;
N		}
N	}
N
Nif((main_1Hz_cnt>=3600UL)&&(lc640_read_int(EE_CAN_RESET_CNT)!=0))
Xif((main_1Hz_cnt>=3600UL)&&(lc640_read_int(0x06)!=0))
N	{
N	lc640_write_int(EE_CAN_RESET_CNT,0);
X	lc640_write_int(0x06,0);
N	}
N
Nif(((LPC_CAN1->GSR)>>24)==127)bRESET=1;
Xif(((((LPC_CAN_TypeDef *) ((0x40000000UL) + 0x44000) )->GSR)>>24)==127)bRESET=1;
Nif((((LPC_CAN1->GSR)>>16)&0x00ff)==127)bRESET=1;
Xif((((((LPC_CAN_TypeDef *) ((0x40000000UL) + 0x44000) )->GSR)>>16)&0x00ff)==127)bRESET=1;
N
N}
N
N//-----------------------------------------------
Nvoid net_drv(void)
N{ 
N
Nmax_net_slot=24;
N
N
Nif(++cnt_net_drv>max_net_slot) 
N	{
N	cnt_net_drv=-5;
N	} 
N
N
Nif((cnt_net_drv>=0)&&(cnt_net_drv<=max_net_slot)) // с 1 по 12 посылки адресные
N
N
N	{
N	//cnt_net_drv=2; 
N	if(mess_find_unvol(MESS2NET_DRV))
X	if(mess_find_unvol(33))
N		{
N		if(mess_data[0]==PARAM_BPS_NET_OFF)
X		if(mess_data[0]==34)
N			{
N			//mess_data[1]=1;
N			if(sub_ind1==cnt_net_drv)
X			if(a_ind . s_i1==cnt_net_drv)
N				{
N				return;
N				}
N			}
N		}
N	
N	//bps[cnt_net_drv]._vol_u=2400;
N	//bps[cnt_net_drv]._x_=0;
N	//if(cntrl_stat==1000) 		   
N	if(!bCAN_OFF)
N		{
N//		if(cntrl_stat==1000)	can1_out(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,*((char*)(&UOUT)),*((char*)((&UOUT))+1),0xe8,0x03);
N//		else 					can1_out(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,*((char*)(&UOUT)),*((char*)((&UOUT))+1),*((char*)(&bps[cnt_net_drv]._x_)),*((char*)((&bps[cnt_net_drv]._x_))+1));
N
N		if(cntrl_stat==2000) can1_out(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,*((char*)(&UOUT)),*((char*)((&UOUT))+1),(char)(cntrl_stat),(char)((cntrl_stat)>>8)/*,*((char*)(&cntrl_stat)),*((char*)((&cntrl_stat))+1)*/);
X		if(cntrl_stat==2000) mcp2515_transmit(cnt_net_drv,cnt_net_drv,0xED,bps[cnt_net_drv]._flags_tu,*((char*)(&UOUT)),*((char*)((&UOUT))+1),(char)(cntrl_stat),(char)((cntrl_stat)>>8) );
N
N		else can1_out(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,*((char*)(&UOUT)),*((char*)((&UOUT))+1),(char)(cntrl_stat+bps[cnt_net_drv]._x_),(char)((cntrl_stat+bps[cnt_net_drv]._x_)>>8)/*,*((char*)(&cntrl_stat)),*((char*)((&cntrl_stat))+1)*/);
X		else mcp2515_transmit(cnt_net_drv,cnt_net_drv,0xED,bps[cnt_net_drv]._flags_tu,*((char*)(&UOUT)),*((char*)((&UOUT))+1),(char)(cntrl_stat+bps[cnt_net_drv]._x_),(char)((cntrl_stat+bps[cnt_net_drv]._x_)>>8) );
N
N     	}
N	if(cnt_net_drv<=max_net_slot)
N	     {
N	     if(bps[cnt_net_drv]._cnt<CNT_SRC_MAX)
X	     if(bps[cnt_net_drv]._cnt<60)
N   	 		{    
N   	 		bps[cnt_net_drv]._cnt++;
N   	 		if( (bps[cnt_net_drv]._cnt>=CNT_SRC_MAX) && (!net_av) && (!(bps[cnt_net_drv]._av&0x08)) && (cnt_net_drv<NUMIST) ) 
X   	 		if( (bps[cnt_net_drv]._cnt>=60) && (!net_av) && (!(bps[cnt_net_drv]._av&0x08)) && (cnt_net_drv<NUMIST) ) 
N   	 			{
N   	 			avar_bps_hndl(cnt_net_drv,3,1);
N   	 			}
N   	 		}
N		else bps[cnt_net_drv]._cnt=CNT_SRC_MAX;
X		else bps[cnt_net_drv]._cnt=60;
N						
N		if((bps[cnt_net_drv]._cnt>=3)&&(bps[cnt_net_drv]._cnt_old<3))bps[cnt_net_drv]._cnt_more2++;
N		bps[cnt_net_drv]._cnt_old=bps[cnt_net_drv]._cnt;
N	     }
N	}
N
Nelse if(cnt_net_drv==-1)
N	{
N     if(!bCAN_OFF)can1_out(0xff,0xff,MEM_KF,*((char*)(&UMAX)),*((char*)((&UMAX))+1),*((char*)(&DU)),*((char*)((&DU))+1),0);
X     if(!bCAN_OFF)mcp2515_transmit(0xff,0xff,0x62,*((char*)(&UMAX)),*((char*)((&UMAX))+1),*((char*)(&DU)),*((char*)((&DU))+1),0);
N     } 
N     
Nelse if(cnt_net_drv==-2)
N	{
N	//UAVT=4567;
N     if(!bCAN_OFF)can1_out(0xff,0xff,MEM_KF1,*((char*)(&UAVT)),*((char*)((&UAVT))+1),(char)(TMAX),(char)(TSIGN),(char)TZAS);
X     if(!bCAN_OFF)mcp2515_transmit(0xff,0xff,0x26,*((char*)(&UAVT)),*((char*)((&UAVT))+1),(char)(TMAX),(char)(TSIGN),(char)TZAS);
N     byps._cnt++;
N	} 
Nelse if(cnt_net_drv==-3)
N	{                 
N	if(!bCAN_OFF) can1_out(GETTM_IBATMETER,GETTM_IBATMETER,0,0,0,0,0,0);
X	if(!bCAN_OFF) mcp2515_transmit(0x1d,0x1d,0,0,0,0,0,0);
N	ibat_metr_cnt++;
N	}
N	
N	
N//else if(cnt_net_drv==15)
N	//{
N     //if(!bCAN_OFF)can1_out(0xff,0xff,MEM_KF1,*((char*)(&TMAX)),*((char*)((&TMAX))+1),*((char*)(&TSIGN)),*((char*)((&TSIGN))+1),(char)TZAS);
N     //}
N
N
N}
N
N#ifdef MCP2515_CAN
N
N//-----------------------------------------------
Nvoid net_drv_mcp2515(void)
N{ 
N//char temp_;    
N
N
N
Nmax_net_slot=MINIM_INV_ADRESS+20;
Xmax_net_slot=20+20;
N//if(NUMINV) max_net_slot=MINIM_INV_ADRESS+NUMINV;
N//gran_char(&max_net_slot,0,MAX_NET_ADRESS);
N
Nif(++cnt_net_drv>max_net_slot) 
N	{
N	cnt_net_drv=0;
N	//LPC_GPIO2->FIODIR|=(1UL<<7);
N	//LPC_GPIO2->FIOPIN^=(1UL<<7);
N	if(bCAN_INV)bCAN_INV=0;
N	else bCAN_INV=1;
N
N	} 
N
N
N
Nif(cnt_net_drv<=17) // с 1 по 17 посылки адресные
N
N	{ 
N	if(mess_find_unvol(MESS2NET_DRV))
X	if(mess_find_unvol(33))
N		{
N		if(mess_data[0]==PARAM_BPS_NET_OFF)
X		if(mess_data[0]==34)
N			{
N			//mess_data[1]=1;
N			if(sub_ind1==cnt_net_drv)
X			if(a_ind . s_i1==cnt_net_drv)
N				{
N				return;
N				}
N			}
N		}
N	
N	bps[cnt_net_drv]._vol_u=2400;
N			   
N	if(!bCAN_OFF)mcp2515_transmit(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,0x60/**((char*)(&bps[cnt_net_drv]._vol_u))*/,0x09/**((char*)((&bps[cnt_net_drv]._vol_u))+1)*/,*((char*)(&bps[cnt_net_drv]._vol_i)),*((char*)((&bps[cnt_net_drv]._vol_i))+1));
X	if(!bCAN_OFF)mcp2515_transmit(cnt_net_drv,cnt_net_drv,0xED,bps[cnt_net_drv]._flags_tu,0x60 ,0x09 ,*((char*)(&bps[cnt_net_drv]._vol_i)),*((char*)((&bps[cnt_net_drv]._vol_i))+1));
N     
N	if(cnt_net_drv<=17)
N	     {
N	     if(bps[cnt_net_drv]._cnt<CNT_SRC_MAX)
X	     if(bps[cnt_net_drv]._cnt<60)
N   	 		{    
N   	 		bps[cnt_net_drv]._cnt++;
N   	 		if( (bps[cnt_net_drv]._cnt>=CNT_SRC_MAX) && (!net_av) && (!(bps[cnt_net_drv]._av&0x08)) && (cnt_net_drv<NUMIST) ) 
X   	 		if( (bps[cnt_net_drv]._cnt>=60) && (!net_av) && (!(bps[cnt_net_drv]._av&0x08)) && (cnt_net_drv<NUMIST) ) 
N   	 			{
N   	 			avar_bps_hndl(cnt_net_drv,3,1);
N   	 			}
N   	 		}
N		else bps[cnt_net_drv]._cnt=CNT_SRC_MAX;
X		else bps[cnt_net_drv]._cnt=60;
N						
N		if((bps[cnt_net_drv]._cnt>=3)&&(bps[cnt_net_drv]._cnt_old<3))bps[cnt_net_drv]._cnt_more2++;
N		bps[cnt_net_drv]._cnt_old=bps[cnt_net_drv]._cnt;
N	     }
N	}
N
N
N
N/*
Nelse if((cnt_net_drv>=MINIM_INV_ADRESS)&&(cnt_net_drv<(MINIM_INV_ADRESS+NUMINV))&&(NUMINV))
N	{
N    if(!bCAN_OFF) can1_out(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,*((char*)(&bps[cnt_net_drv]._vol_u)),*((char*)((&bps[cnt_net_drv]._vol_u))+1),*((char*)(&bps[cnt_net_drv]._vol_i)),*((char*)((&bps[cnt_net_drv]._vol_i))+1));
N
N	if(bps[cnt_net_drv]._cnt<CNT_SRC_MAX)
N   	 		{    
N   	 		bps[cnt_net_drv]._cnt++;
N   	 		if( (bps[cnt_net_drv]._cnt>=CNT_SRC_MAX) && (!net_av) && (!(bps[cnt_net_drv]._av&0x08)) && (cnt_net_drv<NUMIST) ) 
N   	 			{
N   	 			avar_bps_hndl(cnt_net_drv,3,1);
N   	 			}
N   	 		}
N		else bps[cnt_net_drv]._cnt=CNT_SRC_MAX;
N						
N		if((bps[cnt_net_drv]._cnt>=3)&&(bps[cnt_net_drv]._cnt_old<3))bps[cnt_net_drv]._cnt_more2++;
N		bps[cnt_net_drv]._cnt_old=bps[cnt_net_drv]._cnt;
N	} 
N*/	
N	
N
Nelse if(cnt_net_drv==19)
N	{
N     if(!bCAN_OFF)
N		{
N		mcp2515_transmit(cnt_net_drv,cnt_net_drv,GETTM,BAT_TYPE,NUMBAT,0,0,0);
X		mcp2515_transmit(cnt_net_drv,cnt_net_drv,0xED,BAT_TYPE,NUMBAT,0,0,0);
N		lakb[0]._cnt++;
N		if(lakb[0]._cnt>20)lakb[0]._cnt=20;
N		lakb[1]._cnt++;
N		if(lakb[1]._cnt>20)lakb[1]._cnt=20;
N		}
N     }
N	
N	
N
N}
N#endif
N
N//-----------------------------------------------
Nvoid parol_init(void)
N{
Nparol[0]=0;
Nparol[1]=0;
Nparol[2]=0;
Nsub_ind=0;
Xa_ind . s_i=0;
N}
N
N//-----------------------------------------------
Nvoid bitmap_hndl(void)
N{
Nshort x,ii,i;
Nunsigned int ptr_bitmap;
Nstatic char ptr_cnt,ptr_cnt1,ptr_cnt2,ptr_cnt3,ptr_cnt4;
N
Nfor(ii=0;ii<488;ii++)
N	{
N	lcd_bitmap[ii]=0x00;
N	}
N
N
N	{
N	for(i=0;i<4;i++)
N		{
N		ptr_bitmap=122*(unsigned)i;
N		for(x=(20*i);x<((20*i)+20);x++)
N	 		{
N			lcd_bitmap[ptr_bitmap++]=caracter[(unsigned)lcd_buffer[x]*6];
N			lcd_bitmap[ptr_bitmap++]=caracter[((unsigned)lcd_buffer[x]*6)+1];
N			lcd_bitmap[ptr_bitmap++]=caracter[((unsigned)lcd_buffer[x]*6)+2];
N			lcd_bitmap[ptr_bitmap++]=caracter[((unsigned)lcd_buffer[x]*6)+3];
N			lcd_bitmap[ptr_bitmap++]=caracter[((unsigned)lcd_buffer[x]*6)+4];
N			lcd_bitmap[ptr_bitmap++]=caracter[((unsigned)lcd_buffer[x]*6)+5];
N			} 
N		}
N	}	
W "main.c" 1369 13 variable "ptr_cnt" was declared but never referenced
W "main.c" 1369 21 variable "ptr_cnt1" was declared but never referenced
W "main.c" 1369 30 variable "ptr_cnt2" was declared but never referenced
W "main.c" 1369 39 variable "ptr_cnt3" was declared but never referenced
W "main.c" 1369 48 variable "ptr_cnt4" was declared but never referenced
N}
N
N//-----------------------------------------------
Nvoid ind_hndl(void)
N{			  
N//const char* ptr;
Nconst char* ptrs[60];
Nconst char* sub_ptrs[50];
Nstatic char sub_cnt,sub_cnt1;
Nchar i,sub_cnt_max;
Nchar ii_;				  
Nstatic char ii_cnt,cnt_ind_bat;
N
N
N	   
Nsub_cnt_max=5;
Ni=0;
N/*	      
Nif(spc_stat==spcVZ)
N	{
N	sub_ptrs[i++]=		" Выравн.заряд  X:0x ";
N	sub_cnt_max++;
N	}
Nif(spc_stat==spcKE)
N	{
N	if(spc_bat==0)		sub_ptrs[i++]=		"Контроль емк. бат №1";
N	else if(spc_bat==1)	sub_ptrs[i++]=		"Контроль емк. бат №2";
N	sub_cnt_max++;
N	}*/	
Nif(avar_stat&0x0001)
N	{
N	sub_ptrs[i++]=		"   Авария сети!!!   ";
N	sub_cnt_max++;	
N	}
N
N/*
Nif(avar_stat&0x0002)
N	{
N	sub_ptrs[i++]=	" Авария батареи №1  ";
N	sub_cnt_max++;	
N	}
N
Nif(avar_stat&0x0004)
N	{
N	sub_ptrs[i++]=	" Авария батареи №2  ";
N	sub_cnt_max++;	
N	}*/
N
Nif(ips_bat_av_stat)
N	{
N	sub_ptrs[i++]=	"  Авария батареи    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+0)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №1    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+1)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №2    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+2)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №3    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+3)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №4    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+4)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №5    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+5)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №6    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+6)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №7    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+7)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №8    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+8)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №9    ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+9)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №10   ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+10)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №11   ";
N	sub_cnt_max++;	
N	}
Nif(avar_stat&(1<<(3+11)))
N	{
N	sub_ptrs[i++]=	"   Авария БПС №12   ";
N	sub_cnt_max++;	
N	}
N
Nif(uout_av)
N	{
N	sub_ptrs[i++]=	"   Авария Uвых!!!   ";
N	sub_cnt_max++;	
N	}
N
N
Nif(bps[0]._av&(1<<4))
N	{
N	sub_ptrs[i++]=	"Ресурс вент. БПС1   ";
N	sub_cnt_max++;
N	sub_ptrs[i++]=	"     исчерпан       ";
N	sub_cnt_max++;		
N	}
N
Nif(overloadAvar)
N	{
N	sub_ptrs[i++]=	" Перегрузка по току!";
N	sub_cnt_max++;	
N	}
N
Nif(sysTAvar)
N	{
N	sub_ptrs[i++]=	" Перегрев системы!  ";
N	sub_cnt_max++;	
N	}
N
Nif(uOutAvar==1)
N	{
N	sub_ptrs[i++]=	"   Завышено Uвых.!  ";
N	sub_cnt_max++;	
N	}
N
Nif(uOutAvar==2)
N	{
N	sub_ptrs[i++]=	"   Занижено Uвых.!  ";
N	sub_cnt_max++;	
N	}
N
Nif(uInAvar==1)
N	{
N	sub_ptrs[i++]=	"   Завышено Uвх.!   ";
N	sub_cnt_max++;	
N	}
N
Nif(uInAvar==2)
N	{
N	sub_ptrs[i++]=	"   Занижено Uвх.!   ";
N	sub_cnt_max++;	
N	}
N
Ncnt_of_slave=NUMIST+NUMINV;
N
N
N//cnt_of_wrks=0;
N//for(i=0;i<NUMIST;i++)
N //    {
N//     if(bps[i]._state==bsWRK)cnt_of_wrks++;
N  //   }
N
N
Nsub_cnt1++;	
Nif(sub_cnt1>=20)
N	{
N	sub_cnt1=0;
N	sub_cnt++;
N	if(sub_cnt>=sub_cnt_max)
N		{
N		sub_cnt=0;
N		}
N	}
N
N
N
N
N
N
Nelse if(ind==iMn_VD)
Xelse if(a_ind . i==iMn_VD)
N	{
N	ptrs[0]	=	"                    ";
N
N	ptrs[0]	=	"  В работе    rист. ";
N
N
N	 
N    i=0;
N 	
N	ptrs[1]=			"Uвх.    ]В Uв.д.  @В";	
N	ptrs[2]=			"Uвых.   #В Iвых.  $А";
N    ptrs[3]=			" 0%:0^:0& 0</>  /0{ ";
N	ptrs[4]=			"   Tсистемы    ?°C  ";
N								
N	ptrs[5]=  			" БПС N1             ";
N    ptrs[6]=  			" БПС N2             ";
N    ptrs[7]=  			" БПС N3             ";
N    ptrs[8]=  			" БПС N4             ";
N    ptrs[9]= 			" БПС N5             ";
N    ptrs[10]= 			" БПС N6             ";
N    ptrs[11]= 			" БПС N7             ";
N    ptrs[12]= 			" БПС N8             ";
N    ptrs[13]= 			" БПС N9             ";
N    ptrs[14]= 			" БПС N10            ";
N	ptrs[15]=  			" БПС N11            ";
N    ptrs[16]=  			" БПС N12            ";
N    ptrs[17]=  			" БПС N13            ";
N    ptrs[18]=  			" БПС N14            ";
N    ptrs[19]= 			" БПС N15            ";
N    ptrs[20]= 			" БПС N16            ";
N    ptrs[21]= 			" БПС N17            ";
N    ptrs[22]= 			" БПС N18            ";
N    ptrs[23]= 			" БПС N19            ";
N    ptrs[24]= 			" БПС N20            ";
N 	ptrs[25]=  			" БПС N21            ";
N    ptrs[26]=  			" БПС N22            ";
N    ptrs[27]=  			" БПС N23            ";
N    ptrs[28]=  			" БПС N24            ";
N    ptrs[29]= 			" БПС N25            ";
N    ptrs[30]= 			" БПС N26            ";
N    ptrs[31]= 			" БПС N27            ";
N    ptrs[32]= 			" БПС N28            ";
N    ptrs[33]= 			" БПС N29            ";
N    ptrs[34]= 			" БПС N30            ";
N    ptrs[35]= 			" БПС N31            ";
N    ptrs[36]= 			" БПС N32            ";
N	
N	ptrs[5+NUMIST]=		" Таблица источников ";
N	ptrs[6+NUMIST]= 	" Установки          "; 
N    ptrs[7+NUMIST]= 	" Журнал событий     ";
N	ptrs[8+NUMIST]= 	" Выход              ";
N	ptrs[9+NUMIST]=	" Тест               ";
N	
N
N    if(sub_ind==0)index_set=0;
X    if(a_ind . s_i==0)a_ind . i_s=0;
N	else if((index_set-sub_ind)>2)index_set=sub_ind+2;
X	else if((a_ind . i_s-a_ind . s_i)>2)a_ind . i_s=a_ind . s_i+2;
N	else if(sub_ind>index_set)index_set=sub_ind;
X	else if(a_ind . s_i>a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	
N	if(sub_cnt<5)bgnd_par(ptrs[0],ptrs[index_set+1],ptrs[index_set+2],ptrs[index_set+3]);
X	if(sub_cnt<5)bgnd_par(ptrs[0],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2],ptrs[a_ind . i_s+3]);
N	else bgnd_par(sub_ptrs[sub_cnt-5],ptrs[index_set+1],ptrs[index_set+2],ptrs[index_set+3]);
X	else bgnd_par(sub_ptrs[sub_cnt-5],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2],ptrs[a_ind . i_s+3]);
N	
N	if((ii_cnt<=80)||((spc_stat!=spcVZ)&&(spc_stat!=spcKE))) 
N		{
N	//if((ii_!=139)&&(/*(src_state[0]==ssWRK)||(src_state[1]==ssWRK)||(src_state[2]==ssWRK))*/num_of_wrks_bps!=0))
N//		{
N		
N		if((sub_cnt<5)/*&&(num_of_wrks_bps!=0)*/)int2lcdyx(num_of_wrks_bps,0,14,0);
N
N          //}
N     	}
N
N//	if((AUSW_MAIN==22063)||(AUSW_MAIN==22023)||(AUSW_MAIN==22043))
N		//{
N		//int2lcd(load_U/10,'#',0);
N 		//int2lcd(load_I/10,'$',0);
N	//	}
N	//else 
N		//{
N		//int2lcd(load_U/10,'#',0);
N 		//int2lcd(load_I,'$',1);
N		//}
N
N/*	if(bps_U<1000)	int2lcd(bps_U,']',1);
N	else  			int2lcd(bps_U/10,']',0);
N	if(bps_I<100)	int2lcd(bps_I,'@',1);
N	else  			int2lcd(bps_I/10,'@',0);
N	if(out_U<1000)	int2lcd(out_U,'#',1);
N	else  			int2lcd(out_U/10,'#',0); */
N 	
N	int2lcd(LPC_RTC->HOUR,'%',0);
X	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->HOUR,'%',0);
N	int2lcd(LPC_RTC->MIN,'^',0);
X	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MIN,'^',0);
N	int2lcd(LPC_RTC->SEC,'&',0);
X	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->SEC,'&',0);
N	int2lcd(LPC_RTC->DOM,'<',0);
X	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM,'<',0);
N	int2lcd(LPC_RTC->YEAR,'{',0); 
X	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR,'{',0); 
N	sub_bgnd(sm_mont[LPC_RTC->MONTH],'>',0);
X	sub_bgnd(sm_mont[((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH],'>',0);
N
N 	if(bFL2)
N 	     {
N 	     lcd_buffer[find(':')]=' ';
N 	     lcd_buffer[find(':')]=' ';
N 	     lcd_buffer[find(':')]=' ';
N 	     }
N
N	if((index_set)&&(sub_ind>1))
X	if((a_ind . i_s)&&(a_ind . s_i>1))
N	     {
N	     if(index_set==sub_ind)lcd_buffer[60]=1;
X	     if(a_ind . i_s==a_ind . s_i)lcd_buffer[60]=1;
N	     else if((index_set-sub_ind)==1)lcd_buffer[40]=1;
X	     else if((a_ind . i_s-a_ind . s_i)==1)lcd_buffer[40]=1;
N	     else if((index_set-sub_ind)==2)lcd_buffer[20]=1;
X	     else if((a_ind . i_s-a_ind . s_i)==2)lcd_buffer[20]=1;
N	     }	
N		
N	//cnt_ind_bat++;
N	//if(cnt_ind_bat>=(NUMBAT*20)) cnt_ind_bat=0;
N	   
N	//if((AUSW_MAIN==22063)||(AUSW_MAIN==22023)||(AUSW_MAIN==22043)||(AUSW_MAIN==22011))
N		//{
N		//sub_bgnd("Iб      @А Tб    ?°C",'z',-2);
N		if(bIBAT_SMKLBR)sub_bgnd("КЛБР. ",'$',-3);
N		else /*if(Ib_ips_termokompensat<100)*/int2lcd_mmm(Ib_ips_termokompensat,'$',0);
N		//else int2lcd_mmm(Ib_ips_termokompensat/10,'$',1);
N		int2lcd_mmm(t_ext[0],'?',0);
N		//}
N	//if(NUMBAT==0)sub_bgnd(" Работа без батарей ",'z',-2);
N	//else
N		//{
N		//int2lcd((cnt_ind_bat/20)+1+(!(BAT_IS_ON[0]==bisON)),'z',0);
N		//int2lcd((cnt_ind_bat/20)+1+(!(BAT_IS_ON[0]==bisON)),'z',0);
N		//if((NUMBAT==1)&&(!(BAT_IS_ON[0]==bisON)))
N			//{
N			//int2lcd(bat[1]._Ub/10,']',0);
N			//if((mess_find_unvol(MESS2IND_HNDL))&&(mess_data[0]==PARAM_SAMOKALIBR)) sub_bgnd("КЛБР. ",'@',-4);
N			//else int2lcd_mmm(bat[1]._Ib,'@',2);
N			//}
N		//else
N			//{
N			//int2lcd(bat[cnt_ind_bat/20]._Ub/10,']',0);
N			//if((mess_find_unvol(MESS2IND_HNDL))&&(mess_data[0]==PARAM_SAMOKALIBR)) sub_bgnd("КЛБР. ",'@',-4);
N		///	else int2lcd_mmm(bat[cnt_ind_bat/20]._Ib,'@',2);
N		//	}		}
N
N	int2lcd(out_U/10,'#',0);
N	int2lcd(sys_T,'#',0);
N	int2lcd(vd_U/10,'@',0);
N	int2lcd(in_U/10,']',0);
N	//int2lcd(vz_cnt_s_/60,'x',0);
N	//int2lcd(vz_cnt_h_,'X',0); 
N
N	//int2lcdyx(UOUT,0,3,0);
N
N	//int2lcdyx(UOUT_,0,8,0);
N
N	//int2lcdyx(cnt_net_drv,0,19,0);
N	//int2lcdyx((short)ibat_metr_buff_[0],0,4,0);
N	//int2lcdyx((short)ibat_metr_buff_[1],0,9,0);
N	//int2lcdyx((short)ibat_metr_buff_[2],0,19,0);
N//	int2lcdyx(bat[0]._sign_temper_cnt,0,19,0);
N	//int2lcdyx(uAvarHndlOutUMaxCnt,0,16,0);
N	}
N
N#ifndef _DEBUG_
N
Nelse if(ind==iMakb)
Xelse if(a_ind . i==iMakb)
N	{
N	const char* ptr[12];
N 
N	simax=10;
N
N	ptr[0]=			" Uб1    =     @В    ";
N	ptr[1]=			" Uб2    =     #В    ";
N	ptr[2]=			" Uб3    =     $В    ";
N	ptr[3]=			" Uб4    =     %В    ";
N	ptr[4]=			" Uб5    =     ^В    ";
N	ptr[5]=			" tб1    =     &°С   ";
N	ptr[6]=			" tб2    =     *°С   ";
N	ptr[7]=			" tб3    =     (°С   ";
N	ptr[8]=			" tб4    =     )°С   ";
N	ptr[9]=			" tб5    =     +°С   ";
N	ptr[10]=			sm_exit;
N
N 	if(makb[sub_ind1]._cnt>=5)
X 	if(makb[a_ind . s_i1]._cnt>=5)
N	 	{
N		bgnd_par(		"   МОНИТОР АКБ N<   ",
N					"   НЕ ПОДКЛЮЧЕН!!!  ",
N					"                    ",
N					"                    ");
N		}
N
N
N	else 
N		{
N		bgnd_par(		"   МОНИТОР АКБ N<   ",
N					ptr[index_set],
X					ptr[a_ind . i_s],
N					ptr[index_set+1],
X					ptr[a_ind . i_s+1],
N					ptr[index_set+2]);
X					ptr[a_ind . i_s+2]);
N
N		if(sub_ind-index_set>2)index_set=sub_ind-2;
X		if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N		else if (sub_ind<index_set)index_set=sub_ind;
X		else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N
N		if(sub_ind>=simax)	pointer_set(1);
X		if(a_ind . s_i>=simax)	pointer_set(1);
N		
N		int2lcd(makb[sub_ind1]._Ub[0],'@',1);
X		int2lcd(makb[a_ind . s_i1]._Ub[0],'@',1);
N		int2lcd(makb[sub_ind1]._Ub[1],'#',1);
X		int2lcd(makb[a_ind . s_i1]._Ub[1],'#',1);
N		int2lcd(makb[sub_ind1]._Ub[2],'$',1);
X		int2lcd(makb[a_ind . s_i1]._Ub[2],'$',1);
N		int2lcd(makb[sub_ind1]._Ub[3],'%',1);
X		int2lcd(makb[a_ind . s_i1]._Ub[3],'%',1);
N		int2lcd(makb[sub_ind1]._Ub[4],'^',1);
X		int2lcd(makb[a_ind . s_i1]._Ub[4],'^',1);
N		if(makb[sub_ind1]._T_nd[0])sub_bgnd("НЕПОДКЛЮЧЕН",'&',-5);
X		if(makb[a_ind . s_i1]._T_nd[0])sub_bgnd("НЕПОДКЛЮЧЕН",'&',-5);
N		else int2lcd_mmm(makb[sub_ind1]._T[0],'&',0); 
X		else int2lcd_mmm(makb[a_ind . s_i1]._T[0],'&',0); 
N 		if(makb[sub_ind1]._T_nd[1])sub_bgnd("НЕПОДКЛЮЧЕН",'*',-5);
X 		if(makb[a_ind . s_i1]._T_nd[1])sub_bgnd("НЕПОДКЛЮЧЕН",'*',-5);
N		else int2lcd_mmm(makb[sub_ind1]._T[1],'*',0); 
X		else int2lcd_mmm(makb[a_ind . s_i1]._T[1],'*',0); 
N		if(makb[sub_ind1]._T_nd[2])sub_bgnd("НЕПОДКЛЮЧЕН",'(',-5);
X		if(makb[a_ind . s_i1]._T_nd[2])sub_bgnd("НЕПОДКЛЮЧЕН",'(',-5);
N		else int2lcd_mmm(makb[sub_ind1]._T[2],'(',0); 
X		else int2lcd_mmm(makb[a_ind . s_i1]._T[2],'(',0); 
N		if(makb[sub_ind1]._T_nd[3])sub_bgnd("НЕПОДКЛЮЧЕН",')',-5);
X		if(makb[a_ind . s_i1]._T_nd[3])sub_bgnd("НЕПОДКЛЮЧЕН",')',-5);
N		else int2lcd_mmm(makb[sub_ind1]._T[3],')',0); 
X		else int2lcd_mmm(makb[a_ind . s_i1]._T[3],')',0); 
N		if(makb[sub_ind1]._T_nd[4])sub_bgnd("НЕПОДКЛЮЧЕН",'+',-5);
X		if(makb[a_ind . s_i1]._T_nd[4])sub_bgnd("НЕПОДКЛЮЧЕН",'+',-5);
N		else int2lcd_mmm(makb[sub_ind1]._T[4],'+',0); 
X		else int2lcd_mmm(makb[a_ind . s_i1]._T[4],'+',0); 
N		}
N	int2lcd(sub_ind1+1,'<',0);
X	int2lcd(a_ind . s_i1+1,'<',0);
N    }
N
N else if(ind==iBps)
X else if(a_ind . i==iBps)
N	{
N	const char* ptr[8];
N 
N	simax=5;
N
N	ptr[1]=			" Uист =        (В   ";
N	ptr[2]=			" Iист =        [A   ";
N	ptr[3]=			" tист =        ]°С  ";
N	ptr[4]=			" Сброс аварий       ";
N	ptr[5]=			sm_exit;
N
N	if(bps[sub_ind1]._state==bsWRK)
X	if(bps[a_ind . s_i1]._state==bsWRK)
N		{
N		ptr[0]=		"      в работе      ";
N		if((bps[sub_ind1]._flags_tm&0x08)&&(bFL2))
X		if((bps[a_ind . s_i1]._flags_tm&0x08)&&(bFL2))
N		ptr[0]=		"  СИЛЬНЫЙ НАГРЕВ!!! ";	      
N		}
N 	 else if(bps[sub_ind1]._state==bsRDY)
X 	 else if(bps[a_ind . s_i1]._state==bsRDY)
N	 	{
N		ptr[0]=		"      в резерве     ";	
N		}
N
N 	 else if(bps[sub_ind1]._state==bsBL)
X 	 else if(bps[a_ind . s_i1]._state==bsBL)
N	 	{
N		ptr[0]=		" заблокирован извне ";	
N		}
N
N	 else if(bps[sub_ind1]._state==bsAPV)
X	 else if(bps[a_ind . s_i1]._state==bsAPV)
N	 	{
N		ptr[0]=		"    Работает АПВ    ";
N		}
N	 
N	 else if(bps[sub_ind1]._state==bsAV)
X	 else if(bps[a_ind . s_i1]._state==bsAV)
N	 	{
N		if(bps[sub_ind1]._av&(1<<0))
X		if(bps[a_ind . s_i1]._av&(1<<0))
N		ptr[0]=		" Авария - перегрев! ";
N		else if(bps[sub_ind1]._av&(1<<1))
X		else if(bps[a_ind . s_i1]._av&(1<<1))
N		ptr[0]=		"Авария - завыш.Uвых!";
N		else if(bps[sub_ind1]._av&(1<<2))	 
X		else if(bps[a_ind . s_i1]._av&(1<<2))	 
N		ptr[0]=		"Авария - заниж.Uвых!";
N		else if(bps[sub_ind1]._av&(1<<3))
X		else if(bps[a_ind . s_i1]._av&(1<<3))
N			{
N			ptr[0]=	"  Авария - потеряна ";
N			ptr[1]=	"      связь!!!      ";
N			ptr[2]=	"                    ";
N			simax=0;
N			}
N		}
N
N	 else if(bps[sub_ind1]._state==bsOFF_AV_NET)
X	 else if(bps[a_ind . s_i1]._state==bsOFF_AV_NET)
N	 	{
N		ptr[0]=		"      ВЫКЛЮЧЕН      ";
N		ptr[1]=		"     Отсутствует    ";
N		ptr[2]=		" первичное питание! ";
N		simax=0;
N		}
N
N	bgnd_par(			"       БПС N&       ",
N					ptr[index_set],
X					ptr[a_ind . i_s],
N					ptr[index_set+1],
X					ptr[a_ind . i_s+1],
N					ptr[index_set+2]);
X					ptr[a_ind . i_s+2]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N
N	if(sub_ind>=4)	pointer_set(1);
X	if(a_ind . s_i>=4)	pointer_set(1);
N
N
N		
N
N	int2lcd(sub_ind1+1,'&',0);
X	int2lcd(a_ind . s_i1+1,'&',0);
N	int2lcd(bps[sub_ind1]._Uii,'(',1);
X	int2lcd(bps[a_ind . s_i1]._Uii,'(',1);
N     int2lcd(bps[sub_ind1]._Ii,'[',1);  
X     int2lcd(bps[a_ind . s_i1]._Ii,'[',1);  
N   	int2lcd_mmm(bps[sub_ind1]._Ti,']',0); 
X   	int2lcd_mmm(bps[a_ind . s_i1]._Ti,']',0); 
N   			 
N    // char2lcdhxy(bps[sub_ind1]._state,0x32);
N    
N    //	int2lcdyx(sub_ind,0,2,0);
N//	int2lcdyx(index_set,0,4,0);
N	//int2lcdyx(u_necc,0,4,0);
N	//int2lcdyx(cntrl_stat,0,8,0);	
N     }
N else if(ind==iBps_elteh)
X else if(a_ind . i==iBps_elteh)
N	{
N	const char* ptr[11];
N 
N	simax=9;
N
N	ptr[1]=			" Uист.=        (В   ";
N	ptr[2]=			" Uвых.=        )В   ";
N	ptr[3]=			" Iист.=        [A   ";
N	ptr[4]=			" tист.=        ]°С  ";
N	ptr[5]=			" Наработка          ";
N	ptr[6]=			" вентилятора      >ч";
N	ptr[7]=			" Сброс аварий       ";
N	ptr[8]=			sm_exit;
N 	ptr[9]=			" Сброс наработки    ";
N
N	if(bps[sub_ind1]._state==bsWRK)
X	if(bps[a_ind . s_i1]._state==bsWRK)
N		{
N		ptr[0]=		"      в работе      ";
N		if((bps[sub_ind1]._flags_tm&0x08)&&(bFL2))
X		if((bps[a_ind . s_i1]._flags_tm&0x08)&&(bFL2))
N		ptr[0]=		"  СИЛЬНЫЙ НАГРЕВ!!! ";	      
N		}
N 	 else if(bps[sub_ind1]._state==bsRDY)
X 	 else if(bps[a_ind . s_i1]._state==bsRDY)
N	 	{
N		ptr[0]=		"      в резерве     ";	
N		}
N
N 	 else if(bps[sub_ind1]._state==bsBL)
X 	 else if(bps[a_ind . s_i1]._state==bsBL)
N	 	{
N		ptr[0]=		" заблокирован извне ";	
N		}
N
N	 else if(bps[sub_ind1]._state==bsAPV)
X	 else if(bps[a_ind . s_i1]._state==bsAPV)
N	 	{
N		ptr[0]=		"    Работает АПВ    ";
N		}
N	 
N	 else if(bps[sub_ind1]._state==bsAV)
X	 else if(bps[a_ind . s_i1]._state==bsAV)
N	 	{
N		if(bps[sub_ind1]._av&(1<<0))
X		if(bps[a_ind . s_i1]._av&(1<<0))
N		ptr[0]=		" Авария - перегрев! ";
N		else if(bps[sub_ind1]._av&(1<<1))
X		else if(bps[a_ind . s_i1]._av&(1<<1))
N		ptr[0]=		"Авария - завыш.Uвых!";
N		else if(bps[sub_ind1]._av&(1<<2))	 
X		else if(bps[a_ind . s_i1]._av&(1<<2))	 
N		ptr[0]=		"Авария - заниж.Uвых!";
N		else if(bps[sub_ind1]._av&(1<<3))
X		else if(bps[a_ind . s_i1]._av&(1<<3))
N			{
N			ptr[0]=	"  Авария - потеряна ";
N			ptr[1]=	"      связь!!!      ";
N			ptr[2]=	"                    ";
N			simax=0;
N			}
N		}
N
N	 else if(bps[sub_ind1]._state==bsOFF_AV_NET)
X	 else if(bps[a_ind . s_i1]._state==bsOFF_AV_NET)
N	 	{
N		ptr[0]=		"      ВЫКЛЮЧЕН      ";
N		ptr[1]=		"     Отсутствует    ";
N		ptr[2]=		" первичное питание! ";
N		simax=0;
N		}
N
W "main.c" 1947 16 unrecognized character escape sequence
N	bgnd_par(			" \       БПС N&       ",
N					ptr[index_set],
X					ptr[a_ind . i_s],
N					ptr[index_set+1],
X					ptr[a_ind . i_s+1],
N					ptr[index_set+2]);
X					ptr[a_ind . i_s+2]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N
N	if(sub_ind>=7)	pointer_set(1);
X	if(a_ind . s_i>=7)	pointer_set(1);
N
N
N		
N
N	int2lcd(sub_ind1+1,'&',0);
X	int2lcd(a_ind . s_i1+1,'&',0);
N	int2lcd(bps[sub_ind1]._Uii,'(',1);
X	int2lcd(bps[a_ind . s_i1]._Uii,'(',1);
N	int2lcd(bps[sub_ind1]._Uisum,')',1);
X	int2lcd(bps[a_ind . s_i1]._Uisum,')',1);
N    int2lcd(bps[sub_ind1]._Ii,'[',1);  
X    int2lcd(bps[a_ind . s_i1]._Ii,'[',1);  
N   	int2lcd_mmm(bps[sub_ind1]._Ti,']',0); 
X   	int2lcd_mmm(bps[a_ind . s_i1]._Ti,']',0); 
N	int2lcd(bps[sub_ind1]._vent_resurs,'>',0);
X	int2lcd(bps[a_ind . s_i1]._vent_resurs,'>',0);
N   			 
N    // char2lcdhxy(bps[sub_ind1].Uin,0x04);
N    
N   	//int2lcdyx(sub_ind,0,2,0);
N	//int2lcdyx(bps[sub_ind1]._av,0,4,0);
N	//int2lcdyx(u_necc,0,4,0);
N	//int2lcdyx(avg,0,19,0);
N	
N	//int2lcdyx(bps[sub_ind1]._flags_tu,1,19,0);	
N	//int2lcdyx(bps[sub_ind1]._Uin,1,19,0);
N	//int2lcdyx(bps[sub_ind1].debug_info_to_uku0,2,19,0);
N	//int2lcdyx(bps[sub_ind1].debug_info_to_uku1,3,19,0);
N    }  	   
N	 	  
Nelse if(ind==iNet)
Xelse if(a_ind . i==iNet)
N	{
N	bgnd_par(		"        СЕТЬ        ",
N				" U   =     [В       ",
N				" f   =     ]Гц      ",
N				sm_exit);
N	lcd_buffer[60]=1;
N	     	
N     int2lcd(net_U,'[',0);
N     int2lcd(net_F,']',1);
N
N //temp_SL=(signed long)net_buff_;
N//temp_SL*=Kunet;    
N//int2lcdyx(net_buff_,0,4,0);
N//int2lcdyx(Kunet,0,9,0);
N                  	      	   	    		
N     }
N
Nelse if(ind==iNet3)
Xelse if(a_ind . i==iNet3)
N	{
N
N
N	ptrs[0]=  		" UфA           !В   ";
N    ptrs[1]=  		" UфB           @В   ";
N    ptrs[2]=  	    " UфC           #В   ";
N	ptrs[3]=  	    " f   =     ]Гц      ";           
N	ptrs[4]=  		" Выход              ";
N
N
N	bgnd_par(		"        СЕТЬ        ",
N					ptrs[index_set],
X					ptrs[a_ind . i_s],
N					ptrs[index_set+1],
X					ptrs[a_ind . i_s+1],
N					ptrs[index_set+2]);
X					ptrs[a_ind . i_s+2]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	pointer_set(1);
N
N    int2lcd(net_Ua,'!',0);
N	int2lcd(net_Ub,'@',0);
N	int2lcd(net_Uc,'#',0);
N	#ifdef UKU_220_IPS_TERMOKOMPENSAT
N	int2lcd(net_F3,']',1);
N	#else
S    int2lcd(net_F,']',1);
N    #endif
N
N //temp_SL=(signed long)net_buff_;
N//temp_SL*=Kunet;    
N//int2lcdyx(net_buff_,0,4,0);
N//int2lcdyx(Kunet,0,9,0);
N                  	      	   	    		
N     }
N
Nelse if(ind==iNetEM)
Xelse if(a_ind . i==iNetEM)
N	{
N
N
N	ptrs[0]=  		" U             [В   ";
N    	ptrs[1]=  		" f             ]Гц  ";
N    	ptrs[2]=  	    	" Pтекущ.       #Вт  ";
N	ptrs[3]=  	    	" Pсумм.        $кВтч";           
N	ptrs[4]=  		" Выход              ";
N
N
N	bgnd_par(		"        СЕТЬ        ",
N					ptrs[index_set],
X					ptrs[a_ind . i_s],
N					ptrs[index_set+1],
X					ptrs[a_ind . i_s+1],
N					ptrs[index_set+2]);
X					ptrs[a_ind . i_s+2]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	pointer_set(1);
N
N     int2lcd(net_U,'[',0);
N     int2lcd(net_F,']',1);
N     long2lcd_mmm(power_summary/10,'$',1);
N     int2lcd(power_current,'#',0);
N
N //temp_SL=(signed long)net_buff_;
N//temp_SL*=Kunet;    
N//int2lcdyx(net_buff_,0,4,0);
N
N
N                  	      	   	    		
N     }
N
N
Nelse if(ind==iLoad)
Xelse if(a_ind . i==iLoad)
N	{
N	bgnd_par(		"      НАГРУЗКА      ",
N				" Uнагр =     [В     ",
N				" Iнагр =     ]А     ",
N				sm_exit);
N	lcd_buffer[60]=1;
N	     	
N     int2lcd(load_U,'[',1);
N     int2lcd(load_I,']',1);
N
N     
N                   	      	   	    		
N     }
N
Nelse if(ind==iVent)
Xelse if(a_ind . i==iVent)
N	{
N
N	ptrs[0]=  		" Fвент.текущ.     !%";
N     ptrs[1]=  		" Fвент.max. (  @%) #";
N	ptrs[2]=  	     " Выход              ";
N
N	bgnd_par(			"     ВЕНТИЛЯТОР     ",
N					ptrs[index_set],
X					ptrs[a_ind . i_s],
N					ptrs[index_set+1],
X					ptrs[a_ind . i_s+1],
N					ptrs[index_set+2]);
X					ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);
N
N     int2lcd(main_vent_pos*5,'!',0);
N	int2lcd(pos_vent,'#',0);
N	int2lcd(pos_vent*5+45,'@',0);     
N	}
N
Nelse if(ind==iAvt)
Xelse if(a_ind . i==iAvt)
N	{
N     ptrs[0]=  		"  АВТОМАТЫ НАГРУЗОК ";
N	ptrs[1]=  		" Автомат №1       ! ";
N	ptrs[2]=  		" Автомат №2       @ ";
N	ptrs[3]=  		" Автомат №3       # ";
N	ptrs[4]=  		" Автомат №4       $ ";
N	ptrs[5]=  		" Автомат №5       % ";
N	ptrs[6]=  		" Автомат №6       ^ ";
N	ptrs[7]=  		" Автомат №7       & ";
N	ptrs[8]=  		" Автомат №8       * ";
N	ptrs[9]=  		" Автомат №9       ( ";
N	ptrs[10]=  		" Автомат №10      ) ";
N	ptrs[11]=  		" Автомат №11      + ";
N	ptrs[12]=  		" Автомат №12      = ";
N
N	ptrs[1+NUMAVT]=  	" Выход              ";
N	ptrs[2+NUMAVT]=  	"                    ";
N	ptrs[3+NUMAVT]=  	"                    ";
N
N	bgnd_par(		ptrs[0],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2],
X				ptrs[a_ind . i_s+2],
N				ptrs[index_set+3]);
X				ptrs[a_ind . i_s+3]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	pointer_set(1);
N
N	//int2lcdyx(eb2_data_short[6],0,6,0);
N
N	if(avt_stat[0]==avtON)	sub_bgnd("ВКЛ.",'!',-3);
N	else 				sub_bgnd("ВЫКЛ.",'!',-4);
N	if(avt_stat[1]==avtON)	sub_bgnd("ВКЛ.",'@',-3);
N	else 				sub_bgnd("ВЫКЛ.",'@',-4);
N	if(avt_stat[2]==avtON)	sub_bgnd("ВКЛ.",'#',-3);
N	else 				sub_bgnd("ВЫКЛ.",'#',-4);
N	if(avt_stat[3]==avtON)	sub_bgnd("ВКЛ.",'$',-3);
N	else 				sub_bgnd("ВЫКЛ.",'$',-4);
N	if(avt_stat[4]==avtON)	sub_bgnd("ВКЛ.",'%',-3);
N	else 				sub_bgnd("ВЫКЛ.",'%',-4);
N	if(avt_stat[5]==avtON)	sub_bgnd("ВКЛ.",'^',-3);
N	else 				sub_bgnd("ВЫКЛ.",'^',-4);
N	if(avt_stat[6]==avtON)	sub_bgnd("ВКЛ.",'&',-3);
N	else 				sub_bgnd("ВЫКЛ.",'&',-4);
N	if(avt_stat[7]==avtON)	sub_bgnd("ВКЛ.",'*',-3);
N	else 				sub_bgnd("ВЫКЛ.",'*',-4);
N	if(avt_stat[8]==avtON)	sub_bgnd("ВКЛ.",'(',-3);
N	else 				sub_bgnd("ВЫКЛ.",'(',-4);
N	if(avt_stat[9]==avtON)	sub_bgnd("ВКЛ.",')',-3);
N	else 				sub_bgnd("ВЫКЛ.",')',-4);
N	if(avt_stat[10]==avtON)	sub_bgnd("ВКЛ.",'+',-3);
N	else 				sub_bgnd("ВЫКЛ.",'+',-4); 
N	if(avt_stat[11]==avtON)	sub_bgnd("ВКЛ.",'=',-3);
N	else 				sub_bgnd("ВЫКЛ.",'=',-4);
N     //int2lcd(Uvv[1],'$',0);
N     //int2lcd(Uvv[2],'$',0);
N
N     //long2lcd_mmm(power_summary,'%',2);
N     //int2lcd(power_current,'^',0);
N
N     //int2lcdyx(adc_buff_ext_[0],0,4,0);
N     //int2lcdyx(adc_buff_ext_[1],0,10,0);
N     //int2lcdyx(adc_buff_ext_[2],0,16,0);
N     }
N
Nelse if(ind==iEnerg)
Xelse if(a_ind . i==iEnerg)
N	{
N     ptrs[0]=  		"  ЭЛЕКТРОСНАБЖЕНИЕ  ";
N
N     ptrs[1]=  		" Ввод       #В      ";
N     ptrs[2]=  	     " ПЭС        $В      ";            
N     ptrs[3]=  	     " Pсумм.       %кВт*ч";
N	ptrs[4]=  	     " Pтекущ.      ^Вт   ";
N	ptrs[5]=  	     " Выход              ";
N	ptrs[6]=  	     "                    ";
N	ptrs[7]=  	     "                    ";
N
N	bgnd_par(		ptrs[0],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2],
X				ptrs[a_ind . i_s+2],
N				ptrs[index_set+3]);
X				ptrs[a_ind . i_s+3]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	pointer_set(1);
N
N	int2lcd(Uvv0,'#',0);
N     int2lcd(Uvv[1],'$',0);
N     //int2lcd(Uvv[2],'$',0);
N
N     long2lcd_mmm(power_summary,'%',2);
N     int2lcd(power_current,'^',0);
N
N     //int2lcdyx(adc_buff_ext_[0],0,4,0);
N     //int2lcdyx(adc_buff_ext_[1],0,10,0);
N     //int2lcdyx(adc_buff_ext_[2],0,16,0);
N     }
N
Nelse if(ind==iEnerg3)
Xelse if(a_ind . i==iEnerg3)
N	{
N     ptrs[0]=  		"  ЭЛЕКТРОСНАБЖЕНИЕ  ";
N
N     ptrs[1]=  		" Ввод ф.A    !В     ";
N	ptrs[2]=  		" Ввод ф.B    @В     ";
N	ptrs[3]=  		" Ввод ф.C    #В     ";
N     ptrs[4]=  	     " ПЭС  ф.A    &В     ";
N     ptrs[5]=  	     " ПЭС  ф.B    )В     ";
N     ptrs[6]=  	     " ПЭС  ф.C    (В     ";		            
N     ptrs[7]=  	     " Pсумм.       %кВт*ч";
N	ptrs[8]=  	     " Pтекущ.      ^Вт   ";
N	ptrs[9]=  	     " Выход              ";
N	ptrs[10]=  	     "                    ";
N	ptrs[11]=  	     "                    ";
N
N	bgnd_par(		ptrs[0],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2],
X				ptrs[a_ind . i_s+2],
N				ptrs[index_set+3]);
X				ptrs[a_ind . i_s+3]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	pointer_set(1);
N
N	int2lcd(Uvv_eb2[0],'!',0);
N	int2lcd(Uvv_eb2[1],'@',0);
N	int2lcd(Uvv_eb2[2],'#',0);
N	int2lcd(Upes_eb2[0],'&',0);
N	int2lcd(Upes_eb2[1],')',0);
N	int2lcd(Upes_eb2[2],'(',0);
N     long2lcd_mmm(power_summary,'%',3);
N     int2lcd(power_current,'^',0);
N
N     }
N
Nelse if(ind==iSpc)
Xelse if(a_ind . i==iSpc)
N	{
N
N 	ptrs[0]=	" Выр.заряд          ";
N 	ptrs[1]=	" Авт.выр.заряд      ";
N 	ptrs[2]=	" К.Е. батареи N1    ";
N 	ptrs[3]=	" К.Е. батареи N2    ";
N //	ptrs[4]=	" А.К.Е.  бат. N1    ";
N //	ptrs[5]=	" А.К.Е.  бат. N2    ";
N 	ptrs[4]=	" Выход              ";
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N    	bgnd_par( "     СПЕЦФУНКЦИИ    ",
N    	          ptrs[index_set],
X    	          ptrs[a_ind . i_s],
N    	          ptrs[index_set+1],
X    	          ptrs[a_ind . i_s+1],
N    	          ptrs[index_set+2]);
X    	          ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	}    		
N
Nelse if(ind==iSpc_termocompensat)
Xelse if(a_ind . i==iSpc_termocompensat)
N	{
N 	ptrs[0]=	" Выр.заряд          ";
N 	ptrs[1]=	" Авт.выр.заряд      ";
N 	ptrs[2]=	" К.Е. батареи       ";
N 	ptrs[3]=	" Выход              ";
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N    	bgnd_par( "     СПЕЦФУНКЦИИ    ",
N    	          ptrs[index_set],
X    	          ptrs[a_ind . i_s],
N    	          ptrs[index_set+1],
X    	          ptrs[a_ind . i_s+1],
N    	          ptrs[index_set+2]);
X    	          ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	}    		
N
Nelse if(ind==iLog)
Xelse if(a_ind . i==iLog)
N	{
N	//char dt[4],dt_[4],dt__[4];
N//	char iii;
N
N	av_j_si_max=lc640_read_int(CNT_EVENT_LOG);
X	av_j_si_max=lc640_read_int(1024+1024+512+1024+2);
N	if(av_j_si_max>64)av_j_si_max=0;
N
N	if(av_j_si_max==0)
N		{
N		bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," Журнал пуст        ",sm_exit,sm_);
N		//lcd_buffer[33]=1;
N		sub_ind=1;
X		a_ind . s_i=1;
N		index_set=0;
X		a_ind . i_s=0;
N		}       
N		
N	else if(av_j_si_max==1)
N		{
N		bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  ",sm_exit," Очистить журнал    ");
N		//if(sub_ind==0)lcd_buffer[16]=1;
N		//else if(sub_ind==1)lcd_buffer[33]=1;
N		//else if(sub_ind==2)lcd_buffer[50]=1;		
N		index_set=0;
X		a_ind . i_s=0;
N		}
N
N	else if(av_j_si_max==2)
N		{
N		if(sub_ind<index_set) index_set=sub_ind;
X		if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N		else if((sub_ind-index_set)>2) index_set=sub_ind-2;		
X		else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;		
N		if(index_set==0) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  "," [                  ",sm_exit);
X		if(a_ind . i_s==0) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  "," [                  ",sm_exit);
N		else if(index_set==1) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  ",sm_exit," Очистить журнал    ");
X		else if(a_ind . i_s==1) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  ",sm_exit," Очистить журнал    ");
N		
N		//if((sub_ind-index_set)==0) lcd_buffer[16]=1; 
N		//else if((sub_ind-index_set)==1) lcd_buffer[33]=1;
N		//else if((sub_ind-index_set)==2) lcd_buffer[50]=1;
N		}
N		
N	else if(av_j_si_max>2)
N		{
N		if(sub_ind<index_set) index_set=sub_ind;
X		if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N		else if((sub_ind-index_set)>2) index_set=sub_ind-2;  
X		else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;  
N		if(index_set==(av_j_si_max-1)) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  ",sm_exit," Очистить журнал    ");
X		if(a_ind . i_s==(av_j_si_max-1)) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  ",sm_exit," Очистить журнал    ");
N		else if(index_set==(av_j_si_max-2)) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  "," [                  ",sm_exit);
X		else if(a_ind . i_s==(av_j_si_max-2)) bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  "," [                  ",sm_exit);
N		else bgnd_par("   ЖУРНАЛ СОБЫТИЙ   "," (                  "," [                  "," {                  ");
N		
N		//if((sub_ind-index_set)==0) lcd_buffer[16]=1; 
N		//else if((sub_ind-index_set)==1) lcd_buffer[33]=1;
N		//else if((sub_ind-index_set)==2) lcd_buffer[50]=1;
N
N		}
N	pointer_set(1);
N     event2ind(index_set,'(');
X     event2ind(a_ind . i_s,'(');
N     event2ind(index_set+1,'[');	
X     event2ind(a_ind . i_s+1,'[');	
N     event2ind(index_set+2,'{');	  
X     event2ind(a_ind . i_s+2,'{');	  
N    
N	}
N
N
N
Nelse if(ind==iLog_)
Xelse if(a_ind . i==iLog_)
N	{	
N	unsigned short tempUI/*,tempUI_*/;
N//	unsigned long tempUL;
N	char av_head[4],av_data_on[8],av_data_off[8],av_data[4];
N	short av_head_int[2];
N	
N	bgnd_par(sm_,sm_,sm_,sm_);
N	tempUI=lc640_read_int(PTR_EVENT_LOG);
X	tempUI=lc640_read_int(1024+1024+512+1024);
N	tempUI=ptr_carry(tempUI,64,-1*((signed)sub_ind1));
X	tempUI=ptr_carry(tempUI,64,-1*((signed)a_ind . s_i1));
N	tempUI*=32;
N	tempUI+=EVENT_LOG;
X	tempUI+=1024;
N     
N     lc640_read_long_ptr(tempUI,av_head);
N     lc640_read_long_ptr(tempUI+4,(char*)av_head_int);
N     lc640_read_long_ptr(tempUI+8,av_data_on);
N     lc640_read_long_ptr(tempUI+12,&(av_data_on[4])); 
N     lc640_read_long_ptr(tempUI+16,av_data_off);
N     lc640_read_long_ptr(tempUI+20,&(av_data_off[4]));      
N	lc640_read_long_ptr(tempUI+24,av_data);
N	
N	//av_head_int[0]=123;  
N//av_head_int[1]=456;	
N
N	if((av_head[0]=='U')&&(av_head[2]=='R'))
N		{
N		if(index_set==0) {
X		if(a_ind . i_s==0) {
N		
N		bgnd_par(	"    Перезагрузка    ",
N				"   или включение    ",
N				"       системы      ",
N				"  0%(  0^ 0@:0#:0$  ");
N		} else if(index_set==1) {
X		} else if(a_ind . i_s==1) {
N
N		bgnd_par(	"    Перезагрузка    ",
N				"   или включение    ",
N				"       системы      ",
N				"  код источника  [  ");		
N		
N		} else if(index_set==2) {
X		} else if(a_ind . i_s==2) {
N
N		bgnd_par(	"    Перезагрузка    ",
N				"   или включение    ",
N				"       системы      ",
N				"                 ]  ");		
N		
N		}					
N				  	
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		int2lcd(av_data_on[7],'[',0);
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		//int2lcd(av_data_on[1],'(',0);
N		//int2lcdyx(av_data_on[1],2,1,0);
N		if(av_data_on[7]&0x08)sub_bgnd("superwiser  ",']',-12);
N		else if(av_data_on[7]&0x04)sub_bgnd("watchdog      ",']',-12);
N		else if(av_data_on[7]&0x02)sub_bgnd("ext.reset    ",']',-12);
N		else if(av_data_on[7]&0x01)sub_bgnd("power on     ",']',-12);
N		av_j_si_max=2;
N
N		
N		}
N
N	else if((av_head[0]=='P')&&(av_head[2]=='A'))
N		{  
N		ptrs[0]="   Авария сети!!!   ";
N		ptrs[1]="  0%(  0^ 0@:0#:0$  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[2]="    не устранена    ";
N			ptrs[3]="     Uсети=  +В     ";
N			bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N			int2lcd(net_U,'+',0);
N			}
N		else 
N			{
N			gran_char(&index_set,0,1);
X			gran_char(&a_ind . i_s,0,1);
N			ptrs[2]="      устранена     ";
N			ptrs[3]="  0[]  0< 0>:0=:0)  ";
N			ptrs[4]="     Uмин=  +В      ";
N			bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X			bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N			int2lcd(av_data_off[4],'>',0);
N			int2lcd(av_data_off[5],'=',0);
N			int2lcd(av_data_off[6],')',0);
N			int2lcd(av_data_off[2],'[',0);
N			int2lcd(av_data_off[0],'<',0); 
N			if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N			sub_bgnd(sm_mont[av_data_off[1]],']',0);
N			
N			int2lcd(av_data[0]+(av_data[1]*256),'+',0);			
N			}	
N		
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		
N		av_j_si_max=1;
N		}
N
N	else if((av_head[0]=='B')&&(av_head[2]=='C'))
N		{  
N		ptrs[0]="       Авария       ";
N		ptrs[1]="     батареи N+     ";
N		ptrs[2]="  0%(  0^ 0@:0#:0$  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[3]="    не устранена    ";
N			bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N			}
N		else 
N			{
N			gran_char(&index_set,0,1);
X			gran_char(&a_ind . i_s,0,1);
N			ptrs[3]="      устранена     ";
N			ptrs[4]="  0[]  0< 0>:0=:0)  ";
N			bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X			bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N			int2lcd(av_data_off[4],'>',0);
N			int2lcd(av_data_off[5],'=',0);
N			int2lcd(av_data_off[6],')',0);
N			int2lcd(av_data_off[2],'[',0);
N			int2lcd(av_data_off[0],'<',0); 
N			if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N			sub_bgnd(sm_mont[av_data_off[1]],']',0);
N			
N						
N			}	
N		int2lcd(av_head[1]+1,'+',0);
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		
N		av_j_si_max=1;
N		}
N
N	else if((av_head[0]=='B')&&(av_head[2]=='S'))
N		{  
N		ptrs[0]="       Авария       ";
N		ptrs[1]="    несимметрии     ";
N		ptrs[2]="     батареи N+     ";
N		ptrs[3]="  0%(  0^ 0@:0#:0$  ";
N		bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N		int2lcd(av_head[1]+1,'+',0);
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		
N		av_j_si_max=0;
N		}
N
N	else if((av_head[0]=='B')&&(av_head[2]=='Z'))
N		{  
N		ptrs[0]="   Выравнивающий    ";
N		ptrs[1]="       заряд        ";
N		ptrs[2]="  0%(  0^ 0@:0#:0$  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[3]="    не завершен     ";
N			bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N			}
N		else 
N			{
N			gran_char(&index_set,0,1);
X			gran_char(&a_ind . i_s,0,1);
N			ptrs[3]="      завершен      ";
N			ptrs[4]="  0[]  0< 0>:0=:0)  ";
N			bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X			bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N			int2lcd(av_data_off[4],'>',0);
N			int2lcd(av_data_off[5],'=',0);
N			int2lcd(av_data_off[6],')',0);
N			int2lcd(av_data_off[2],'[',0);
N			int2lcd(av_data_off[0],'<',0); 
N			if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N			sub_bgnd(sm_mont[av_data_off[1]],']',0);
N			
N						
N			}	
N		int2lcd(av_head[1]+1,'+',0);
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		
N		av_j_si_max=1;
N		}
N
N
N
N	else if((av_head[0]=='B')&&(av_head[2]=='W'))
N		{  
N		ptrs[0]="       Разряд       ";
N		ptrs[1]="     батареи N!     ";
N		ptrs[2]="   Начало           ";
N		ptrs[3]="  0%(  0^ 0@:0#:0$  ";
N		ptrs[4]="       Uбат=  <В";
N		ptrs[5]="   Конец            ";
N		ptrs[6]="  0qw  0r 0i:0l:0s  ";
N		ptrs[7]="         Uбат=  >В  ";
N		ptrs[8]="   Отдано    /а*ч.  ";
N		
N		bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X		bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N		
N		int2lcd(av_head[1]+1,'!',0);
N
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N				
N		int2lcd(av_data_off[4],'i',0);
N		int2lcd(av_data_off[5],'l',0);
N		int2lcd(av_data_off[6],'s',0);
N		int2lcd(av_data_off[2],'q',0);
N		int2lcd(av_data_off[0],'r',0); 
N		if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N		sub_bgnd(sm_mont[av_data_off[1]],'w',0);
N		
N		
N		int2lcd(av_head_int[0]/10,'/',1);
N		int2lcd(av_data_on[3]+(av_data_on[7]*256),'<',1);
N		int2lcd(av_head_int[1],'>',1);	
N		av_j_si_max=5;				
N
N		
N		}
N
N	else if((av_head[0]=='B')&&(av_head[2]=='K'))
N		{  
N		ptrs[0]="  Контроль емкости  ";
N		ptrs[1]="       батареи      ";
N		ptrs[2]="   Начало           ";
N		ptrs[3]="  0%(  0^ 0@:0#:0$  ";
N		ptrs[4]="         Uбат=  <В  ";
N		ptrs[5]="   Конец            ";
N		ptrs[6]="  0qw  0r 0i:0l:0s  ";
N		ptrs[7]="         Uбат=  >В  ";
N		ptrs[8]="   Ёмкость   /а*ч.  ";
N		
N		bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X		bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N		
N		int2lcd(av_head[1]+1,'!',0);
N
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N				
N		int2lcd(av_data_off[4],'i',0);
N		int2lcd(av_data_off[5],'l',0);
N		int2lcd(av_data_off[6],'s',0);
N		int2lcd(av_data_off[2],'q',0);
N		int2lcd(av_data_off[0],'r',0); 
N		if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N		sub_bgnd(sm_mont[av_data_off[1]],'w',0);
N		
N		
N		int2lcd(av_head_int[0],'/',1);
N		int2lcd(av_data_on[3]+(av_data_on[7]*256),'<',1);
N		int2lcd(av_head_int[1],'>',1);	
N		av_j_si_max=5;				
N
N		
N		}
N
N
N
N	else if((av_head[0]=='S')||(av_head[0]=='I'))
N		{  
N		ptrs[0]="   Авария БПС N+    ";
N		
N		if(av_head[2]=='L')
N			{
N			ptrs[1]="     отключился     ";
N			}
N		else if(av_head[2]=='T')
N			{
N			ptrs[1]="      перегрев      ";
N			}		
N		else if(av_head[2]=='U')
N			{
N			ptrs[1]="   завышено Uвых.   ";
N			}		
N		else if(av_head[2]=='u')
N			{
N			ptrs[1]="   занижено Uвых.   ";
N			}								
N		else if(av_head[2]=='O')
N			{
N			ptrs[1]="    завышено Iвых   ";
N			}		
N		
N		ptrs[2]="  0%(  0^ 0@:0#:0$  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[3]="    не устранена    ";
N			bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N			}
N		else 
N			{
N			gran_char(&index_set,0,1);
X			gran_char(&a_ind . i_s,0,1);
N			ptrs[3]="      устранена     ";
N			ptrs[4]="  0[]  0< 0>:0=:0)  ";
N			bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X			bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N			int2lcd(av_data_off[4],'>',0);
N			int2lcd(av_data_off[5],'=',0);
N			int2lcd(av_data_off[6],')',0);
N			int2lcd(av_data_off[2],'[',0);
N			int2lcd(av_data_off[0],'<',0); 
N			if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N			sub_bgnd(sm_mont[av_data_off[1]],']',0);
N			
N						
N			}	
N		int2lcd(av_head[1]+1,'+',0);
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		
N		}
N
N	else if((av_head[0]=='V')&&(av_head[1]=='I')&&(av_head[2]=='N'))
N		{
N		av_j_si_max=4;  
N		ptrs[0]=" Авария входного    ";
N		ptrs[1]=" напряжения (заниж.)";
N		if(av_head_int[1]==1)ptrs[1]=" напряжения (завыш.)";
N		ptrs[2]="   Начало           ";
N		ptrs[3]="  0%[  0^ 0@:0#:0$  ";
N		ptrs[4]="        Uвх=    <В  ";
N		ptrs[5]="   Конец            ";
N		ptrs[6]="  0qw  0r 0i:0l:0s  ";
N		ptrs[7]="        Uвх=    >В  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[5]="  Не устранена      ";
N			ptrs[6]="                    ";
N			ptrs[7]="                    ";
N			av_j_si_max=2;
N			}
N			
N		bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X		bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N		
N		int2lcd(av_head[1]+1,'!',0);
N
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'[',0);
N				
N		int2lcd(av_data_off[4],'i',0);
N		int2lcd(av_data_off[5],'l',0);
N		int2lcd(av_data_off[6],'s',0);
N		int2lcd(av_data_off[2],'q',0);
N		int2lcd(av_data_off[0],'r',0); 
N		if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N		sub_bgnd(sm_mont[av_data_off[1]],'w',0);
N		
N		int2lcd(av_head_int[0],'<',1);
N		int2lcd(av_data[0]+(av_data[1]*256),'>',1);
N			
N		
N		//int2lcdyx(av_head_int[0],0,3,0);
N		//int2lcdyx(av_head_int[1],0,7,0);
N
N						
N		}
N
N	else if((av_head[0]=='V')&&(av_head[1]=='O')&&(av_head[2]=='U')&&(av_head[3]=='T'))
N		{
N		av_j_si_max=4;  
N		ptrs[0]=" Авария выходного   ";
N		ptrs[1]=" напряжения (заниж.)";
W "main.c" 2733 6 subscript out of range
N		if(av_head_int[2]==1)ptrs[1]=" напряжения (завыш.)";
N		ptrs[2]="   Начало           ";
N		ptrs[3]="  0%[  0^ 0@:0#:0$  ";
N		ptrs[4]="       Uвых=    <В  ";
N		ptrs[5]="   Конец            ";
N		ptrs[6]="  0qw  0r 0i:0l:0s  ";
N		ptrs[7]="       Uвых=    >В  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[5]="  Не устранена      ";
N			ptrs[6]="                    ";
N			ptrs[7]="                    ";
N			av_j_si_max=2;
N			}
N			
N		bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X		bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N		
N		int2lcd(av_head[1]+1,'!',0);
N
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'[',0);
N				
N		int2lcd(av_data_off[4],'i',0);
N		int2lcd(av_data_off[5],'l',0);
N		int2lcd(av_data_off[6],'s',0);
N		int2lcd(av_data_off[2],'q',0);
N		int2lcd(av_data_off[0],'r',0); 
N		if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N		sub_bgnd(sm_mont[av_data_off[1]],'w',0);
N		
N		int2lcd(av_head_int[0],'<',1);
N		int2lcd(av_data[0]+(av_data[1]*256),'>',1);
N
N						
N		}
N
N
N	else if((av_head[0]=='O')&&(av_head[1]=='V')&&(av_head[2]=='L'))
N		{  
N		ptrs[0]=" ПЕРЕГРУЗКА СИСТЕМЫ ";
N		ptrs[1]="       ПО ТОКУ      ";
N		
N		ptrs[2]="  0%(  0^ 0@:0#:0$  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[3]="    не устранена    ";
N			bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N			}
N		else 
N			{
N			gran_char(&index_set,0,1);
X			gran_char(&a_ind . i_s,0,1);
N			ptrs[3]="      устранена     ";
N			ptrs[4]="  0[]  0< 0>:0=:0)  ";
N			bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X			bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N			int2lcd(av_data_off[4],'>',0);
N			int2lcd(av_data_off[5],'=',0);
N			int2lcd(av_data_off[6],')',0);
N			int2lcd(av_data_off[2],'[',0);
N			int2lcd(av_data_off[0],'<',0); 
N			if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N			sub_bgnd(sm_mont[av_data_off[1]],']',0);
N			
N						
N			}	
N		int2lcd(av_head[1]+1,'+',0);
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'(',0);
N		
N		}
N
N	else if((av_head[0]=='T')&&(av_head[1]=='S')&&(av_head[2]=='Y')&&(av_head[3]=='S'))
N		{
N		av_j_si_max=4;  
N		ptrs[0]="  Авария перегрев   ";
N		ptrs[1]="      системы       ";
N		ptrs[2]="   Начало           ";
N		ptrs[3]="  0%[  0^ 0@:0#:0$  ";
N		ptrs[4]="  Tсистемы =   <°С  ";
N		ptrs[5]="   Конец            ";
N		ptrs[6]="  0qw  0r 0i:0l:0s  ";
N		ptrs[7]="  Tсистемы =   >°С  ";
N		if((av_data_off[0]=='A')&&(av_data_off[1]=='A'))
N			{
N			ptrs[5]="  Не устранена      ";
N			ptrs[6]="                    ";
N			ptrs[7]="                    ";
N			av_j_si_max=2;
N			}
N			
N		bgnd_par(ptrs[index_set],ptrs[1+index_set],ptrs[2+index_set],ptrs[3+index_set]);
X		bgnd_par(ptrs[a_ind . i_s],ptrs[1+a_ind . i_s],ptrs[2+a_ind . i_s],ptrs[3+a_ind . i_s]);
N		
N		int2lcd(av_head[1]+1,'!',0);
N
N		int2lcd(av_data_on[4],'@',0);
N		int2lcd(av_data_on[5],'#',0);
N		int2lcd(av_data_on[6],'$',0);
N		int2lcd(av_data_on[2],'%',0);
N		int2lcd(av_data_on[0],'^',0); 
N		if(!((av_data_on[1]>=1)&&(av_data_on[1]<=12)))av_data_on[1]=1;
N		sub_bgnd(sm_mont[av_data_on[1]],'[',0);
N				
N		int2lcd(av_data_off[4],'i',0);
N		int2lcd(av_data_off[5],'l',0);
N		int2lcd(av_data_off[6],'s',0);
N		int2lcd(av_data_off[2],'q',0);
N		int2lcd(av_data_off[0],'r',0); 
N		if(!((av_data_off[1]>=1)&&(av_data_off[1]<=12)))av_data_off[1]=1;
N		sub_bgnd(sm_mont[av_data_off[1]],'w',0);
N		
N		int2lcd(av_head_int[0],'<',0);
N		int2lcd(av_data[0]+(av_data[1]*256),'>',0);
N
N						
N		}	
N	
N	}
N		 
Nelse if(ind==iBatLog)
Xelse if(a_ind . i==iBatLog)
N	{
N	if(BAT_IS_ON[sub_ind1]==bisON)ptrs[0]=" Введена  0!/@  /0# ";
X	if(BAT_IS_ON[a_ind . s_i1]==bisON)ptrs[0]=" Введена  0!/@  /0# ";
N	else ptrs[0]=" Выведена 0!/@  /0# ";
N     ptrs[1]=" Номин.емк.     $A*ч";
N     ptrs[2]=" Наработка      %ч. ";
N     ptrs[3]=" Контроль емкости   ";
N     ptrs[4]=" Выравнивающий заряд";
N     ptrs[5]=" Разряды            ";
N     ptrs[6]=sm_exit;	
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(	" БАТАРЕЙНЫЙ ЖУРНАЛ  ",
N			"     БАТАРЕЯ N^     ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1]);
X			ptrs[a_ind . i_s+1]);
N	pointer_set(2);	
N
N	int2lcd(sub_ind1+1,'^',0); 
X	int2lcd(a_ind . s_i1+1,'^',0); 
N	int2lcd(BAT_DAY_OF_ON[sub_ind1],'!',0);
X	int2lcd(BAT_DAY_OF_ON[a_ind . s_i1],'!',0);
N	sub_bgnd(sm_mont[BAT_MONTH_OF_ON[sub_ind1]],'@',0);
X	sub_bgnd(sm_mont[BAT_MONTH_OF_ON[a_ind . s_i1]],'@',0);
N	int2lcd(BAT_YEAR_OF_ON[sub_ind1],'#',0); 
X	int2lcd(BAT_YEAR_OF_ON[a_ind . s_i1],'#',0); 
N	int2lcd(BAT_C_NOM[sub_ind1],'$',0);
X	int2lcd(BAT_C_NOM[a_ind . s_i1],'$',0);
N	int2lcd(BAT_RESURS[sub_ind1],'%',0);
X	int2lcd(BAT_RESURS[a_ind . s_i1],'%',0);
N
N	/*int2lcdyx(BAT_IS_ON[0],0,2,0);
N	int2lcdyx(BAT_IS_ON[1],0,6,0); 
N	int2lcdyx(lc640_read_int(EE_BAT1_IS_ON),0,10,0);
N	int2lcdyx(lc640_read_int(EE_BAT2_IS_ON),0,14,0);*/
N	}
N
Nelse if(ind==iBatLogKe)
Xelse if(a_ind . i==iBatLogKe)
N	{             
N	if(av_j_si_max==0)
N		{
N		bgnd_par(	"  КОНТРОЛИ ЕМКОСТИ  ",
N				"     БАТАРЕИ N!     ",
N				" Журнал пуст        ",
N				sm_exit);
N		pointer_set(3);
N		sub_ind=0;
X		a_ind . s_i=0;
N		index_set=0;
X		a_ind . i_s=0;
N		} 
N	else if(av_j_si_max==1)
N		{
N		bgnd_par(	"  КОНТРОЛИ ЕМКОСТИ  ",
N				"     БАТАРЕИ N!     ",
N				" (                  ",
N				sm_exit);
N		index_set=0;
X		a_ind . i_s=0;
N		pointer_set(2);
N		}	
N	else
N		{
N		if(sub_ind<index_set) index_set=sub_ind;
X		if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N		else if((sub_ind-index_set)>1) index_set=sub_ind-1;
X		else if((a_ind . s_i-a_ind . i_s)>1) a_ind . i_s=a_ind . s_i-1;
N		if(index_set==(av_j_si_max-1)) 
X		if(a_ind . i_s==(av_j_si_max-1)) 
N			{
N			bgnd_par( "  КОНТРОЛИ ЕМКОСТИ  ",
N					"     БАТАРЕИ N!     ",
N					" (                  ",
N					sm_exit);
N			}
N		else
N			{
N			bgnd_par(	"  КОНТРОЛИ ЕМКОСТИ  ",
N					"     БАТАРЕИ N!     ",
N					" (                  ",
N					" [                  ");
N			}
N		pointer_set(2);			 
N		}
N		
N   	int2lcd(sub_ind1+1,'!',0);
X   	int2lcd(a_ind . s_i1+1,'!',0);
N 	event_data2ind(content[index_set],'(');
X 	event_data2ind(content[a_ind . i_s],'(');
N 	event_data2ind(content[index_set+1],'[');
X 	event_data2ind(content[a_ind . i_s+1],'[');
N	}
N
Nelse if(ind==iBatLogVz)
Xelse if(a_ind . i==iBatLogVz)
N	{
N	if(av_j_si_max==0)
N		{
N		bgnd_par(	"ВЫРАВНИВАЮЩИЕ ЗАРЯДЫ",
N				"     БАТАРЕИ N!     ",
N				" Журнал пуст        ",
N				sm_exit);
N		sub_ind=0;
X		a_ind . s_i=0;
N		index_set=0;
X		a_ind . i_s=0;
N		pointer_set(3);
N		} 
N	else if(av_j_si_max==1)
N		{
N		bgnd_par(	"ВЫРАВНИВАЮЩИЕ ЗАРЯДЫ",
N				"     БАТАРЕИ N!     ",
N				" (                  ",
N				sm_exit);
N		index_set=0;
X		a_ind . i_s=0;
N		pointer_set(2);
N		}	
N	else
N		{
N		if(sub_ind<index_set) index_set=sub_ind;
X		if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N		else if((sub_ind-index_set)>1) index_set=sub_ind-1;
X		else if((a_ind . s_i-a_ind . i_s)>1) a_ind . i_s=a_ind . s_i-1;
N		if(index_set==(av_j_si_max-1)) 
X		if(a_ind . i_s==(av_j_si_max-1)) 
N			{
N			bgnd_par(	"ВЫРАВНИВАЮЩИЕ ЗАРЯДЫ",
N					"     БАТАРЕИ N!     ",
N					" (                  ",
N					sm_exit);
N			}
N
N		else bgnd_par(	"ВЫРАВНИВАЮЩИЕ ЗАРЯДЫ",
N					"     БАТАРЕИ N!     ",
N					" (                  ",
N					" [                  "); 
N		pointer_set(2);			        
N		}
N   	int2lcd(sub_ind1+1,'!',0);
X   	int2lcd(a_ind . s_i1+1,'!',0);
N 	event_data2ind(content[index_set],'(');
X 	event_data2ind(content[a_ind . i_s],'(');
N 	event_data2ind(content[index_set+1],'[');
X 	event_data2ind(content[a_ind . i_s+1],'[');
N	
N	}
N   
Nelse if(ind==iBatLogWrk)
Xelse if(a_ind . i==iBatLogWrk)
N	{
N	if(av_j_si_max==0)
N		{
N		bgnd_par(	"      РАЗРЯДЫ       ",
N				"     БАТАРЕИ N!     ",
N				" Журнал пуст        ",
N				sm_exit);
N		sub_ind=0;
X		a_ind . s_i=0;
N		index_set=0;
X		a_ind . i_s=0;
N		pointer_set(3);
N		} 
N	else if(av_j_si_max==1)
N		{
N		bgnd_par(	"      РАЗРЯДЫ       ",
N				"     БАТАРЕИ N!     ",
N				" (                  ",
N				sm_exit);
N		index_set=0;
X		a_ind . i_s=0;
N		pointer_set(2);
N		}	
N
N	else
N		{
N		if(sub_ind<index_set) index_set=sub_ind;
X		if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N		else if((sub_ind-index_set)>1) index_set=sub_ind-1;
X		else if((a_ind . s_i-a_ind . i_s)>1) a_ind . i_s=a_ind . s_i-1;
N		if(index_set==(av_j_si_max-1))
X		if(a_ind . i_s==(av_j_si_max-1))
N			{
N			bgnd_par(	"      РАЗРЯДЫ       ",
N					"     БАТАРЕИ N!     ",
N					" (                  ",
N					sm_exit);
N			}
N		else bgnd_par(	"      РАЗРЯДЫ       ",
N					"     БАТАРЕИ N!     ",
N					" (                  ",
N					" [                  ");
N
N		pointer_set(2);
N		}
N
N   	int2lcd(sub_ind1+1,'!',0);
X   	int2lcd(a_ind . s_i1+1,'!',0);
N 	event_data2ind(content[index_set],'(');
X 	event_data2ind(content[a_ind . i_s],'(');
N 	event_data2ind(content[index_set+1],'[');
X 	event_data2ind(content[a_ind . i_s+1],'[');
N
N	
N
N	} 
N	
Nelse if((ind==iSet_prl)||(ind==iK_prl)
Xelse if((a_ind . i==iSet_prl)||(a_ind . i==iK_prl)
N	||(ind==iAusw_prl)||(ind==iPrltst))
X	||(a_ind . i==iAusw_prl)||(a_ind . i==iPrltst))
N	{
N	bgnd_par("  Введите  пароль   ",sm_,sm_,sm_);
N	int2lcdyx(parol[0],1,8,0);
N     int2lcdyx(parol[1],1,9,0);
N     int2lcdyx(parol[2],1,10,0);
N     lcd_buffer[48+sub_ind]='¤';
X     lcd_buffer[48+a_ind . s_i]='¤';
N	}	
N		
Nelse if(ind==iPrl_bat_in_out)
Xelse if(a_ind . i==iPrl_bat_in_out)
N	{
N	if(BAT_IS_ON[sub_ind1]==bisON)ptrs[0]="Для выведения бат.-и";
X	if(BAT_IS_ON[a_ind . s_i1]==bisON)ptrs[0]="Для выведения бат.-и";
N	else  ptrs[0]="Для введения батареи";
N	bgnd_par(ptrs[0],"  наберите пароль   ",sm_,sm_);
N	
N     int2lcdyx(parol[0],2,8,0);
N     int2lcdyx(parol[1],2,9,0);
N     int2lcdyx(parol[2],2,10,0);
N     lcd_buffer[68+sub_ind]='¤';	
X     lcd_buffer[68+a_ind . s_i]='¤';	
N	}
N
Nelse if(ind==iPrl_bat_in_sel)
Xelse if(a_ind . i==iPrl_bat_in_sel)
N	{
N	
N	bgnd_par(	"Для введения батареи",
N			"   выбеите ее тип   ",
N			" Свинцово-кислотная ",
N			" GYFP4875T          ");
N	
N	pointer_set(2);
N	}
N
N
Nelse if(ind==iSet)
Xelse if(a_ind . i==iSet)
N	{
N     ptrs[0]=		" Стандартные        ";
N	ptrs[1]=		" Время и дата       ";
N     ptrs[2]=		" Структура          ";
N	ptrs[3]=		" Климатконтроль     ";
N	ptrs[4]=		" Выход              ";
N     ptrs[5]=		" Мнемоника         y";
N	ptrs[6]=		" Зв.сигн.   (       ";
N	ptrs[7]=		" Отключение сигнала ";
N	ptrs[8]=		"  аварии    )       ";
N	ptrs[9]=		" АПВ источников     ";
N	ptrs[10]=		" Паралл.работа z    ";
N	ptrs[11]=		" T проверки   цепи  ";
N     ptrs[12]=		" батареи     qмин.  ";
N     ptrs[13]=		" Umax=       !В     ";
N     ptrs[14]=		" Umin=       ZВ     ";
N     ptrs[15]=		" Uб0°=       @В     ";
N     ptrs[16]=		" Uб20°=      #В     ";
N     ptrs[17]=		" Uсигн=      ^В     ";
N     ptrs[18]=		" Umin.сети=  &В     ";
N	ptrs[19]=		" U0б=        >В     ";
N	ptrs[20]=		" Iбк.=       jА     ";
N     ptrs[21]=		" Iз.мах.=    JА     ";
N     ptrs[22]=		" Imax =      ]A     ";
N     ptrs[23]=		" Imin =      {A     ";
N     ptrs[24]=		" Uвыр.зар.=   [В    ";
N     ptrs[25]=		" Tз.вкл.а.с. !с     ";
N	ptrs[26]=		" tи.max=     $°C    ";
N	ptrs[27]=		" tи.сигн=    z°C    ";
N	ptrs[28]=		" tбат.max=   b°C    ";
N	ptrs[29]=		" tбат.сигн=  X°C    ";
N     ptrs[30]=		" Внешние датчики    ";
N	ptrs[31]=		" Ethernet           ";
N     ptrs[32]=      " Адрес счетчика    +";
N     ptrs[33]=      " Контроль ср.точки  ";
N     ptrs[34]=      " батареи         Q% ";
N	ptrs[35]=      " Серийный N        w";
N     ptrs[36]=		" Выход              ";
N     ptrs[37]=		" Калибровки         "; 
N     ptrs[38]=		"                    ";        
N	
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     УСТАНОВКИ      ",
N			ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X			ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	
N	
N	if(index_set<19)
X	if(a_ind . i_s<19)
N	     {
N	     if(ZV_ON)sub_bgnd("ВКЛ.",'(',0);
N	     else sub_bgnd("ВЫК.",'(',0);
N	     if(AV_OFF_AVT)sub_bgnd("автом.",')',0);
N	     else sub_bgnd("ручн.",')',0);
N//		if(PAR)sub_bgnd("ВКЛ.",'z',0);
N//	     else sub_bgnd("ВЫК.",'z',0);
N	     if(MNEMO_ON==mnON)
N	     	{
N	     	sub_bgnd("через yс.",'y',-8);
N	     	int2lcd(MNEMO_TIME,'y',0);
N	     	}
N	     else sub_bgnd("выкл.",'y',-4);
N	     int2lcd(UMAX,'!',1);
N	     //int2lcd((UB20-DU),'Z',1);
N	     //int2lcd(UB0,'@',1);
N	     //int2lcd(UB20,'#',1);
N	     int2lcd(USIGN,'^',0);
N	     int2lcd(UMN,'&',0);
N	     int2lcd(U0B,'>',1);
N	     } 
N	int2lcd(TMAX,'$',0);
N	int2lcd(IKB,'j',2);
N//	int2lcd(UVZ,'[',1);
N	int2lcd(IMAX,']',1);
N	int2lcd(IMIN,'{',1);
N	int2lcd(IZMAX,'J',1); 
N	int2lcd(TZAS,'!',0);
N	int2lcd(TBAT,'q',0);
N	int2lcd(TSIGN,'z',0); 
N	int2lcd(TBATMAX,'b',0); 
N	int2lcd(TBATSIGN,'X',0);
N     int2lcd(POWER_CNT_ADRESS,'+',0);
N     if(UBM_AV)
N          {
N          int2lcd(UBM_AV,'Q',0);
N          } 
N     else sub_bgnd("ВЫКЛ.",'Q',-2);
N
N
N	long2lcd_mmm(AUSW_MAIN_NUMBER,'w',0);
N	}
N
N
Nelse if((ind==iSet_VD))
Xelse if((a_ind . i==iSet_VD))
N	{
N    ptrs[0]=		" Стандартные        ";
N	ptrs[1]=		" Время и дата       ";
N    ptrs[2]=		" Структура          ";
N	ptrs[3]=		" Выход              ";
N	ptrs[4]=		" Зв.сигн.   (       ";
N	ptrs[5]=		" Отключение сигнала ";
N	ptrs[6]=		"  аварии    )       ";
N	ptrs[7]=		" АПВ источников     ";
N	ptrs[8]=		" Uвых. =        @В  ";
N    ptrs[9]=		" Uавтон. =      #В  ";
N	ptrs[10]=		" tбпс.сигн =    z°C ";
N	ptrs[11]=		" tбпс.max =     $°C ";
N	ptrs[12]=		" tсист.max =    [°C ";
N	ptrs[13]=		" dUбпс.авар =   ZВ  ";
N    ptrs[14]=		" Uбпс.авар =    !В  ";
N    ptrs[15]=		" Uвх.авар.max =   ^В";
N    ptrs[16]=		" Uвх.авар.min =   &В";
N    ptrs[17]=		" Uвых.авар.max =  jВ";
N    ptrs[18]=		" Uвых.авар.min =  JВ";
N	ptrs[19]=		" Tз.ав.сигн. =    }с";
N    ptrs[20]=		" Порог ресурса      ";
N    ptrs[21]=		" вентилятора      ]ч";
N	ptrs[22]=		" Реле               ";
N	ptrs[23]=		" Ethernet           ";
N	ptrs[24]=		" MODBUS ADRESS     <";
N	ptrs[25]=		" MODBUS BAUDRATE    ";
N	ptrs[26]=		"                  >0";
N	ptrs[27]=		" Измерение тока     ";
N	ptrs[28]=		" нагрузки          {";
N    ptrs[29]=		" Выход              ";
N    ptrs[30]=		" Калибровки         "; 
N    ptrs[31]=		"                    ";        
N	
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     УСТАНОВКИ      ",
N			ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X			ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	
N	
N//	if(index_set<19)
N		{
N	    if(ZV_ON)sub_bgnd("ВКЛ.",'(',0);
N	    else sub_bgnd("ВЫК.",'(',0);
N	    if(AV_OFF_AVT)sub_bgnd("автом.",')',0);
N	    else sub_bgnd("ручн.",')',0);
N		int2lcd(UOUT,'@',1);
N	    int2lcd(UAVT,'#',1);
N		int2lcd(TMAX,'$',0);	
N		int2lcd(TSIGN,'z',0);
N		int2lcd(TSYSMAX,'[',0);
N		int2lcd(UMAX,'!',1);
N		int2lcd(DU,'Z',1);
N	    int2lcd(UINMAX/10,'^',0);
N	    int2lcd(UINMIN/10,'&',0);
N		int2lcd(UOUTMAX/10,'j',0);	
N		int2lcd(UOUTMIN/10,'J',0);
N		int2lcd(TZAS,'}',0);
N		int2lcd(TVENTMAX*10,']',0);
N
N		if(TBAT==0)sub_bgnd("выкл.",'q',0);	
N		else int2lcd(TBAT,'q',0);
N
N		if(I_LOAD_MODE)
N     		{
N     		sub_bgnd("шунт",'{',-3);
N     		}
N		else sub_bgnd("суммIбпс",'{',-7);
N	    } 
N	
N	
N//	int2lcd(UVZ,'[',1);
N	//int2lcd(IMAX,']',1);
N	//int2lcd(IMIN,'{',1);
N 
N	
N	
N 
N	int2lcd(TBATMAX,'b',0); 
N	int2lcd(TBATSIGN,'X',0);
N     int2lcd(POWER_CNT_ADRESS,'+',0);
N     if(UBM_AV)
N          {
N          int2lcd(UBM_AV,'Q',0);
N          } 
N     else sub_bgnd("ВЫКЛ.",'Q',-2);
N
N
N	long2lcd_mmm(AUSW_MAIN_NUMBER,'w',0);
N	if(index_set>19)
X	if(a_ind . i_s>19)
N		{
N		if(TERMOKOMPENS)sub_bgnd("ВКЛ.",'q',-3);
N		else sub_bgnd("ВЫКЛ.",'q',-4);
N		}
N	int2lcd(MODBUS_ADRESS,'<',0);
N	int2lcd(MODBUS_BAUDRATE,'>',0);
N
N	if((FORVARDBPSCHHOUR<=0)||(FORVARDBPSCHHOUR>500)) {
N		sub_bgnd("ВЫКЛ.",'l',0);
N	} else {
N		int2lcd(FORVARDBPSCHHOUR,'l',0);	
N	}
N
N	//int2lcdyx(sub_ind,0,3,0);
N	//int2lcdyx(index_set,0,1,0);PWM_START
N	int2lcd(PWM_START,'(',0);
N	
N	if(KB_ALGORITM==1)	sub_bgnd("1-о ступ.",')',0);
N	else if(KB_ALGORITM==2)	sub_bgnd("2-х ступ.",')',0);
N	else 				sub_bgnd("3-х ступ.",')',0);
N	if(REG_SPEED==2)	sub_bgnd("стандарт/2",'&',0);
N	else if(REG_SPEED==3)	sub_bgnd("стандарт/3",'&',0);
N	else if(REG_SPEED==4)	sub_bgnd("стандарт/4",'&',0);
N	else if(REG_SPEED==5)	sub_bgnd("стандарт/5",'&',0);
N	else 				sub_bgnd("стандарт",'&',0);
N
N	int2lcd(MODBUS_ADRESS,'<',0);
N	int2lcd(MODBUS_BAUDRATE,'>',0);
N
N	}
N
N
N
N
Nelse if (ind==iDef_220_IPS_TERMOKOMPENSAT)
Xelse if (a_ind . i==iDef_220_IPS_TERMOKOMPENSAT)
N	{ 
N	ptrs[0]=" ИПС380/220-45АТКИ17";
N	ptrs[1]=" ИПС220/220-10АТКИ17";
N	ptrs[2]=" ИПС380/110-90АТКИ9 ";
N	ptrs[3]=" ИПС380/220-ТКИ18   ";
N	ptrs[4]=sm_exit;
N	ptrs[5]="                    ";
N	ptrs[6]="                    ";
N	if(bFL5)ptrs[default_temp]=sm_;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N
N    	bgnd_par("СТАНДАРТНЫЕ УСТ.-КИ ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X    	bgnd_par("СТАНДАРТНЫЕ УСТ.-КИ ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	} 	
N
Nelse if(ind==iSet_T)
Xelse if(a_ind . i==iSet_T)
N	{
N	static char phase_cnt;
N	if(++phase_cnt>=15)
N	     {
N	     phase_cnt=0;
N	     if(++phase>=3)phase=0;
N	     }
N	ptrs[0]=sm_time;
N	ptrs[1]=sm_;
N	if(phase==0)ptrs[2]="     <> - выбор     ";
N     if(phase==1)ptrs[2]="   ^v - установка   ";
N     if(phase==2)ptrs[2]="     ¤  - выход     ";
N	
N	bgnd_par(" УСТАНОВКА  ВРЕМЕНИ ",ptrs[0],ptrs[1],ptrs[2]);
N     if(sub_ind==0)lcd_buffer[42]='^';
X     if(a_ind . s_i==0)lcd_buffer[42]='^';
N     else if(sub_ind==1)lcd_buffer[45]='^';
X     else if(a_ind . s_i==1)lcd_buffer[45]='^';
N     else if(sub_ind==2)lcd_buffer[48]='^';
X     else if(a_ind . s_i==2)lcd_buffer[48]='^';
N     else if(sub_ind==3)lcd_buffer[51]='^';
X     else if(a_ind . s_i==3)lcd_buffer[51]='^';
N     else if(sub_ind==4)lcd_buffer[54]='^';
X     else if(a_ind . s_i==4)lcd_buffer[54]='^';
N     else if(sub_ind==5)lcd_buffer[58]='^';
X     else if(a_ind . s_i==5)lcd_buffer[58]='^';
N  
N 	int2lcd(LPC_RTC->SEC,'&',0);
X 	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->SEC,'&',0);
N 	int2lcd(LPC_RTC->MIN,'^',0);
X 	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MIN,'^',0);
N 	int2lcd(LPC_RTC->HOUR,'%',0);
X 	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->HOUR,'%',0);
N 	
N 	int2lcd(LPC_RTC->DOM,'<',0);
X 	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM,'<',0);
N 	sub_bgnd(sm_mont[LPC_RTC->MONTH],'>',0);
X 	sub_bgnd(sm_mont[((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH],'>',0);
N 	int2lcd(LPC_RTC->YEAR,'{',0);
X 	int2lcd(((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR,'{',0);
N 	if(bFL2)
N 	     {
N 	     lcd_buffer[find(':')]=' ';
N 	     lcd_buffer[find(':')]=' ';
N 	     }  
N	}  
N
Nelse if(ind==iStr)
Xelse if(a_ind . i==iStr)
N	{
N	ptrs[0]=" Батарей           @";
N	ptrs[1]=" Источников        !";
N	ptrs[2]=" Инверторов        ^";	
N	ptrs[3]=" Контролируемых     ";
N	ptrs[4]=" автоматов         $";
N	ptrs[5]=" Выход              ";
N
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N	bgnd_par("      СТРУКТУРА     ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("      СТРУКТУРА     ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N
N	int2lcd(NUMBAT,'@',0);		
N	int2lcd(NUMIST,'!',0);
N	int2lcd(NUMAVT,'$',0);	 
N	int2lcd(NUMINV,'^',0);
N	int2lcd(NUMDT,'#',0);
N	int2lcd(NUMSK,'$',0);
N	}    
N
Nelse if(ind==iStr_VD)
Xelse if(a_ind . i==iStr_VD)
N	{
N	ptrs[0]=" Источников        !";
N	ptrs[1]=" Датчиков темпер.  #";
N//	ptrs[2]=" Мониторов АКБ     %";
N//	ptrs[3]=" Сухих контактов   $";
N	ptrs[2]=" Выход              ";
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N	bgnd_par("      СТРУКТУРА     ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("      СТРУКТУРА     ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N
N	int2lcd(NUMIST,'!',0); 
N	int2lcd(NUMDT,'#',0);
N	int2lcd(NUMMAKB,'%',0);
N	int2lcd(NUMSK,'$',0);
N	}    
N
Nelse if (ind==iLan_set)
Xelse if (a_ind . i==iLan_set)
N	{
N	char sss[10]="abcdef";
N	char i/*,i_flag*/;
N	 
N	ptrs[0]=	" Ethernet         ! ";
N	ptrs[1]=	" DHCPклиент       @ ";
N	ptrs[2]=	" IPадрес            ";
N	ptrs[3]=	"  000.000.000.00#   ";
N	ptrs[4]=	" Маска подсети      ";
N	ptrs[5]=	"  000.000.000.00$   ";
N	ptrs[6]=	" Шлюз               ";
N	ptrs[7]=	"  000.000.000.00)   ";
N	ptrs[8]=	" Порт.чтения       [";
N	ptrs[9]=	" Порт.записи       ]";
N	ptrs[10]=	" Community <        ";
N	ptrs[11]=	" Адресат для TRAP N1";
N	ptrs[12]=	"  000.000.000.00%   ";
N	ptrs[13]=	" Адресат для TRAP N2";
N	ptrs[14]=	"  000.000.000.00^   ";
N	ptrs[15]=	" Адресат для TRAP N3";
N	ptrs[16]=	"  000.000.000.00&   ";
N	ptrs[17]=	" Адресат для TRAP N4";
N	ptrs[18]=	"  000.000.000.00*   ";
N	ptrs[19]=	" Адресат для TRAP N5";
N	ptrs[20]=	"  000.000.000.00(   ";
N	ptrs[21]=	" Выход              ";
N
N	
N	if(!ETH_IS_ON)
N		{
N		ptrs[1]=" Выход              ";
N		ptrs[2]="                    ";
N		ptrs[3]="                    ";
N		}
N
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N
N     bgnd_par(	" УСТАНОВКИ Ethernet ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N     if(ETH_IS_ON)
N     	{
N     	sub_bgnd("ВКЛ.",'!',-3);   
N     	}
N     else 
N     	{
N     	sub_bgnd("ВЫКЛ.",'!',-4);   
N     	}
N
N     if(ETH_DHCP_ON)
N     	{
N     	sub_bgnd("ВКЛ.",'@',-3);   
N     	}
N     else 
N     	{
N     	sub_bgnd("ВЫКЛ.",'@',-4);   
N     	}
N		  
N	if(sub_ind==2)	ip2lcd(ETH_IP_1,ETH_IP_2,ETH_IP_3,ETH_IP_4,'#',(sub_ind1+1));
X	if(a_ind . s_i==2)	ip2lcd(ETH_IP_1,ETH_IP_2,ETH_IP_3,ETH_IP_4,'#',(a_ind . s_i1+1));
N	else ip2lcd(ETH_IP_1,ETH_IP_2,ETH_IP_3,ETH_IP_4,'#',0);
N	if(sub_ind==4)	ip2lcd(ETH_MASK_1,ETH_MASK_2,ETH_MASK_3,ETH_MASK_4,'$',(sub_ind1+1));
X	if(a_ind . s_i==4)	ip2lcd(ETH_MASK_1,ETH_MASK_2,ETH_MASK_3,ETH_MASK_4,'$',(a_ind . s_i1+1));
N	else ip2lcd(ETH_MASK_1,ETH_MASK_2,ETH_MASK_3,ETH_MASK_4,'$',0);
N	if(sub_ind==6)	ip2lcd(ETH_GW_1,ETH_GW_2,ETH_GW_3,ETH_GW_4,')',(sub_ind1+1));
X	if(a_ind . s_i==6)	ip2lcd(ETH_GW_1,ETH_GW_2,ETH_GW_3,ETH_GW_4,')',(a_ind . s_i1+1));
N	else ip2lcd(ETH_GW_1,ETH_GW_2,ETH_GW_3,ETH_GW_4,')',0);
N
N	int2lcd(ETH_SNMP_PORT_READ,'[',0);
N	int2lcd(ETH_SNMP_PORT_WRITE,']',0);
N
N	if( (ETH_TRAP1_IP_1==255) && (ETH_TRAP1_IP_2==255) && (ETH_TRAP1_IP_3==255) && (ETH_TRAP1_IP_4==255) ) sub_bgnd("    неактивен    ",'%',-14);
N	else
N		{
N		if(sub_ind==11)	ip2lcd(ETH_TRAP1_IP_1,ETH_TRAP1_IP_2,ETH_TRAP1_IP_3,ETH_TRAP1_IP_4,'%',(sub_ind1+1));
X		if(a_ind . s_i==11)	ip2lcd(ETH_TRAP1_IP_1,ETH_TRAP1_IP_2,ETH_TRAP1_IP_3,ETH_TRAP1_IP_4,'%',(a_ind . s_i1+1));
N		else ip2lcd(ETH_TRAP1_IP_1,ETH_TRAP1_IP_2,ETH_TRAP1_IP_3,ETH_TRAP1_IP_4,'%',0);
N		}
N
N	if( (ETH_TRAP2_IP_1==255) && (ETH_TRAP2_IP_2==255) && (ETH_TRAP2_IP_3==255) && (ETH_TRAP2_IP_4==255) ) sub_bgnd("    неактивен    ",'^',-14);
N	else
N		{
N		if(sub_ind==13)	ip2lcd(ETH_TRAP2_IP_1,ETH_TRAP2_IP_2,ETH_TRAP2_IP_3,ETH_TRAP2_IP_4,'^',(sub_ind1+1));
X		if(a_ind . s_i==13)	ip2lcd(ETH_TRAP2_IP_1,ETH_TRAP2_IP_2,ETH_TRAP2_IP_3,ETH_TRAP2_IP_4,'^',(a_ind . s_i1+1));
N		else ip2lcd(ETH_TRAP2_IP_1,ETH_TRAP2_IP_2,ETH_TRAP2_IP_3,ETH_TRAP2_IP_4,'^',0);
N		}
N
N	if( (ETH_TRAP3_IP_1==255) && (ETH_TRAP3_IP_2==255) && (ETH_TRAP3_IP_3==255) && (ETH_TRAP3_IP_4==255) ) sub_bgnd("    неактивен    ",'&',-14);
N	else
N		{
N		if(sub_ind==15)	ip2lcd(ETH_TRAP3_IP_1,ETH_TRAP3_IP_2,ETH_TRAP3_IP_3,ETH_TRAP3_IP_4,'&',(sub_ind1+1));
X		if(a_ind . s_i==15)	ip2lcd(ETH_TRAP3_IP_1,ETH_TRAP3_IP_2,ETH_TRAP3_IP_3,ETH_TRAP3_IP_4,'&',(a_ind . s_i1+1));
N		else ip2lcd(ETH_TRAP3_IP_1,ETH_TRAP3_IP_2,ETH_TRAP3_IP_3,ETH_TRAP3_IP_4,'&',0);
N		}
N
N	if( (ETH_TRAP4_IP_1==255) && (ETH_TRAP4_IP_2==255) && (ETH_TRAP4_IP_3==255) && (ETH_TRAP4_IP_4==255) ) sub_bgnd("    неактивен    ",'*',-14);
N	else
N		{
N		if(sub_ind==17)	ip2lcd(ETH_TRAP4_IP_1,ETH_TRAP4_IP_2,ETH_TRAP4_IP_3,ETH_TRAP4_IP_4,'*',(sub_ind1+1));
X		if(a_ind . s_i==17)	ip2lcd(ETH_TRAP4_IP_1,ETH_TRAP4_IP_2,ETH_TRAP4_IP_3,ETH_TRAP4_IP_4,'*',(a_ind . s_i1+1));
N		else ip2lcd(ETH_TRAP4_IP_1,ETH_TRAP4_IP_2,ETH_TRAP4_IP_3,ETH_TRAP4_IP_4,'*',0);
N		}
N
N	if( (ETH_TRAP5_IP_1==255) && (ETH_TRAP5_IP_2==255) && (ETH_TRAP5_IP_3==255) && (ETH_TRAP5_IP_4==255) ) sub_bgnd("    неактивен    ",'(',-14);
N	else
N		{
N		if(sub_ind==19)	ip2lcd(ETH_TRAP5_IP_1,ETH_TRAP5_IP_2,ETH_TRAP5_IP_3,ETH_TRAP5_IP_4,'(',(sub_ind1+1));
X		if(a_ind . s_i==19)	ip2lcd(ETH_TRAP5_IP_1,ETH_TRAP5_IP_2,ETH_TRAP5_IP_3,ETH_TRAP5_IP_4,'(',(a_ind . s_i1+1));
N		else ip2lcd(ETH_TRAP5_IP_1,ETH_TRAP5_IP_2,ETH_TRAP5_IP_3,ETH_TRAP5_IP_4,'(',0);
N		}
N
N/*	if((sub_ind==2)&&(sub_ind1==0)&&(bFL2))
N		{
N		sub_bgnd("   ",'#',-2);
N		}
N	else int2lcd(ETH_IP_1,'#',0);
N
N	if((sub_ind==2)&&(sub_ind1==1)&&(bFL2))
N		{
N		sub_bgnd("   ",'$',-2);
N		}
N	else int2lcd(ETH_IP_2,'$',0);
N
N	if((sub_ind==2)&&(sub_ind1==2)&&(bFL2))
N		{
N		sub_bgnd("   ",'%',-2);
N		}
N	else int2lcd(ETH_IP_3,'%',0);
N
N	if((sub_ind==2)&&(sub_ind1==3)&&(bFL2))
N		{
N		sub_bgnd("   ",'^',-2);
N		}
N	else int2lcd(ETH_IP_4,'^',0);*/
N
N
N	//int2lcdyx(sub_ind,0,1,0);	
N	//int2lcdyx(index_set,0,3,0);
N	//int2lcdyx(sub_ind1,0,5,0);
N	//for(i=0;(i<9)&&(snmp_community[i]))
N
N	for(i=0;i<9;i++)
N		{
N		sss[i]=snmp_community[i];
N		}
N	sss[9]=0;		
N
N	if(sub_ind==10)community2lcd(sss,'<',sub_ind1,1);
X	if(a_ind . s_i==10)community2lcd(sss,'<',a_ind . s_i1,1);
N	else community2lcd(sss,'<',sub_ind1,0);
X	else community2lcd(sss,'<',a_ind . s_i1,0);
N	
N	//int2lcdyx(snmp_community[0],0,4,0);
N	//int2lcdyx(snmp_community[11],0,9,0);
N	//int2lcdyx(snmp_community[2],0,14,0);
N	//int2lcdyx(snmp_community[sub_ind1],0,19,0);	
N	}
N
N
N
Nelse if (ind==iBlok_ips_set)
Xelse if (a_ind . i==iBlok_ips_set)
N	{
N	char sss[10]="abcdef";
N///	char i/*,i_flag*/;
N	 
N	ptrs[0]=	" Блокирование      ^";
N	ptrs[1]=	" Сигнал блокирования";
N	ptrs[2]=	"                   &";
N	ptrs[3]=	" Выход              ";
N
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N
N     bgnd_par(	"   БЛОКИРОВКА ИПС   ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N
N	if(ipsBlckSrc==1)sub_bgnd("СК1",'^',-2);
N	else if(ipsBlckSrc==2)sub_bgnd("СК2",'^',-2);   
N    else if(ipsBlckSrc==0)sub_bgnd("ВЫКЛ.",'^',-4);
N	else sub_bgnd("НЕКОРР..",'^',-6); 
N	if(ipsBlckLog==0)sub_bgnd("РАЗОМКН.",'&',-7);
N	else if(ipsBlckLog==1) sub_bgnd("ЗАМКН.",'&',-5);  
N    else sub_bgnd("НЕКОРР.",'&',-6); 	  
N
N	
W "main.c" 3542 7 variable "sss" was declared but never referenced
N	}
N
N
Nelse if (ind==iApv)
Xelse if (a_ind . i==iApv)
N	{ 
N	ptrs[0]=			" АПВ 1й уровень !   ";
N	if(APV_ON1!=apvON)
N	     {
N	     ptrs[1]=		" Выход              ";
N	     ptrs[2]=sm_;
N	     ptrs[3]=sm_;
N	     ptrs[4]=sm_;
N	     simax=1;
N	     }
N	else
N	     {
N	     if(APV_ON2!=apvON)
N	          {
N	          ptrs[1]=" АПВ 2й уровень @   ";
N	          ptrs[2]=" Выход              ";
N	          ptrs[3]=sm_;
N	          ptrs[4]=sm_;
N	          simax=2;
N	          }
N	     else 
N	          {
N               ptrs[1]=" АПВ 2й уровень @   ";
N	          ptrs[2]=" Период АПВ2     #ч.";
N	          ptrs[3]=" Выход              ";
N	          ptrs[4]=sm_;
N	          simax=3;	          
N	          }     
N	     }     
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;	
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;	
N     bgnd_par("   АПВ ИСТОЧНИКОВ   ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("   АПВ ИСТОЧНИКОВ   ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	if(APV_ON1==apvON)sub_bgnd("ВКЛ.",'!',0);
N	else sub_bgnd("ВЫКЛ.",'!',-1);
N	
N	if(APV_ON2==apvON)
N	     {
N	     sub_bgnd("ВКЛ.",'@',0);
N	     int2lcd(APV_ON2_TIME,'#',0);
N	     }
N	else sub_bgnd("ВЫКЛ.",'@',-1);	
N     
N 	} 
N/*
N     ptrs[0+NUMDT]=  	" СК1        $       ";            
N     ptrs[1+NUMDT]=  	" СК2        %       ";
N	ptrs[2+NUMDT]=  	" СК3        ^       ";
N	ptrs[3+NUMDT]=  	" СК4        &       ";
N	ptrs[0+NUMEXT]=  	" Выход              ";
N	ptrs[1+NUMEXT]=  	"                    ";
N	ptrs[2+NUMEXT]=  	"                    ";
N
N	bgnd_par(		"  ВНЕШНИЕ ДАТЧИКИ   ",
N				ptrs[index_set],
N				ptrs[index_set+1],
N				ptrs[index_set+2]);
N
N*/
N
Nelse if (ind==iExt_set)
Xelse if (a_ind . i==iExt_set)
N	{ 
N//	ptrs[0]=			" Датчик темпер. N1  ";
N//	ptrs[1]=			" Датчик темпер. N2  ";
N//	ptrs[2]=			" Датчик темпер. N3  ";
N	ptrs[0]=		" Датчик двери       ";
N	ptrs[1]=		" Датчик дыма        ";
N	ptrs[2]=		" Датчик удара       ";
N//	ptrs[3]=		" Датчик переворачив.";
N	ptrs[3]=  	" Выход              ";
N	ptrs[4]=  	"                    ";
N	ptrs[5]=  	"                    ";
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("     УСТАНОВКИ      ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("     УСТАНОВКИ      ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	}
N
Nelse if (ind==iExt_set_3U)
Xelse if (a_ind . i==iExt_set_3U)
N	{ 
N	ptrs[0]=		" Сухой контакт №1   ";
N	ptrs[1]=		" Сухой контакт №2   ";
N	ptrs[2]=		" Сухой контакт №3   ";
N	ptrs[3]=		" Сухой контакт №4   ";
N	ptrs[NUMSK]=  	" Выход              ";
N	ptrs[NUMSK+1]= "                    ";
N	ptrs[NUMSK+2]=	"                    ";
N	ptrs[NUMSK+3]=	"                    ";
N		
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("     УСТАНОВКИ      ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("     УСТАНОВКИ      ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	}
N	
Nelse if (ind==iExt_dt)
Xelse if (a_ind . i==iExt_dt)
N	{ 
N	ptrs[0]=" температура     @°C";
N	ptrs[1]=" tmax            #°C";
N	ptrs[2]=" tmin            $°C";
N	ptrs[3]=" Реле            [  ";
N	ptrs[4]=" Звук            ]  ";
N	ptrs[5]=" Дисплей         (  ";
N	ptrs[6]=" RS232           )  ";
N	ptrs[7]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>1) index_set=sub_ind-1;
X	else if((a_ind . s_i-a_ind . i_s)>1) a_ind . i_s=a_ind . s_i-1;
N     bgnd_par("  ВНЕШНИЙ ДАТЧИК    ","   ТЕМПЕРАТУРЫ N!   ",ptrs[index_set],ptrs[index_set+1]);
X     bgnd_par("  ВНЕШНИЙ ДАТЧИК    ","   ТЕМПЕРАТУРЫ N!   ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1]);
N	
N	pointer_set(2);
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd_mmm(t_ext[sub_ind1],'@',0);
X	int2lcd_mmm(t_ext[a_ind . s_i1],'@',0);
N	if(!TMAX_EXT_EN[sub_ind1])int2lcd_mmm(TMAX_EXT[sub_ind1],'#',0);
X	if(!TMAX_EXT_EN[a_ind . s_i1])int2lcd_mmm(TMAX_EXT[a_ind . s_i1],'#',0);
N	else sub_bgnd("выкл.",'#',-2);
N	if(!TMIN_EXT_EN[sub_ind1])int2lcd_mmm(TMIN_EXT[sub_ind1],'$',0);
X	if(!TMIN_EXT_EN[a_ind . s_i1])int2lcd_mmm(TMIN_EXT[a_ind . s_i1],'$',0);
N	else sub_bgnd("выкл.",'$',-2);
N	if(!T_EXT_REL_EN[sub_ind1])sub_bgnd("вкл.",'[',-2);
X	if(!T_EXT_REL_EN[a_ind . s_i1])sub_bgnd("вкл.",'[',-2);
N	else sub_bgnd("выкл.",'[',-2);
N	if(!T_EXT_ZVUK_EN[sub_ind1])sub_bgnd("вкл.",']',-2);
X	if(!T_EXT_ZVUK_EN[a_ind . s_i1])sub_bgnd("вкл.",']',-2);
N	else sub_bgnd("выкл.",']',-2);
N	if(!T_EXT_LCD_EN[sub_ind1])sub_bgnd("вкл.",'(',-2);
X	if(!T_EXT_LCD_EN[a_ind . s_i1])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N	if(!T_EXT_RS_EN[sub_ind1])sub_bgnd("вкл.",')',-2);
X	if(!T_EXT_RS_EN[a_ind . s_i1])sub_bgnd("вкл.",')',-2);
N	else sub_bgnd("выкл.",')',-2);	
N	
N	//int2lcdyx(sub_ind,0,1,0);	
N	//int2lcdyx(index_set,0,3,0);
N	}	
Nelse if (ind==iExt_sk)
Xelse if (a_ind . i==iExt_sk)
N	{ 
N	ptrs[0]=" состояние - @      ";
N	ptrs[1]=" аварийное          ";
N	ptrs[2]=" состояние - #      ";
N	ptrs[3]=" Реле            [  ";
N	ptrs[4]=" Звук            ]  ";
N	ptrs[5]=" Дисплей         (  ";
N	ptrs[6]=" RS232           )  ";
N	ptrs[7]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("  СУХОЙ КОНТАКТ N!  ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("  СУХОЙ КОНТАКТ N!  ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	if(sk_stat[sub_ind1]==ssON)sub_bgnd("замкнут",'@',0);
X	if(sk_stat[a_ind . s_i1]==ssON)sub_bgnd("замкнут",'@',0);
N	else sub_bgnd("разомк.",'@',0);
N	if(!SK_SIGN[sub_ind1])sub_bgnd("замкнут",'#',0);
X	if(!SK_SIGN[a_ind . s_i1])sub_bgnd("замкнут",'#',0);
N	else sub_bgnd("незамк.",'#',0);
N	if(!TMIN_EXT_EN[sub_ind1])int2lcd_mmm(TMIN_EXT[sub_ind1],'$',0);
X	if(!TMIN_EXT_EN[a_ind . s_i1])int2lcd_mmm(TMIN_EXT[a_ind . s_i1],'$',0);
N	else sub_bgnd("выкл.",'$',-6);
N	if(!SK_REL_EN[sub_ind1])sub_bgnd("вкл.",'[',-2);
X	if(!SK_REL_EN[a_ind . s_i1])sub_bgnd("вкл.",'[',-2);
N	else sub_bgnd("выкл.",'[',-2);
N	if(!SK_ZVUK_EN[sub_ind1])sub_bgnd("вкл.",']',-2);
X	if(!SK_ZVUK_EN[a_ind . s_i1])sub_bgnd("вкл.",']',-2);
N	else sub_bgnd("выкл.",']',-2);
N	if(!SK_LCD_EN[sub_ind1])sub_bgnd("вкл.",'(',-2);
X	if(!SK_LCD_EN[a_ind . s_i1])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N	if(!SK_RS_EN[sub_ind1])sub_bgnd("вкл.",')',-2);
X	if(!SK_RS_EN[a_ind . s_i1])sub_bgnd("вкл.",')',-2);
N	else sub_bgnd("выкл.",')',-2);	
N	
N	//int2lcdyx(sub_ind,0,1,0);	
N	//int2lcdyx(index_set,0,3,0);
N	}		
N
Nelse if (ind==iExt_sk_3U)
Xelse if (a_ind . i==iExt_sk_3U)
N	{ 
N	ptrs[0]=" состояние - @      ";
N	ptrs[1]=" аварийное          ";
N	ptrs[2]=" состояние - #      ";
N	ptrs[3]=" Звук            ]  ";
N	ptrs[4]=" Дисплей         (  ";
N	ptrs[5]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("  СУХОЙ КОНТАКТ N!  ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("  СУХОЙ КОНТАКТ N!  ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	if(sk_stat[sub_ind1]==ssON)sub_bgnd("замкнут",'@',0);
X	if(sk_stat[a_ind . s_i1]==ssON)sub_bgnd("замкнут",'@',0);
N	else sub_bgnd("разомк.",'@',0);
N	if(!SK_SIGN[sub_ind1])sub_bgnd("замкнут",'#',0);
X	if(!SK_SIGN[a_ind . s_i1])sub_bgnd("замкнут",'#',0);
N	else sub_bgnd("незамк.",'#',0);
N	if(!SK_ZVUK_EN[sub_ind1])sub_bgnd("вкл.",']',-2);
X	if(!SK_ZVUK_EN[a_ind . s_i1])sub_bgnd("вкл.",']',-2);
N	else sub_bgnd("выкл.",']',-2);
N	if(!SK_LCD_EN[sub_ind1])sub_bgnd("вкл.",'(',-2);
X	if(!SK_LCD_EN[a_ind . s_i1])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N	}		
N
Nelse if (ind==iExt_ddv)
Xelse if (a_ind . i==iExt_ddv)
N	{ 
N	ptrs[0]=" состояние - @      ";
N	ptrs[1]=" открытое состояние ";
N	ptrs[2]=" двери     - #      ";
N	ptrs[3]=" Реле            [  ";
N	ptrs[4]=" Дисплей         (  ";
N	ptrs[5]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("   ДАТЧИК ДВЕРИ     ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("   ДАТЧИК ДВЕРИ     ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	
N	if(sk_stat[0]==ssON)sub_bgnd("замкнут",'@',0);
N	else sub_bgnd("разомк.",'@',0);
N	if(!SK_SIGN[0])sub_bgnd("замкнут",'#',0);
N	else sub_bgnd("незамк.",'#',0);
N	if(SK_REL_EN[0])sub_bgnd("вкл.",'[',-2);
N	else sub_bgnd("выкл.",'[',-2);
N     if(SK_LCD_EN[0])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N	
N	}	
N
Nelse if (ind==iExt_ddi)
Xelse if (a_ind . i==iExt_ddi)
N	{ 
N	ptrs[0]=" состояние - @      ";
N	ptrs[1]=" аварийное          ";
N	ptrs[2]=" состояние - #      ";
N	ptrs[3]=" Реле            [  ";
N	ptrs[4]=" Дисплей         (  ";
N	ptrs[5]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("   ДАТЧИК ДЫМА      ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("   ДАТЧИК ДЫМА      ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	
N	if(sk_stat[1]==ssON)sub_bgnd("замкнут",'@',0);
N	else sub_bgnd("разомк.",'@',0);
N	if(!SK_SIGN[1])sub_bgnd("замкнут",'#',0);
N	else sub_bgnd("незамк.",'#',0);
N	if(SK_REL_EN[1])sub_bgnd("вкл.",'[',-2);
N	else sub_bgnd("выкл.",'[',-2);
N	if(SK_LCD_EN[1])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N	}	
N
Nelse if (ind==iExt_dud)
Xelse if (a_ind . i==iExt_dud)
N	{ 
N	ptrs[0]=" состояние - @      ";
N	ptrs[1]=" аварийное          ";
N	ptrs[2]=" состояние - #      ";
N	ptrs[3]=" Реле            [  ";
N	ptrs[4]=" Дисплей         (  ";
N	ptrs[5]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("   ДАТЧИК УДАРА     ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("   ДАТЧИК УДАРА     ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N	
N	if(sk_stat[2]==ssON)sub_bgnd("замкнут",'@',0);
N	else sub_bgnd("разомк.",'@',0);
N	if(!SK_SIGN[2])sub_bgnd("замкнут",'#',0);
N	else sub_bgnd("незамк.",'#',0);
N	if(SK_REL_EN[2])sub_bgnd("вкл.",'[',-2);
N	else sub_bgnd("выкл.",'[',-2);
N	if(SK_LCD_EN[2])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N	}
N
N
Nelse if (ind==iExt_dp)
Xelse if (a_ind . i==iExt_dp)
N	{ 
N	ptrs[0]=" состояние - @      ";
N	ptrs[1]=" аварийное          ";
N	ptrs[2]=" состояние - #      ";
N	ptrs[3]=" Реле            [  ";
N     ptrs[4]=" Дисплей         (  ";
N	ptrs[5]=sm_exit;
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>2) index_set=sub_ind-2;
X	else if((a_ind . s_i-a_ind . i_s)>2) a_ind . i_s=a_ind . s_i-2;
N     bgnd_par("ДАТЧИК ПЕРЕВОРАЧИВ. ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X     bgnd_par("ДАТЧИК ПЕРЕВОРАЧИВ. ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	
N	pointer_set(1);
N
N	if(sk_stat[3]==ssON)sub_bgnd("замкнут",'@',0);
N	else sub_bgnd("разомк.",'@',0);
N	if(!SK_SIGN[3])sub_bgnd("замкнут",'#',0);
N	else sub_bgnd("незамк.",'#',0);
N	if(!SK_REL_EN[3])sub_bgnd("вкл.",'[',-2);
N	else sub_bgnd("выкл.",'[',-2);
N	if(!SK_LCD_EN[3])sub_bgnd("вкл.",'(',-2);
N	else sub_bgnd("выкл.",'(',-2);
N
N
N    /* int2lcdyx(sk_stat[0],0,2,0);
N     int2lcdyx(sk_stat[1],0,5,0);
N     int2lcdyx(sk_stat[2],0,8,0);
N     int2lcdyx(sk_stat[3],0,11,0);*/
N	}
N
Nelse if(ind==iK)
Xelse if(a_ind . i==iK)
N	{
N	char i;
N	i=0;
N	
N	ptrs[i++]=" Сеть               ";
N	if(NUMBAT)
N     ptrs[i++]=" Батареи            ";
N	if(NUMIST)
N	ptrs[i++]=" БПС                ";
N	if(NUMINV)
N     ptrs[i++]=" Инверторы          ";
N	ptrs[i++]=" Нагрузка           ";
N     ptrs[i++]=" Внешние датчики    ";
N     ptrs[i++]=" Силовые вводы      ";
N     ptrs[i++]=" Выход              ";
N     ptrs[i++]="                    ";
N     ptrs[i++]="                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     КАЛИБРОВКА     ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	 
N	}    	
N
N
Nelse if(ind==iK_220_IPS_TERMOKOMPENSAT)
Xelse if(a_ind . i==iK_220_IPS_TERMOKOMPENSAT)
N	{
N	char i;
N	i=0;
N	
N	ptrs[i++]=" Сеть               ";
N	if(NUMBAT)
N     ptrs[i++]=" Батареи            ";
N	if(NUMIST)
N	ptrs[i++]=" БПС                ";
N	ptrs[i++]=" Выходные параметры ";
N     if(NUMDT)
N     ptrs[i++]=" Внешние датчики    ";
N     ptrs[i++]=" Выход              ";
N     ptrs[i++]="                    ";
N     ptrs[i++]="                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     КАЛИБРОВКА     ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	 
N	}   
N
Nelse if(ind==iK_VD)
Xelse if(a_ind . i==iK_VD)
N	{
N	char i;
N	i=0;
N	
N	ptrs[i++]=" Uвых.         !В   ";
N	ptrs[i++]=" Iвых.         @А   ";
N	if(NUMIST)
N	ptrs[i++]=" БПС                ";
N	ptrs[i++]=" Uв.д.         #В   ";
N    ptrs[i++]=" Tсистемы  =   ^°C  ";;
N    ptrs[i++]=" Выход              ";
N    ptrs[i++]="                    ";
N    ptrs[i++]="                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     КАЛИБРОВКА     ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);
N
N	int2lcd(out_U,'!',1);
N	int2lcd(out_I,'@',0);
N	int2lcd(vd_U,'#',1);
N	int2lcd(sys_T,'^',0);
N	
N	//int2lcdyx(adc_buff_[0],0,4,0);
N    //int2lcdyx(adc_buff_[1],0,9,0);	
N	
N	if((sub_ind==0)||(sub_ind==3))mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,1000,10);
X	if((a_ind . s_i==0)||(a_ind . s_i==3))mess_send(225,229,1000,10);
N	
N	//int2lcdyx(adc_buff_[6],0,4,0);
N	//int2lcdyx(Ktext[0],0,9,0);	 
N	}   
N
N
Nelse if(ind==iK_220_IPS_TERMOKOMPENSAT_IB)
Xelse if(a_ind . i==iK_220_IPS_TERMOKOMPENSAT_IB)
N	{
N	char i;
N	i=0;
N	
N	ptrs[i++]=" Сеть               ";
N    ptrs[i++]=" Батарея            ";
N	if(NUMIST)
N	ptrs[i++]=" БПС                ";
N	ptrs[i++]=" Выходные параметры ";
N    if(NUMDT)
N    ptrs[i++]=" Внешние датчики    ";
N    ptrs[i++]=" Выход              ";
N    ptrs[i++]="                    ";
N    ptrs[i++]="                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     КАЛИБРОВКА     ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	 
N	}   
N
N
Nelse if(ind==iK_TELECORE)
Xelse if(a_ind . i==iK_TELECORE)
N	{
N	char i;
N	i=0;
N	
N	ptrs[i++]=	" Сеть               ";
N	if(NUMBAT_TELECORE)
N    ptrs[i++]=	" Батареи            ";
N	if(NUMIST)
N	ptrs[i++]=	" БПС                ";
N	ptrs[i++]=	" Нагрузка           ";
N    if(NUMDT)
N    ptrs[i++]=	" Внешние датчики    ";
N    ptrs[i++]=" Выход              ";
N    ptrs[i++]="                    ";
N    ptrs[i++]="                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     КАЛИБРОВКА     ",
N			ptrs[index_set],
X			ptrs[a_ind . i_s],
N			ptrs[index_set+1],
X			ptrs[a_ind . i_s+1],
N			ptrs[index_set+2]);
X			ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	 
N	}    	
N
Nelse if(ind==iK_net)
Xelse if(a_ind . i==iK_net)
N	{
N	ptrs[0]=" U =     @В         ";
N     ptrs[1]=" Выход              ";
N	ptrs[2]="                    ";
N	
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("   КАЛИБРОВКА СЕТИ  ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("   КАЛИБРОВКА СЕТИ  ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	
N	int2lcd(net_U,'@',0);
N	//int2lcdyx(net_buff_,3,10,0);
N	
N	//int2lcdyx(Kunet,3,16,0);
N     }
N
N
Nelse if(ind==iK_net3)
Xelse if(a_ind . i==iK_net3)
N	{
N
N	ptrs[0]=  		" UфA           !В   ";
N    ptrs[1]=  		" UфB           @В   ";
N    ptrs[2]=  	    " UфC           #В   ";
N	ptrs[3]=  	    " Выход              ";
N
N
N	bgnd_par(		"   КАЛИБРОВКА СЕТИ  ",
N					ptrs[index_set],
X					ptrs[a_ind . i_s],
N					ptrs[index_set+1],
X					ptrs[a_ind . i_s+1],
N					ptrs[index_set+2]);
X					ptrs[a_ind . i_s+2]);
N
N	if(sub_ind-index_set>2)index_set=sub_ind-2;
X	if(a_ind . s_i-a_ind . i_s>2)a_ind . i_s=a_ind . s_i-2;
N	else if (sub_ind<index_set)index_set=sub_ind;
X	else if (a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	pointer_set(1);
N
N    int2lcd(net_Ua,'!',0);
N	int2lcd(net_Ub,'@',0);
N	int2lcd(net_Uc,'#',0);
N
N	/*int2lcdyx(KunetC,0,19,0);
N	int2lcdyx(adc_buff_[10],0,13,0);
N	int2lcdyx(KunetB,0,8,0);
N	int2lcdyx(adc_buff_[3],0,4,0);*/
N
N    }
N
N
Nelse if(ind==iK_load)
Xelse if(a_ind . i==iK_load)
N	{
N	ptrs[0]=" U =     @В         ";
N     ptrs[1]=" Выход              ";
N	ptrs[2]="                    ";
N	
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(		" КАЛИБРОВКА НАГРУЗКИ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2]);
X				ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);
N	if((load_U)>1000)int2lcd(load_U/10,'@',0);	
N	else int2lcd(load_U,'@',1);
N     }
N
Nelse if(ind==iK_out)
Xelse if(a_ind . i==iK_out)
N	{
N	ptrs[0]=" Uвыпр. =     @В    ";
N    ptrs[1]=" Uшины  =     #В    ";
N	ptrs[2]=" Выход              ";
N	ptrs[3]="                    ";
N	
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(	"КАЛИБРОВКА ВЫХОДНЫХ ",
N				"     ПАРАМЕТРОВ     ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1]);
X				ptrs[a_ind . i_s+1]);
N
N	pointer_set(2);
N	
N	if((bps_U)>1000)int2lcd(bps_U/10,'@',0);	
N	else int2lcd(bps_U,'@',1);
N
N	if((out_U)>1000)int2lcd(out_U/10,'#',0);	
N	else int2lcd(out_U,'#',1);
N    }
N
Nelse if(ind==iK_t_ext)
Xelse if(a_ind . i==iK_t_ext)
N	{
N	ptrs[0]=  	" tвнеш.возд.    !°С ";
N     ptrs[1]=  	" tотсек ЭПУ     @°С ";
N     ptrs[2]=  	" tотсек MSAN    #°С ";
N     ptrs[3]=	     " Выход              ";
N	ptrs[4]=	     "                    ";
N	ptrs[5]=	     "                    ";
N	
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(		" КАЛИБРОВКА ВНЕШНИХ ",
N				" ДАТЧИКОВ ТЕМПЕРАТУР",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1]);
X				ptrs[a_ind . i_s+1]);
N
N	pointer_set(2);	
N	if(ND_EXT[0])sub_bgnd("неиспр.",'!',-3);
N     else int2lcd_mmm(t_ext[0],'!',0);
N
N	if(ND_EXT[1])sub_bgnd("неиспр.",'@',-3);
N     else int2lcd_mmm(t_ext[1],'@',0);
N
N	if(ND_EXT[2])sub_bgnd("неиспр.",'#',-3);
N     else int2lcd_mmm(t_ext[2],'#',0);
N     }
N
Nelse if(ind==iK_t_ext_6U)
Xelse if(a_ind . i==iK_t_ext_6U)
N	{
N	ptrs[0]=  		" t1             !°С ";
N    ptrs[1]=  		" t2             @°С ";
N    ptrs[2]=  		" t3             #°С ";
N    ptrs[NUMDT]=	" Выход              ";
N	ptrs[NUMDT+1]=  "                    ";
N	ptrs[NUMDT+2]=  "                    ";
N	
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(		" КАЛИБРОВКА ВНЕШНИХ ",
N				" ДАТЧИКОВ ТЕМПЕРАТУР",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1]);
X				ptrs[a_ind . i_s+1]);
N
N	pointer_set(2);	
N	if(ND_EXT[0])sub_bgnd("неиспр.",'!',-3);
N     else int2lcd_mmm(t_ext[0],'!',0);
N
N	if(ND_EXT[1])sub_bgnd("неиспр.",'@',-3);
N     else int2lcd_mmm(t_ext[1],'@',0);
N
N	if(ND_EXT[2])sub_bgnd("неиспр.",'#',-3);
N     else int2lcd_mmm(t_ext[2],'#',0);
N	//int2lcdyx(u_necc,3,18,0);
N     }
N     
Nelse if(ind==iK_bat_sel)
Xelse if(a_ind . i==iK_bat_sel)
N	{
N	ptrs[0]=						" Батарея N1         ";
N     ptrs[1]=						" Батарея N2         ";
N     if(BAT_IS_ON[0]!=bisON)ptrs[0]=	" Батарея N2         ";
N	ptrs[0+NUMBAT]=				" Выход              ";
N	ptrs[1+NUMBAT]=				"                    ";
N	ptrs[2+NUMBAT]=				"                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(" КАЛИБРОВКА БАТАРЕЙ ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par(" КАЛИБРОВКА БАТАРЕЙ ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N     }     
N
Nelse if(ind==iK_bat_sel_TELECORE)
Xelse if(a_ind . i==iK_bat_sel_TELECORE)
N	{
N	ptrs[0]=						" Батарея N1         ";
N    ptrs[1]=						" Батарея N2         ";
N    ptrs[0+NUMBAT_TELECORE]=		" Выход              ";
N	ptrs[1+NUMBAT_TELECORE]=		"                    ";
N	ptrs[2+NUMBAT_TELECORE]=		"                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(" КАЛИБРОВКА БАТАРЕЙ ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par(" КАЛИБРОВКА БАТАРЕЙ ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N     }  
N
Nelse if(ind==iK_bat_TELECORE)
Xelse if(a_ind . i==iK_bat_TELECORE)
N	{
N    ptrs[0]=		" Iбат =     #А      ";
N    if(phase==0)
N      	{
N        ptrs[1]=	"   нажмите ¤ для    ";
N        ptrs[2]=	"калибровки нуля Iбат";
N        }
N    else          
N       	{
N        ptrs[1]=	" откалибруйте Iбат  ";
N        ptrs[2]=	"  нажатием љ или њ  ";
N        }
N	ptrs[3]=		" Выход              ";
N    ptrs[4]=		"                    ";
N    ptrs[5]=		"                    ";
N
N	bgnd_par(		" КАЛИБРОВКА БАТ. N! ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2]);
X				ptrs[a_ind . i_s+2]);
N     
N   	if(sub_ind==0)
X   	if(a_ind . s_i==0)
N     	{
N     	if(phase==0)
N     		{
N			mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,0xffff,10);
X			mess_send(205,208,0xffff,10);
N     		mess_send(MESS2RELE_HNDL,PARAM_RELE_SAMOKALIBR,1,10);
X     		mess_send(210,100,1,10);
N			mess_send(MESS2BAT_HNDL,PARAM_BAT_MASK_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X			mess_send(200,202,(1<<a_ind . s_i1),10);
N     		//mess_send(MESS2BAT_HNDL1,PARAM_BAT_ON,(1<<(1-sub_ind1)),10);
N     		}
N    	else if(phase==1)
N     		{
N			mess_send(MESS2BPS_HNDL,PARAM_BPS_ALL_OFF_AFTER_2SEC,0xffff,10);
X			mess_send(205,206,0xffff,10);
N			mess_send(MESS2BAT_HNDL,PARAM_BAT_MASK_OFF_AFTER_2SEC,(1<<(1-sub_ind1)),10);
X			mess_send(200,202,(1<<(1-a_ind . s_i1)),10);
N     		//mess_send(MESS2BAT_HNDL1,PARAM_BAT_ON,(1<<sub_ind1),10);
N   			}
N     		
N     	}
N
N	
N	if((sub_ind==0)||(sub_ind==1)||(sub_ind==2))index_set=0;
X	if((a_ind . s_i==0)||(a_ind . s_i==1)||(a_ind . s_i==2))a_ind . i_s=0;
N	else index_set=3;
X	else a_ind . i_s=3;
N
N	pointer_set(1);	
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd_mmm(bat[sub_ind1]._Ib,'#',2);
X	int2lcd_mmm(bat[a_ind . s_i1]._Ib,'#',2);
N
N	}  	
N
Nelse if(ind==iK_bat_ips_termokompensat_ib)
Xelse if(a_ind . i==iK_bat_ips_termokompensat_ib)
N	{
N     ptrs[0]=		" Iбат =     #А      ";
N     ptrs[1]=		" откалибруйте Iбат  ";
N     ptrs[2]=		"  нажатием љ или њ  ";
N     ptrs[3]=		" Выход              ";
N     ptrs[4]=		"                    ";
N     ptrs[5]=		"                    ";
N
N	bgnd_par(		" КАЛИБРОВКА БАТ. N1 ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2]);
X				ptrs[a_ind . i_s+2]);
N     
N
N	if((sub_ind==0)||(sub_ind==1)||(sub_ind==2))index_set=0;
X	if((a_ind . s_i==0)||(a_ind . s_i==1)||(a_ind . s_i==2))a_ind . i_s=0;
N	else if((sub_ind==3)||(sub_ind==4)||(sub_ind==5))index_set=3;
X	else if((a_ind . s_i==3)||(a_ind . s_i==4)||(a_ind . s_i==5))a_ind . i_s=3;
N	
N
N
N	pointer_set(1);	
N	
N	if(bIBAT_SMKLBR)sub_bgnd("КЛБР. ",'#',-4);
N	else int2lcd_mmm(Ib_ips_termokompensat,'#',2);
N
N	
N	}  	
N
N  
N
Nelse if(ind==iInv_set)
Xelse if(a_ind . i==iInv_set)
N	{
N	ptrs[0]=						" Минимальное напр.  ";
N     ptrs[1]=						" выхода          <В ";
N     ptrs[2]=						" Максимальное напр. ";
N	ptrs[3]=						" выхода          >В ";
N	ptrs[4]=					  	" Выход              ";
N	ptrs[5]=						"                    ";
N	ptrs[6]=						"                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("    ИНВЕРТОР N!     ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("    ИНВЕРТОР N!     ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd(inv[sub_ind1]._Uoutmin,'<',0);
X	int2lcd(inv[a_ind . s_i1]._Uoutmin,'<',0);
N	int2lcd(inv[sub_ind1]._Uoutmax,'>',0);
X	int2lcd(inv[a_ind . s_i1]._Uoutmax,'>',0);
N	}     
N
Nelse if(ind==iK_makb_sel)
Xelse if(a_ind . i==iK_makb_sel)
N	{
N	ptrs[0]=						" Монитор АКБ N1     ";
N     ptrs[1]=						" Монитор АКБ N2     ";
N     ptrs[2]=						" Монитор АКБ N3     ";
N	ptrs[3]=						" Монитор АКБ N4     ";
N	ptrs[NUMMAKB]=					" Выход              ";
N	ptrs[1+NUMMAKB]=				"                    ";
N	ptrs[2+NUMMAKB]=				"                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("КАЛИБРОВАТЬ МОНИТОРЫ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("КАЛИБРОВАТЬ МОНИТОРЫ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N     }     
N
Nelse if(ind==iK_makb)
Xelse if(a_ind . i==iK_makb)
N	{
N	ptrs[0]=						" U1  =    !В        ";
N	ptrs[1]=						" U2  =    @В        ";
N	ptrs[2]=						" U3  =    #В        ";
N	ptrs[3]=						" U4  =    $В        ";
N	ptrs[4]=						" U5  =    %В        ";
N	ptrs[5]=						" t1  =    ^°C       ";
N	ptrs[6]=						" t2  =    &°C       ";
N	ptrs[7]=						" t3  =    *°C       ";
N	ptrs[8]=						" t4  =    (°C       ";
N	ptrs[9]=						" t5  =    )°C       ";
N	ptrs[10]=						" Выход              ";
N	ptrs[11]=						"                    ";
N
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     КАЛИБРОВКА     ","   МОНИТОР АКБ N<   ",ptrs[index_set],ptrs[index_set+1]);
X	bgnd_par("     КАЛИБРОВКА     ","   МОНИТОР АКБ N<   ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1]);
N	pointer_set(2);
N	simax=10;
N
N	int2lcd(sub_ind1+1,'<',0);
X	int2lcd(a_ind . s_i1+1,'<',0);
N	int2lcd(makb[sub_ind1]._U[0],'!',1);
X	int2lcd(makb[a_ind . s_i1]._U[0],'!',1);
N	int2lcd(makb[sub_ind1]._U[1],'@',1);
X	int2lcd(makb[a_ind . s_i1]._U[1],'@',1);
N	int2lcd(makb[sub_ind1]._U[2],'#',1);
X	int2lcd(makb[a_ind . s_i1]._U[2],'#',1);
N	int2lcd(makb[sub_ind1]._U[3],'$',1);
X	int2lcd(makb[a_ind . s_i1]._U[3],'$',1);
N	int2lcd(makb[sub_ind1]._U[4],'%',1);
X	int2lcd(makb[a_ind . s_i1]._U[4],'%',1);
N
N	if(makb[sub_ind1]._T_nd[0])sub_bgnd("НЕПОДКЛЮЧЕН",'^',-5);
X	if(makb[a_ind . s_i1]._T_nd[0])sub_bgnd("НЕПОДКЛЮЧЕН",'^',-5);
N	else int2lcd_mmm(makb[sub_ind1]._T[0],'^',0); 
X	else int2lcd_mmm(makb[a_ind . s_i1]._T[0],'^',0); 
N	if(makb[sub_ind1]._T_nd[1])sub_bgnd("НЕПОДКЛЮЧЕН",'&',-5);
X	if(makb[a_ind . s_i1]._T_nd[1])sub_bgnd("НЕПОДКЛЮЧЕН",'&',-5);
N	else int2lcd_mmm(makb[sub_ind1]._T[1],'&',0); 
X	else int2lcd_mmm(makb[a_ind . s_i1]._T[1],'&',0); 
N	if(makb[sub_ind1]._T_nd[2])sub_bgnd("НЕПОДКЛЮЧЕН",'*',-5);
X	if(makb[a_ind . s_i1]._T_nd[2])sub_bgnd("НЕПОДКЛЮЧЕН",'*',-5);
N	else int2lcd_mmm(makb[sub_ind1]._T[2],'*',0); 
X	else int2lcd_mmm(makb[a_ind . s_i1]._T[2],'*',0); 
N	if(makb[sub_ind1]._T_nd[3])sub_bgnd("НЕПОДКЛЮЧЕН",'(',-5);
X	if(makb[a_ind . s_i1]._T_nd[3])sub_bgnd("НЕПОДКЛЮЧЕН",'(',-5);
N	else int2lcd_mmm(makb[sub_ind1]._T[3],'(',0); 
X	else int2lcd_mmm(makb[a_ind . s_i1]._T[3],'(',0); 
N	if(makb[sub_ind1]._T_nd[4])sub_bgnd("НЕПОДКЛЮЧЕН",')',-5);
X	if(makb[a_ind . s_i1]._T_nd[4])sub_bgnd("НЕПОДКЛЮЧЕН",')',-5);
N	else int2lcd_mmm(makb[sub_ind1]._T[4],')',0); 
X	else int2lcd_mmm(makb[a_ind . s_i1]._T[4],')',0); 
N
N
N/*	int2lcd(makb[sub_ind1]._T[0],'^',0);
N	int2lcd(makb[sub_ind1]._T[1],'&',0);
N	int2lcd(makb[sub_ind1]._T[2],'*',0);
N	int2lcd(makb[sub_ind1]._T[3],'(',0);
N	int2lcd(makb[sub_ind1]._T[4],')',0);*/
N	
N     }   
N
Nelse if(ind==iK_bps_sel)
Xelse if(a_ind . i==iK_bps_sel)
N	{
N	ptrs[0]=						" БПС N1             ";
N    ptrs[1]=						" БПС N2             ";
N    ptrs[2]=						" БПС N3             ";
N	ptrs[3]=						" БПС N4             ";
N    ptrs[4]=						" БПС N5             ";
N    ptrs[5]=						" БПС N6             ";
N	ptrs[6]=						" БПС N7             ";
N    ptrs[7]=						" БПС N8             ";
N    ptrs[8]=						" БПС N9             ";
N	ptrs[9]=						" БПС N10            ";
N    ptrs[10]=						" БПС N11            ";
N    ptrs[11]=						" БПС N12            ";
N    ptrs[12]=						" БПС N13            ";
N	ptrs[13]=						" БПС N14            ";
N    ptrs[14]=						" БПС N15            ";
N    ptrs[15]=						" БПС N16            ";
N	ptrs[16]=						" БПС N17            ";
N    ptrs[17]=						" БПС N18            ";
N    ptrs[18]=						" БПС N19            ";
N	ptrs[19]=						" БПС N20            ";
N    ptrs[20]=						" БПС N21            ";
N    ptrs[21]=						" БПС N22            ";	               
N	ptrs[NUMIST]=					" Выход              ";
N	ptrs[1+NUMIST]=				"                    ";
N	ptrs[2+NUMIST]=				"                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("  КАЛИБРОВКА БПСов  ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("  КАЛИБРОВКА БПСов  ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N     }     
N
Nelse if(ind==iK_bps)
Xelse if(a_ind . i==iK_bps)
N	{
N	
N	ptrs[0]=" Uист =    @В       ";
N    ptrs[1]=" откалибруйте Uист  ";
N	ptrs[2]="  нажатием љ или њ  "; 
N	ptrs[3]=" Uшины =   #В       ";
N    ptrs[4]=" откалибруйте Uнагр ";
N    ptrs[5]="  нажатием љ или њ  ";
N	ptrs[6]=" Uавтон =   $В      ";
N	if(bFL_)
N		{
N		ptrs[7]=" установите Uавтон  ";
N     	ptrs[8]="  нажатием љ или њ  ";
N     	}
N    else 
N     	{
N		ptrs[7]=" удерживайте ¤ для  ";
N     	ptrs[8]="    запоминания     ";     	
N     	}	
N	ptrs[9]=" Iист =     %А      ";
N	if(phase==0)
N    	{
N        ptrs[10]=	"   нажмите ¤ для    ";
N        ptrs[11]=	"калибровки нуля Iист";
N        }
N    else
N     	{
N        ptrs[10]=" откалибруйте Iист  ";
N        ptrs[11]="  нажатием љ или њ  ";     	
N     	} 
N     	
N    ptrs[12]=" tист =   ^°C       ";    
N	ptrs[13]=" откалибруйте tист  ";
N    ptrs[14]="  нажатием љ или њ  ";
N	ptrs[15]=" Uвых  =    &В      ";
N    ptrs[16]=" откалибруйте Uвых  ";
N	ptrs[17]="  нажатием љ или њ  ";
N    ptrs[18]=sm_exit;
N    ptrs[19]=sm_;
N    ptrs[20]=sm_;     	     	    
N	
N
N    if((sub_ind==0)||(sub_ind==1)||(sub_ind==2))index_set=0;
X    if((a_ind . s_i==0)||(a_ind . s_i==1)||(a_ind . s_i==2))a_ind . i_s=0;
N	else if((sub_ind==3)||(sub_ind==4)||(sub_ind==5))index_set=3;
X	else if((a_ind . s_i==3)||(a_ind . s_i==4)||(a_ind . s_i==5))a_ind . i_s=3;
N	else if((sub_ind==6)||(sub_ind==7)||(sub_ind==8))index_set=6;
X	else if((a_ind . s_i==6)||(a_ind . s_i==7)||(a_ind . s_i==8))a_ind . i_s=6;
N	else if((sub_ind==9)||(sub_ind==10)||(sub_ind==11))index_set=9;
X	else if((a_ind . s_i==9)||(a_ind . s_i==10)||(a_ind . s_i==11))a_ind . i_s=9;
N	else if((sub_ind==12)||(sub_ind==13)||(sub_ind==14))index_set=12;
X	else if((a_ind . s_i==12)||(a_ind . s_i==13)||(a_ind . s_i==14))a_ind . i_s=12;
N	else if((sub_ind==15)||(sub_ind==16)||(sub_ind==17))index_set=15;	
X	else if((a_ind . s_i==15)||(a_ind . s_i==16)||(a_ind . s_i==17))a_ind . i_s=15;	
N	else index_set=18;
X	else a_ind . i_s=18;
N	
N	bgnd_par(" КАЛИБРОВКА БПС N! ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par(" КАЛИБРОВКА БПС N! ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd(bps[sub_ind1]._Uii,'@',1);
X	int2lcd(bps[a_ind . s_i1]._Uii,'@',1);
N	int2lcd(bps[sub_ind1]._Uin,'#',1);
X	int2lcd(bps[a_ind . s_i1]._Uin,'#',1);
N	int2lcd(U_AVT,'$',1);
N	int2lcd(bps[sub_ind1]._Ii,'%',1);
X	int2lcd(bps[a_ind . s_i1]._Ii,'%',1);
N	int2lcd(bps[sub_ind1]._Ti,'^',0); 
X	int2lcd(bps[a_ind . s_i1]._Ti,'^',0); 
N	int2lcd(bps[sub_ind1]._Uisum,'&',1);
X	int2lcd(bps[a_ind . s_i1]._Uisum,'&',1);
N	 
N	
N    if((sub_ind==0)||(sub_ind==3))
X    if((a_ind . s_i==0)||(a_ind . s_i==3))
N		{
N		mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X		mess_send(205,208,(1<<a_ind . s_i1),10);
N		mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,10);
X		mess_send(200,201,0,10);
N	    mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,2000,10);
X	    mess_send(225,229,2000,10);
N        }
N  	if(sub_ind==6)
X  	if(a_ind . s_i==6)
N		{
N        mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X        mess_send(205,208,(1<<a_ind . s_i1),10);
N        mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,40);
X        mess_send(200,201,0,40);
N        mess_send(MESS2UNECC_HNDL,PARAM_UNECC_SET,U_AVT,10);
X        mess_send(190,191,U_AVT,10);
N	   	mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_FAST_REG,0,10);
X	   	mess_send(225,230,0,10);
N		}
N
N    if(sub_ind==9)
X    if(a_ind . s_i==9)
N		{
N		if(phase==0)
N			{
N          	mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,~(1<<sub_ind1),10);
X          	mess_send(205,208,~(1<<a_ind . s_i1),10);
N          	}
N      	else if(phase==1)
N			{
N          	mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X          	mess_send(205,208,(1<<a_ind . s_i1),10);
N			mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,10);
X			mess_send(200,201,0,10);
N          	}
N       	mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,2000,10);
X       	mess_send(225,229,2000,10);
N        }
N	
N    if(sub_ind==12)
X    if(a_ind . s_i==12)
N		{
N        }	
N
N    if(sub_ind==15)
X    if(a_ind . s_i==15)
N		{
N		mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X		mess_send(205,208,(1<<a_ind . s_i1),10);
N		mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,10);
X		mess_send(200,201,0,10);
N	    mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,2000,10);
X	    mess_send(225,229,2000,10);
N        }          
N          
N	if(mess_find( (MESS2IND_HNDL)) && (mess_data[0]==PARAM_U_AVT_GOOD) )
X	if(mess_find( (215)) && (mess_data[0]==217) )
N		{
N		show_mess("     Установка      ",
N	          	"    напряжения      ",
N	          	" автономной работы  ",
N	          	"    произведена     ",3000);
N		}	     
N	     
N	//MSG_IND2PWM_SRC1=900;
N	//MSG_IND2PWM_SRC2=900;         
N/*int2lcdyx(sub_ind1,0,0,0);
Nint2lcdyx(sub_ind,0,1,0);
Nint2lcdyx(phase,0,2,0);
Nint2lcdyx(MSG_IND2OUT_DIS_SRC1,0,3,0);
Nint2lcdyx(MSG_IND2OUT_DIS_SRC2,0,4,0);  
Nint2lcdyx(MSG_IND2OUT_EN_SRC1,0,5,0);
Nint2lcdyx(MSG_IND2OUT_EN_SRC2,0,6,0); */
N
N//int2lcdyx(cntrl_stat1,0,19,0); 
N//int2lcdyx(load_U,0,5,0); 
N//int2lcdyx(cntrl_stat,0,10,0); 
N//int2lcdyx(bps[sub_ind1]._rotor,0,19,0); 
N//int2lcdyx(u_necc,0,19,0);  
N	 }
N
N
Nelse if(ind==iRele_set)
Xelse if(a_ind . i==iRele_set)
N	{
N	ptrs[0]=				" Реле N1            ";
N    ptrs[1]=				" Реле N2            ";
N    ptrs[2]=				" Реле N3            ";
N	ptrs[3]=				" Реле N4            ";
N	ptrs[4]=				" Выход              ";
N	ptrs[5]=				"                    ";
N	ptrs[6]=				"                    ";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(	"   НАСТРОЙКА РЕЛЕ   ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2]);
X				ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N     }     
N
Nelse if(ind==iRele_set_)
Xelse if(a_ind . i==iRele_set_)
N	{
N	
N	ptrs[0]=	" Авария модуля     @";
N    ptrs[1]=	" Пергрузка системы  ";
N	ptrs[2]=	"  по току          #"; 
N	ptrs[3]=	" Перегрев системы  $";
N    ptrs[4]=	" Uвых. занижено    %";
N    ptrs[5]=	" Uвых. завышено    ^";
N	ptrs[6]=	" Uвх. занижено     [";
N	ptrs[7]=	" Uвх. завышено     ]";
N	ptrs[8]=	" Ресурс вентилятора ";
N	ptrs[9]=	"  израсходован     {";
N	ptrs[10]=	" Uв.д. > 2В        }";
N    ptrs[11]=	sm_exit;
N    ptrs[12]=	sm_;
N    ptrs[13]=	sm_;     	     	    
N	
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	
N	bgnd_par(	" Реле N! срабатыв. ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1],
X				ptrs[a_ind . i_s+1],
N				ptrs[index_set+2]);
X				ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	
N
N	int2lcd(sub_ind1+1,'!',0); 
X	int2lcd(a_ind . s_i1+1,'!',0); 
N 	checkboxing('@',RELE_SET_MASK[sub_ind1]&(1<<0));
X 	checkboxing('@',RELE_SET_MASK[a_ind . s_i1]&(1<<0));
N	checkboxing('#',RELE_SET_MASK[sub_ind1]&(1<<1));
X	checkboxing('#',RELE_SET_MASK[a_ind . s_i1]&(1<<1));
N 	checkboxing('$',RELE_SET_MASK[sub_ind1]&(1<<2));
X 	checkboxing('$',RELE_SET_MASK[a_ind . s_i1]&(1<<2));
N	checkboxing('%',RELE_SET_MASK[sub_ind1]&(1<<3));
X	checkboxing('%',RELE_SET_MASK[a_ind . s_i1]&(1<<3));
N 	checkboxing('^',RELE_SET_MASK[sub_ind1]&(1<<4));
X 	checkboxing('^',RELE_SET_MASK[a_ind . s_i1]&(1<<4));
N	checkboxing('[',RELE_SET_MASK[sub_ind1]&(1<<5));
X	checkboxing('[',RELE_SET_MASK[a_ind . s_i1]&(1<<5));
N 	checkboxing(']',RELE_SET_MASK[sub_ind1]&(1<<6));
X 	checkboxing(']',RELE_SET_MASK[a_ind . s_i1]&(1<<6));
N	checkboxing('{',RELE_SET_MASK[sub_ind1]&(1<<7));
X	checkboxing('{',RELE_SET_MASK[a_ind . s_i1]&(1<<7));
N	checkboxing('}',RELE_SET_MASK[sub_ind1]&(1<<8));
X	checkboxing('}',RELE_SET_MASK[a_ind . s_i1]&(1<<8));
N	
N	//int2lcdyx(lc640_read_int(ADR_EE_RELE_SET_MASK[sub_ind1]),0,19,0);
N	//int2lcdyx(RELE_SET_MASK[sub_ind1],0,12,0);
N	//int2lcdyx(sub_ind1,0,2,0);  
N	}
N
N
Nelse if(ind==iK_power_net)
Xelse if(a_ind . i==iK_power_net)
N	{
N	ptrs[0]=" Uввод=    @В       ";
N	ptrs[1]=" Uпэс =    #В       ";
N     ptrs[2]=" Выход              ";
N	ptrs[3]="                    ";
N	
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par( "      КАЛИБРОВКА    ",
N               "   СИЛОВЫХ ВВОДОВ   ",
N               ptrs[index_set],
X               ptrs[a_ind . i_s],
N               ptrs[index_set+1]);
X               ptrs[a_ind . i_s+1]);
N
N	pointer_set(2);	
N	int2lcd(Uvv[0],'@',0);
N     int2lcd(Uvv[1],'#',0);
N	//int2lcdyx(net_buff_,3,10,0);
N	
N	//int2lcdyx(Kunet,3,16,0);
N     }
N
N
Nelse if(ind==iK_power_net3)
Xelse if(a_ind . i==iK_power_net3)
N	{
N     ptrs[0]=  		" Ввод ф.A    !В     ";
N	ptrs[1]=  		" Ввод ф.B    @В     ";
N	ptrs[2]=  		" Ввод ф.C    #В     ";
N     ptrs[3]=  	     " ПЭС  ф.A    &В     ";
N     ptrs[4]=  	     " ПЭС  ф.B    *В     ";
N     ptrs[5]=  	     " ПЭС  ф.C    (В     ";		            
N     ptrs[6]=" Выход              ";
N	ptrs[7]="                    ";
N	
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par( "      КАЛИБРОВКА    ",
N               "   СИЛОВЫХ ВВОДОВ   ",
N               ptrs[index_set],
X               ptrs[a_ind . i_s],
N               ptrs[index_set+1]);
X               ptrs[a_ind . i_s+1]);
N
N	pointer_set(2);	
N	int2lcd(Uvv_eb2[0],'!',0);
N	int2lcd(Uvv_eb2[1],'@',0);
N	int2lcd(Uvv_eb2[2],'#',0);
N	int2lcd(Upes_eb2[0],'&',0);
N	int2lcd(Upes_eb2[1],'*',0);
N	int2lcd(Upes_eb2[2],'(',0);
N	//int2lcdyx(net_buff_,3,10,0);
N	
N	//int2lcdyx(Kunet,3,16,0);
N     }
N
N
N#endif	 
N			
Nif(ind==iDeb)
Xif(a_ind . i==iDeb)
N     {
N     if(sub_ind==0)
X     if(a_ind . s_i==0)
N     	{
N
N
N        bgnd_par("*0000*000000*       ",
N     	         "                    ",
N     	         "                    ",
N     	         "      ********      ");
N
N		int2lcdyx(SOFT_NUM,0,4,0);
X		int2lcdyx(1051,0,4,0);
N		long2lcdyx_mmm(SOFT_DATE,0,11,0);
X		long2lcdyx_mmm(21112UL,0,11,0);
N	
N		int2lcdyx(numOfForvardBps_minCnt,1,5,0);
N		int2lcdyx(numOfForvardBps_hourCnt,1,10,0);
N		int2lcdyx(numOfForvardBps,1,15,0);
N	
N		int2lcdyx(numOfForvardBps_minCnt,2,4,0);
N		int2lcdyx(numOfForvardBps_hourCnt,2,9,0);
N		int2lcdyx(cntrl_stat,2,19,0);
N
N      
N
N     	}     
N
N    	else if(sub_ind==1) 
X    	else if(a_ind . s_i==1) 
N     	{
N     	bgnd_par("Б                   ",
N     	         "                    ",
N     	         "                    ",
N     	         "                    ");
N
N		//int2lcdyx(bAVG,0,0,0);
N		//int2lcdyx(LPC_CAN1->GSR,0,6,0);
N		//int2lcdyx((LPC_CAN1->GSR)>>16,0,16,0);
N		//int2lcdyx(avg,0,19,0);
N
N				//int2lcdyx((((LPC_CAN1->GSR)&(0xff000000))>>24),0,19,0);
N		//int2lcdyx((((LPC_CAN1->GSR)&(0x00ff0000))>>16),0,15,0);
N
N /*         int2lcdyx(bat[0]._Ubm,1,7,0); 	int2lcdyx(bat[0]._av,1,10,0);
N		int2lcdyx(bat[0]._dUbm,2,7,0);
N		int2lcdyx(bat[0]._cnt_as,3,7,0);
N		
N 
N		int2lcdyx(bat[1]._Ub,0,14,0);
N          int2lcdyx(bat[1]._Ubm,1,14,0);	int2lcdyx(bat[1]._av,1,17,0);
N		int2lcdyx(bat[1]._dUbm,2,14,0);
N		int2lcdyx(bat[1]._cnt_as,3,14,0);*/
N
N		int2lcdyx(sub_ind1+0,1,0,0);
X		int2lcdyx(a_ind . s_i1+0,1,0,0);
N		int2lcdyx(sub_ind1+1,2,0,0);
X		int2lcdyx(a_ind . s_i1+1,2,0,0);
N		int2lcdyx(sub_ind1+2,3,0,0);
X		int2lcdyx(a_ind . s_i1+2,3,0,0);
N		
N		
N		int2lcdyx(bps[sub_ind1  ]._cnt,1,2,0);
X		int2lcdyx(bps[a_ind . s_i1  ]._cnt,1,2,0);
N		int2lcdyx(bps[sub_ind1+1]._cnt,2,2,0);
X		int2lcdyx(bps[a_ind . s_i1+1]._cnt,2,2,0);
N		int2lcdyx(bps[sub_ind1+2]._cnt,3,2,0);		
X		int2lcdyx(bps[a_ind . s_i1+2]._cnt,3,2,0);		
N		
N	/*	int2lcdyx(bps[sub_ind1  ]._ist_blok_cnt,1,5,0);
N		int2lcdyx(bps[sub_ind1+1]._ist_blok_cnt,2,5,0);
N		int2lcdyx(bps[sub_ind1+2]._ist_blok_cnt,3,5,0);*/			
N		
N	/*	char2lcdhyx(bps[sub_ind1  ]._flags_tu,1,8);
N		char2lcdhyx(bps[sub_ind1+1]._flags_tu,2,8);
N		char2lcdhyx(bps[sub_ind1+2]._flags_tu,3,8);
N
N		int2lcdyx(bps[sub_ind1  ]._vol_u,1,12,0);
N		int2lcdyx(bps[sub_ind1+1]._vol_u,2,12,0);
N		int2lcdyx(bps[sub_ind1+2]._vol_u,3,12,0);		
N
N
N		char2lcdhyx(bps[sub_ind1]._flags_tm,1,15);
N		char2lcdhyx(bps[sub_ind1+1]._flags_tm,2,15);
N		char2lcdhyx(bps[sub_ind1+2]._flags_tm,3,15);	
N		*/
N		int2lcdyx(bps[sub_ind1]._Ii,1,15,0);
X		int2lcdyx(bps[a_ind . s_i1]._Ii,1,15,0);
N		int2lcdyx(bps[sub_ind1+1]._Ii,2,15,0);
X		int2lcdyx(bps[a_ind . s_i1+1]._Ii,2,15,0);
N		int2lcdyx(bps[sub_ind1+2]._Ii,3,15,0);
X		int2lcdyx(bps[a_ind . s_i1+2]._Ii,3,15,0);
N	/*
N		char2lcdhyx(bps[sub_ind1]._rotor>>8,1,15);
N		char2lcdhyx(bps[sub_ind1+1]._rotor>>8,2,15);
N		char2lcdhyx(bps[sub_ind1+2]._rotor>>8,3,15);		
N		*/
N		
N		int2lcdyx(bps[sub_ind1]._rotor,1,19,0);
X		int2lcdyx(bps[a_ind . s_i1]._rotor,1,19,0);
N		int2lcdyx(bps[sub_ind1+1]._rotor,2,19,0);
X		int2lcdyx(bps[a_ind . s_i1+1]._rotor,2,19,0);
N		int2lcdyx(bps[sub_ind1+2]._rotor,3,19,0);
X		int2lcdyx(bps[a_ind . s_i1+2]._rotor,3,19,0);
N
N
N 		}
N
N 
N
N    else if(sub_ind==2)
X    else if(a_ind . s_i==2)
N     	{
N     	bgnd_par(	"F                   ",
N     		    	"                    ",
N     		    	"                    ",
N     		    	"                    ");
N
N
N		int2lcdyx(uout_av,1,5,0);
N		int2lcdyx(USIGN,2,5,0); 
N
N		int2lcdyx(bSILENT,3,5,0);
N
N		
N		
N		int2lcdyx(U_OUT_KONTR_MAX,0,19,0);
N		int2lcdyx(load_U,1,19,0);
N		int2lcdyx(U_OUT_KONTR_MIN,2,19,0);
N		//int2lcdyx(U_OUT_KONTR_DELAY,3,19,0);
N		int2lcdyx(outVoltContrHndlCnt,3,19,0);
N
N		long2lcdhyx(0x12345678UL,1,14);
N		long2lcdhyx(avar_stat,2,14);
N		long2lcdhyx(avar_ind_stat,3,14);
N		}  
N
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N     	{
N     	bgnd_par("КЕ                  ",
N     	         "                    ",
N     	         "                   ^",
N     	         "                   &");
N
N/*	int2lcdyx(spc_stat,0,5,0);
N	int2lcdyx(__ee_spc_stat,0,9,0);
N	int2lcdyx(lc640_read_int(EE_SPC_STAT),0,13,0);
N
N	int2lcdyx(spc_bat,1,5,0);
N	int2lcdyx(__ee_spc_bat,1,9,0);
N	int2lcdyx(lc640_read_int(EE_SPC_BAT),1,13,0);
N
N	int2lcdyx(bat_u_old_cnt,0,19,0);
N	
N	
N	int2lcdyx(bat[0]._zar_cnt_ke,2,5,0);
N	int2lcdyx(lc640_read_int(ADR_EE_BAT_ZAR_CNT_KE[0]),2,10,0);	
N	int2lcdyx(bat[0]._u_old[0],2,14,0);
N	int2lcd_mmm(bat[0]._Ib,'^',2);
N
N	int2lcdyx(bat[1]._zar_cnt_ke,3,5,0);
N	int2lcdyx(lc640_read_int(ADR_EE_BAT_ZAR_CNT_KE[1]),3,10,0);
N	int2lcdyx(bat[1]._Ub,3,14,0);
N	int2lcd_mmm(bat[1]._Ib,'&',2);	
N
N	int2lcdyx(spc_phase,1,15,0);
N	int2lcdyx(__ee_spc_phase,1,17,0);
N	int2lcdyx(lc640_read_int(EE_SPC_PHASE),1,19,0);	*/
N
N/*	int2lcdyx(speedChIsOn,0,4,0);
N	int2lcdyx(speedChTimeCnt,1,4,0);
N	int2lcdyx(speedChrgBlckStat,2,4,0);
N	int2lcdyx(speedChrgBlckSrc,3,4,0);
N
N	int2lcdyx(speedChrgBlckSrc,0,8,0);
N	int2lcdyx(speedChrgBlckLog,1,8,0); */
N	
N	
N		
N
N/*	    		int2lcdyx(adc_net_buff_cnt,0,4,0);
N
N		    	int2lcdyx((short)(main_power_buffer[0]>>12),0,19,0);
N			int2lcdyx((short)(main_power_buffer[1]>>12),1,19,0);
N			int2lcdyx((short)(main_power_buffer[2]>>12),2,19,0);
N			int2lcdyx((short)(main_power_buffer[3]>>12),3,19,0);
N
N		    	int2lcdyx((net_buff_),2,5,0); */
N
N
N		   
N		    
N
N
N/*		int2lcdyx(load_U,0,4,0);
N		int2lcdyx(load_I,1,4,0);
N		lcd_buffer[44]='a';
N		int2lcd_mmm((bat[0]._Ib)/10,'a',1);
N		lcd_buffer[64]='a';
N		int2lcd_mmm((bat[1]._Ib)/10,'a',1);
N
N 		int2lcdyx(u_necc,0,8,0);
N
N		
N		
N		lcd_buffer[14]='.';
N		lcd_buffer[34]='.';
N		int2lcdyx(Isumm,0,15,1);		
N		int2lcdyx(Isumm_,1,15,1);
N
N
N		int2lcdyx(cntrl_stat,0,19,0);
N		int2lcdyx(num_necc,1,19,0);
N		
N		
N		  
N//		int2lcdyx(cntrl_stat,0,15,0);
N		 
N		//int2lcdyx(cntrl_plazma,1,3,0);
N		//lcd_buffer[30]='a';
N		int2lcd_mmm(Ibmax,'a',0);
N		int2lcdyx(IZMAX,1,14,0);
N
N		lcd_buffer[65]='a';
N		int2lcd_mmm(bat[0]._Ib,'a',0);
N
N		lcd_buffer[70]='a';
N		int2lcd_mmm(bat[1]._Ib,'a',0); 
N
N		lcd_buffer[75]='a';
N		int2lcd_mmm(Ibmax,'a',0); 
N
N	//	int2lcdyx(IMAX,2,3,0);
N		
N		
N
N	//	int2lcdyx(IZMAX,3,19,0);
N
N		//int2lcdyx(num_necc_Imax,3,6,0);
N		//int2lcdyx(num_necc_Imin,3,12,0);
N
N
N //    	lcd_buffer[4]='a';            
N //    	int2lcd_mmm(Ibat,'a',1);   int2lcdyx(cntrl_stat,0,9,0);          int2lcdyx(hour_apv_cnt,0,13,0);                             char2lcdhyx(St_[0],0,19);  
N //    	int2lcdyx(Ubat,1,4,0);     int2lcdyx(main_apv_cnt,1,9,0);        int2lcdyx(lc640_read_int(bps1_AVAR_PTR),1,13,0);            char2lcdhyx(St_[1],1,19);
N //    	int2lcdyx(Us[0],2,4,0);  int2lcdyx(apv_cnt_1,2,9,0);           int2lcdyx(lc640_read_int(SRC1_AVAR_CNT),2,13,0);                                     int2lcdhyx(av_stat,2,19);
N //    	int2lcdyx(Us[1],3,4,0);  int2lcdyx(reset_apv_cnt,3,9,0);                                            int2lcdyx(plazma,3,19,0);
N     	//int2lcd(plazma,'(',0);
N
N     	//int2lcd(Us[0],'#',1);
N     	//int2lcd(Us[1],'$',1);
N     	//int2lcd(Is[0],'%',1);
N     	//int2lcd(Is[1],'^',1);
N    // 	int2lcd(bat[0]._Ub,'<',1);
N    // 	int2lcd_mmm(bat[0]._Ib,'>',2);
N //    	char2lcdhyx(St_[0],3,13);
N //    	char2lcdhyx(St_[1],3,19);
N //    	char2lcdhyx(St,3,5);  */
N		}
N
N   else if(sub_ind==4)
X   else if(a_ind . s_i==4)
N     	{
N     	bgnd_par(	"LB                  ",
N     		    	"                    ",
N     		    	"      !   #         ",
N     		    	"      @   $         ");
N
N
N     	int2lcdyx(NUMBAT_TELECORE,0,1,0);
N		
N		int2lcdyx(bps[0]._Ii,0,5,0);
N		int2lcdyx(bps[1]._Ii,0,9,0);
N		
N		int2lcdyx(plazma_cntrl_stat,0,19,0);
N		
N		int2lcdyx(Ubpsmax,1,3,0);
N		int2lcdyx(Ibmax,1,7,0);
N		int2lcdyx(cntrl_stat,1,11,0);
N		int2lcdyx(load_U,1,19,0);
N			
N		int2lcdyx(lakb[0]._balanced_event_code/*_tot_bat_volt*/,2,2,0);
N	   	int2lcdyx(lakb[1]._balanced_event_code/*_tot_bat_volt*/,3,2,0);
N		
N	 	int2lcd_mmm(lakb[0]._ch_curr/10,'!',0);
N		int2lcd_mmm(lakb[1]._ch_curr/10,'@',0);		
N		
N	 	int2lcd_mmm(bat[0]._Ib/10,'#',0);
N		int2lcd_mmm(bat[1]._Ib/10,'$',0);
N
N//		int2lcdyx(TELECORE2017_ULINECC,2,19,0);
N//	   	int2lcdyx(TELECORE2017_ULINECC_,3,19,0);
N
N		//int2lcdyx(lakb[0]._communicationFullErrorStat,2,19,0);
N	   	//int2lcdyx(lakb[1]._communicationFullErrorStat,3,19,0);
N
N		int2lcdyx(IMAX,0,13,0);
N		
N		int2lcdyx(lakb[0]._voltage_event_code,2,15,0); 
N		int2lcdyx(lakb[1]._voltage_event_code,3,15,0);
N
N
N
N		//int2lcdyx(load_I,2,17,0); 
N		//int2lcdyx(Isumm,3,17,0);
N
N		//int2lcdyx(lakb[0]._s_o_c_percent,2,17,0); 
N		//int2lcdyx(lakb[1]._s_o_c_percent,3,17,0);
N
N
N		
N
N
N
N
N		
N		//int2lcdyx(u_necc,1,15,0);
N		
N
N		//int2lcdyx(plazma_ztt[0],1,13,0);lakb[i]._communicationFullErrorStat
N		//int2lcdyx(plazma_ztt[1],1,17,0);
N 		//int2lcdyx(zTTBatteryHndlCmnd/*zTTBatteryHndlPhase*/,0,5,0);
N
N		//int2lcdyx(zTTButteryCnter,0,7,0);
N
N		//int2lcdyx(numOfPacks,0,9,0);
N
N		//int2lcdyx(numOfTemperCells,0,12,0);
N		//t2lcdyx(cntrl_stat_blck_cnt,0,6,0);
N		 
N		//int2lcdyx(ch_cnt0,0,13,0);
N		//int2lcdyx(ch_cnt1,0,16,0);
N		//int2lcdyx(bat[0]._Ib,0,9,0);
N		//int2lcdyx(bat[1]._Ib,0,15,0);
N		}
N/*	else if(sub_ind==4)
N     	{
N     	bgnd_par(" АВАРИИ             ",
N     	         "                    ",
N     	         "                    ",
N     	         "                    ");
N
N		int2lcdyx(main_10Hz_cnt,0,7,0);
N		int2lcdyx(bat[0]._av,0,10,0);
N		int2lcdyx(bat[1]._av,0,12,0);
N		char2lcdhyx(rele_stat,0,19);
N
N 		long2lcdhyx(avar_stat,1,7);
N		long2lcdhyx(avar_stat_old,2,7);
N		long2lcdhyx(avar_ind_stat,3,7);
N
N		long2lcdhyx(avar_stat_new,2,19);
N		long2lcdhyx(avar_stat_offed,3,19);
N
N
N
N		}*/
N 
N    else if(sub_ind==5)
X    else if(a_ind . s_i==5)
N     	{
N     	bgnd_par(	"*                   ",
N     		    	"                    ",
N     		    	"                    ",
N     		    	"                    ");
N
N		int2lcdyx(adc_buff_[0],0,4,0);
N		int2lcdyx(adc_buff_[1],1,4,0);
N		int2lcdyx(adc_buff_[2],2,4,0);
N		int2lcdyx(adc_buff_[3],3,4,0);
N		int2lcdyx(adc_buff_[4],0,9,0);
N		int2lcdyx(adc_buff_[5],1,9,0);
N		int2lcdyx(adc_buff_[6],2,9,0);
N		int2lcdyx(adc_buff_[7],3,9,0);
N		int2lcdyx(adc_buff_[8],0,14,0);
N		int2lcdyx(adc_buff_[9],1,14,0);
N		int2lcdyx(adc_buff_[10],2,14,0);
N		int2lcdyx(adc_buff_[11],3,14,0);
N		int2lcdyx(adc_buff_[12],0,19,0);
N		int2lcdyx(adc_buff_[13],1,19,0);
N		int2lcdyx(adc_buff_[14],2,19,0);
N		int2lcdyx(adc_buff_[15],3,19,0);
N
N
N
N	/*	int2lcdyx(main_kb_cnt,0,3,0);
N		int2lcdyx(cntrl_stat,1,3,0);
N		int2lcdyx(ibat_ips,2,3,0);
N		int2lcdyx(ibat_ips_,3,3,0);
N
N		int2lcdyx(kb_cnt_1lev,0,19,0);
N		int2lcdyx(kb_cnt_2lev,1,19,0);
N		int2lcdyx(kb_full_ver,2,19,0);
N
N		int2lcdyx(Ibmax,0,16,0);
N		int2lcdyx(IZMAX_,1,16,0);
N		int2lcdyx(cntrl_hndl_plazma,2,16,0); */
N
N		
N    	}  		  		
N
N
N  else if(sub_ind==6)
X  else if(a_ind . s_i==6)
N     	{
N     	bgnd_par(	"6                   ",
N     		    	"    !     $         ",
N     		    	"    @     %         ",
N     		    	"            ^       ");
N#ifdef UKU_TELECORE2017     		    
S/*		int2lcd_mmm(bat[0]._Ib,'!',2);
S		int2lcd_mmm(bat[1]._Ib,'@',2);
S		int2lcd_mmm(bps[0]._Ii,'$',1);
S		int2lcd_mmm(bps[1]._Ii,'%',1);
S		int2lcd_mmm(bps[2]._Ii,'^',1); */
S
S		int2lcd_mmm(t_ext[0],'!',0);
S		int2lcd_mmm(t_ext[1],'@',0);
S		int2lcd_mmm(t_box_warm,'$',0);
S		int2lcd_mmm(t_box_vent,'%',0);
S		//int2lcdyx(load_I,3,7,0);
S		//int2lcdyx(t_box_vent,2,7,0);
S
S		int2lcdyx(warm_stat_k,1,19,0);
S		int2lcdyx(vent_stat_k,2,19,0);
S		
S
S		int2lcdyx(TELECORE2017_KLIMAT_WARM_ON_temp,3,3,0);
S		int2lcdyx(TELECORE2017_KLIMAT_WARM_ON,3,7,0);
S		int2lcdyx(TELECORE2017_KLIMAT_WARM_OFF,3,11,0);
S		int2lcdyx(TELECORE2017_INT_VENT_PWM,3,15,0);
S		int2lcdyx(TELECORE2017_EXT_VENT_PWM,3,19,0);
S		
S		
S		
S		//int2lcdyx(li_bat._Tb,3,3,0);
S		
S		
S
S
S		int2lcdyx(t_box_warm_on_cnt,1,17,0);
S		int2lcdyx(t_box_vent_on_cnt,2,17,0);
S//			//int2lcdyx(t_box_vent_on_cnt,0,3,0);
S	//int2lcdyx(t_box_warm_on_cnt,0,7,0);
S//		int2lcdyx(vent_stat_k,2,15,0);
S
S		
S		int2lcdyx(ND_EXT[0],0,9,0);
S		int2lcdyx(ND_EXT[1],0,13,0);
S		//int2lcdyx(TELECORE2017_KLIMAT_VENT_ON20,0,16,0);	 
S		int2lcdyx(lakb[0]._zar_percent,0,19,0);	 
N#endif
N    	}
N
N
N   else if(sub_ind==7)
X   else if(a_ind . s_i==7)
N     	{
N     	bgnd_par("7                   ",
N     		    "                    ",
N     		    "                    ",
N     		    "                    ");
N     		    
N		int2lcdyx(adc_buff_[sk_buff_TELECORE2015[0]],0,19,0);
N		int2lcdyx(adc_buff_[sk_buff_TELECORE2015[1]],1,19,0);
N		int2lcdyx(adc_buff_[sk_buff_TELECORE2015[2]],2,19,0);
N		int2lcdyx(adc_buff_[sk_buff_TELECORE2015[3]],3,19,0);
N		int2lcdyx(sk_cnt[0],0,14,0);
N		int2lcdyx(sk_cnt[1],1,14,0);
N		int2lcdyx(sk_cnt[2],2,14,0);
N		int2lcdyx(sk_cnt[3],3,14,0);
N		int2lcdyx(sk_stat[0],0,10,0);
N		int2lcdyx(sk_stat[1],1,10,0);
N		int2lcdyx(sk_stat[2],2,10,0);
N		int2lcdyx(sk_stat[3],3,10,0);
N
N    		}
N    else if(sub_ind==8)
X    else if(a_ind . s_i==8)
N     	{
N     	bgnd_par("                    ",
N     		    "                    ",
N     		    "                    ",
N     		    "                    ");
N     	int2lcdyx(ibt._T[0],0,2,0);
N		int2lcdyx(ibt._T[1],1,2,0);
N     	int2lcdyx(ibt._T[2],2,2,0);
N		int2lcdyx(ibt._T[3],3,2,0);
N		
N     	int2lcdyx(ibt._nd[0],0,4,0);
N		int2lcdyx(ibt._nd[1],1,4,0);
N     	int2lcdyx(ibt._nd[2],2,4,0);
N		int2lcdyx(ibt._nd[3],3,4,0);	    
N
N     	int2lcdyx(ibt._T_dispers[0],0,7,0);
N		int2lcdyx(ibt._T_dispers[1],1,7,0);
N     	int2lcdyx(ibt._T_dispers[2],2,7,0);
N		int2lcdyx(ibt._T_dispers[3],3,7,0);
N			    
N		int2lcdyx(ibt._avg1,0,19,0);
N		int2lcdyx(ibt._max_dispers_num,1,19,0);
N		int2lcdyx(t_box,3,19,0);
N     	}		     	
N
N    else if(sub_ind==10)
X    else if(a_ind . s_i==10)
N     	{
N     	bgnd_par("LB                  ",
N     		    "                    ",
N     		    "                    ",
N     		    "                    ");
N
N     	int2lcdyx(sub_ind1+1,0,3,0);
X     	int2lcdyx(a_ind . s_i1+1,0,3,0);
N		int2lcdyx(lakb[sub_ind1]._cnt,0,6,0);
X		int2lcdyx(lakb[a_ind . s_i1]._cnt,0,6,0);
N
N		int2lcdyx(lakb[sub_ind1]._max_cell_temp,0,14,0);
X		int2lcdyx(lakb[a_ind . s_i1]._max_cell_temp,0,14,0);
N		int2lcdyx(lakb[sub_ind1]._min_cell_temp,0,19,0);
X		int2lcdyx(lakb[a_ind . s_i1]._min_cell_temp,0,19,0);
N
N		int2lcdyx(lakb[sub_ind1]._max_cell_volt,1,4,0);
X		int2lcdyx(lakb[a_ind . s_i1]._max_cell_volt,1,4,0);
N		int2lcdyx(lakb[sub_ind1]._min_cell_volt,1,9,0);
X		int2lcdyx(lakb[a_ind . s_i1]._min_cell_volt,1,9,0);
N		int2lcdyx(lakb[sub_ind1]._tot_bat_volt,1,14,0);
X		int2lcdyx(lakb[a_ind . s_i1]._tot_bat_volt,1,14,0);
N		int2lcdyx(lakb[sub_ind1]._s_o_h,1,19,0);
X		int2lcdyx(lakb[a_ind . s_i1]._s_o_h,1,19,0);
N
N		int2lcdyx(lakb[sub_ind1]._ch_curr,2,4,0);
X		int2lcdyx(lakb[a_ind . s_i1]._ch_curr,2,4,0);
N		int2lcdyx(lakb[sub_ind1]._dsch_curr,2,9,0);
X		int2lcdyx(lakb[a_ind . s_i1]._dsch_curr,2,9,0);
N		int2lcdyx(lakb[sub_ind1]._rat_cap,2,14,0);
X		int2lcdyx(lakb[a_ind . s_i1]._rat_cap,2,14,0);
N		int2lcdyx(lakb[sub_ind1]._s_o_c,2,19,0);
X		int2lcdyx(lakb[a_ind . s_i1]._s_o_c,2,19,0);
N
N		int2lcdyx(lakb[sub_ind1]._c_c_l_v,3,4,0);
X		int2lcdyx(lakb[a_ind . s_i1]._c_c_l_v,3,4,0);
N		int2lcdyx(lakb[sub_ind1]._r_b_t,3,9,0);
X		int2lcdyx(lakb[a_ind . s_i1]._r_b_t,3,9,0);
N		int2lcdyx(lakb[sub_ind1]._b_p_ser_num,3,14,0);
X		int2lcdyx(lakb[a_ind . s_i1]._b_p_ser_num,3,14,0);
N		//int2lcdyx(lakb[sub_ind1]._bRS485ERR,3,16,0);
N		//int2lcdyx(lakb[sub_ind1]._rs485_cnt,3,19,0); 
N		
N     	}	
N
N    else if(sub_ind==11)
X    else if(a_ind . s_i==11)
N     	{
N     	bgnd_par("LB                  ",
N     		    "                    ",
N     		    "                    ",
N     		    "                    ");
N
N     	int2lcdyx(sub_ind,0,1,0);
X     	int2lcdyx(a_ind . s_i,0,1,0);
N		
N		int2lcdyx(u_necc,0,5,0);
N
N		int2lcdyx(load_U,0,11,0);
N		int2lcdyx(bps[0]._Uin,0,15,0);
N		int2lcdyx(bps[1]._Uii,0,19,0);
N
N		int2lcdyx(li_bat._Ub,1,3,0);
N
N
N		int2lcdyx(lakb[0]._tot_bat_volt,1,8,0);   
N
N		int2lcdyx(cntrl_stat,1,19,0);
N		
N		int2lcdyx(lakb_error_cnt,3,19,0);
N
N
N
N		//int2lcdyx(ccc_plazma[2],3,12,0);
N		//int2lcdyx(ccc_plazma[3],1,16,0);  
N		//int2lcdyx(ccc_plazma[4],2,16,0);  
N		//int2lcdyx(ccc_plazma[5],3,16,0); 
N
N		int2lcdyx(li_bat._canErrorCnt,2,5,0);
N		int2lcdyx(li_bat._canError,2,8,0);
N		int2lcdyx(li_bat._485ErrorCnt,3,5,0);
N		int2lcdyx(li_bat._485Error,3,8,0);
N			
N		/*int2lcdyx(lakb[sub_ind1]._cnt,0,6,0);
N
N		int2lcdyx(lakb[sub_ind1]._max_cell_temp,0,14,0);
N		int2lcdyx(lakb[sub_ind1]._min_cell_temp,0,19,0);
N
N		int2lcdyx(lakb[sub_ind1]._max_cell_volt,1,4,0);
N		int2lcdyx(lakb[sub_ind1]._min_cell_volt,1,9,0);
N		int2lcdyx(lakb[sub_ind1]._tot_bat_volt,1,14,0);
N		int2lcdyx(lakb[sub_ind1]._s_o_h,1,19,0);
N
N		int2lcdyx(lakb[sub_ind1]._ch_curr,2,4,0);
N		int2lcdyx(lakb[sub_ind1]._dsch_curr,2,9,0);
N		int2lcdyx(lakb[sub_ind1]._rat_cap,2,14,0);
N		int2lcdyx(lakb[sub_ind1]._s_o_c,2,19,0);
N
N		int2lcdyx(lakb[sub_ind1]._c_c_l_v,3,4,0);
N		int2lcdyx(lakb[sub_ind1]._r_b_t,3,9,0);
N		int2lcdyx(lakb[sub_ind1]._b_p_ser_num,3,14,0);
N		int2lcdyx(lakb[sub_ind1]._bRS485ERR,3,16,0);
N		 */
N		
N     	}	
N    else if(sub_ind==12)
X    else if(a_ind . s_i==12)
N     	{
N     	bgnd_par(	"ica                 ",
N     		    	"                    ",
N     		    	"                    ",
N     		    	"                    ");
N		int2lcdyx(ica_my_current,1,4,0);
N     	int2lcdyx(ica_your_current,2,4,0);
N     	int2lcdyx(ica_timer_cnt,1,14,0);
N
N
N		int2lcdyx(ica_plazma[0],0,15,0);
N     	int2lcdyx(ica_plazma[1],1,15,0);
N     	int2lcdyx(ica_plazma[2],2,15,0);
N     	int2lcdyx(ica_plazma[3],3,15,0);
N     	int2lcdyx(ica_plazma[4],0,19,0);
N		int2lcdyx(ica_plazma[5],1,19,0);
N     	int2lcdyx(ica_plazma[6],2,19,0);
N     	int2lcdyx(ica_plazma[7],3,19,0);
N
N 
N		int2lcdyx(ica_u_necc+50,0,10,0);
N		int2lcdyx(u_necc,1,10,0);
N
N		int2lcdyx(bps_U,2,10,0);
N
N
N     	//int2lcdyx(ica_plazma[8],3,15,0);
N     	//int2lcdyx(ica_plazma[9],3,19,0); */
N 
N		
N     	}	     			
N     }
N
Nelse if((ind==iAv_view)||(ind==iAv_view_avt))
Xelse if((a_ind . i==iAv_view)||(a_ind . i==iAv_view_avt))
N	{
N//	unsigned short tempUI,tempUI_;
N//    	unsigned long tempUL;
N	
N	bgnd_par(sm_,sm_,sm_,sm_);
N	if(sub_ind==0)
X	if(a_ind . s_i==0)
N		{	
N		if(avar_stat&0x00000001)
N			{
N			bgnd_par(	"    Авария  сети    ",
N				    	"    не устранена    ",
N				    	sm_,sm_); 
N			int2lcd(net_U,']',0);
N			}
N    		else 
N			{
N	    		bgnd_par(	"    Авария  сети    ",
N	    				"     устранена      ",
N					sm_,sm_); 
N			}
N		}
N	else if((sub_ind==1)||(sub_ind==2))
X	else if((a_ind . s_i==1)||(a_ind . s_i==2))
N		{
N		if(avar_stat&(1<<sub_ind))
X		if(avar_stat&(1<<a_ind . s_i))
N			{
N			bgnd_par(	"   Авария бат. N!   ",
N				    	"    не устранена    ",
N				    	sm_,sm_); 
N			}
N    		else 
N			{
N	    		bgnd_par(	"   Авария бат. N!   ",
N	    				"     устранена      ",
N					sm_,sm_); 
N		
N		     }
N		int2lcd(sub_ind,'!',0);
X		int2lcd(a_ind . s_i,'!',0);
N		} 
N     
N	else if((sub_ind>=3)&&(sub_ind<=14))
X	else if((a_ind . s_i>=3)&&(a_ind . s_i<=14))
N		{
N		if((sub_ind-2)<=9)					ptrs[0]=	"   Авария БПС N+    ";
X		if((a_ind . s_i-2)<=9)					ptrs[0]=	"   Авария БПС N+    ";
N		else 							ptrs[0]=	"   Авария БПС N +   ";
N		if(bps[sub_ind-3]._last_avar==0)		ptrs[1]=	"     перегрев!!!    ";
X		if(bps[a_ind . s_i-3]._last_avar==0)		ptrs[1]=	"     перегрев!!!    ";
N		else if(bps[sub_ind-3]._last_avar==1)	ptrs[1]=	"  завышено Uвых!!!  ";	
X		else if(bps[a_ind . s_i-3]._last_avar==1)	ptrs[1]=	"  завышено Uвых!!!  ";	
N		else if(bps[sub_ind-3]._last_avar==2)	ptrs[1]=	"  занижено Uвых!!!  ";	
X		else if(bps[a_ind . s_i-3]._last_avar==2)	ptrs[1]=	"  занижено Uвых!!!  ";	
N		else if(bps[sub_ind-3]._last_avar==3)	ptrs[1]=	"    отключился!!!   ";
X		else if(bps[a_ind . s_i-3]._last_avar==3)	ptrs[1]=	"    отключился!!!   ";
N		if(avar_stat&(1<<sub_ind)) 			ptrs[2]=	"    не устранена    ";
X		if(avar_stat&(1<<a_ind . s_i)) 			ptrs[2]=	"    не устранена    ";
N		else								ptrs[2]=	"     устранена      ";	
N										ptrs[3]=	"                    ";
N
N		bgnd_par(ptrs[0],ptrs[1],ptrs[2],ptrs[3]);
N		int2lcd((sub_ind-2),'+',0);
X		int2lcd((a_ind . s_i-2),'+',0);
N          
N		//int2lcdxy(sub_ind,0x20,0);
N
N		} 
N		
N	else if(sub_ind==24)
X	else if(a_ind . s_i==24)
N		{ 
N
N		if(sk_av_stat[0]==sasON)
N			{
N			bgnd_par(	"   Авария СК. N1    ",
N				    	"    не устранена    ",
N				    	sm_,sm_); 
N			}
N    		else 
N			{
N	    		bgnd_par(	"   Авария СК. N1    ",
N	    				"     устранена      ",
N					sm_,sm_); 
N		
N		     }
N
N		}
N
N	else if(sub_ind==25)
X	else if(a_ind . s_i==25)
N		{ 
N
N		if(sk_av_stat[1]==sasON)
N			{
N			bgnd_par(	"   Авария СК. N2    ",
N				    	"    не устранена    ",
N				    	sm_,sm_); 
N			}
N    		else 
N			{
N	    		bgnd_par(	"   Авария СК. N2    ",
N	    				"     устранена      ",
N					sm_,sm_); 
N		
N		     }
N
N		}
N
N	else if(sub_ind==26)
X	else if(a_ind . s_i==26)
N		{ 
N
N		if(sk_av_stat[2]==sasON)
N			{
N			bgnd_par(	"   Авария СК. N3    ",
N				    	"    не устранена    ",
N				    	sm_,sm_); 
N			}
N    		else 
N			{
N	    		bgnd_par(	"   Авария СК. N3    ",
N	    				"     устранена      ",
N					sm_,sm_); 
N		
N		     }
N
N		}
N
N	else if(sub_ind==27)
X	else if(a_ind . s_i==27)
N		{ 
N
N		if(sk_av_stat[3]==sasON)
N			{
N			bgnd_par(	"   Авария СК. N4    ",
N				    	"    не устранена    ",
N				    	sm_,sm_); 
N			}
N    		else 
N			{
N	    		bgnd_par(	"   Авария СК. N4    ",
N	    				"     устранена      ",
N					sm_,sm_); 
N		
N		     }
N
N		}
N
N	else if(sub_ind==28)
X	else if(a_ind . s_i==28)
N		{ 
N		if(avar_stat&(1<<sub_ind))
X		if(avar_stat&(1<<a_ind . s_i))
N			{
N			bgnd_par(	"  Авария выходного  ",
N				    	"    напряжения!!!   ",
N				    	sm_,sm_); 
N			}
N
N		}
N
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N		{
N
N		}
N
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N		{
N
N		}
N
N	else if(sub_ind==7)
X	else if(a_ind . s_i==7)
N		{
N
N		} 
N		
N	else if(sub_ind==8)
X	else if(a_ind . s_i==8)
N		{
N
N		}
N
N	else if(sub_ind==9)
X	else if(a_ind . s_i==9)
N		{
N
N		}
N
N	else if(sub_ind==10)
X	else if(a_ind . s_i==10)
N		{
N
N		}
N	    		     
N	else if(sub_ind==11)
X	else if(a_ind . s_i==11)
N		{
N
N		} 
N		
N	else if(sub_ind==12)
X	else if(a_ind . s_i==12)
N		{
N
N		}
N
N	else if(sub_ind==13)
X	else if(a_ind . s_i==13)
N		{
N
N		}
N
N	else if(sub_ind==14)
X	else if(a_ind . s_i==14)
N		{
N
N		}
N
N	else if(sub_ind==15)
X	else if(a_ind . s_i==15)
N		{
N
N		} 
N					
N	} 
N#ifndef _DEBUG_	
N
N
Nelse if(ind==iTst_VD)
Xelse if(a_ind . i==iTst_VD)
N	{
N	ptrs[0]=						" Реле аварии        ";
N    ptrs[1]=						" 1                 !";
N    ptrs[2]=						" Реле аварии        ";
N    ptrs[3]=						" 2                 @";
N    ptrs[4]=						" Реле аварии        ";
N    ptrs[5]=						" 3                 #";
N	ptrs[6]=						" Реле аварии        ";
N    ptrs[7]=						" 4                 $";
N	ptrs[8]=						" БПС N1             ";
N    ptrs[9]=						" БПС N2             ";
N    ptrs[10]=						" БПС N3             ";
N	ptrs[11]=						" БПС N4             ";
N    ptrs[12]=						" БПС N5             ";
N    ptrs[13]=						" БПС N6             ";
N	ptrs[14]=						" БПС N7             ";
N    ptrs[15]=						" БПС N8             ";
N    ptrs[16]=						" БПС N9             ";               
N	ptrs[17]=						" БПС N10            ";
N    ptrs[18]=						" БПС N11            ";
N    ptrs[19]=						" БПС N12            ";               
N	ptrs[8+NUMIST]=					" Выход              ";
N	ptrs[9+NUMIST]=					" Проверка WDT(внутр)";
N	ptrs[10+NUMIST]=				" Проверка WDT(внешн)";
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("        ТЕСТ        ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("        ТЕСТ        ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N/*	int2lcdyx(sub_ind,0,19,0);
N	int2lcdyx(index_set,0,17,0);
N	int2lcdyx(tst_state[0],0,15,0); */
N
N	//int2lcd_mmm(bat[0]._Ib,'<',2);
N	//int2lcd_mmm(bat[1]._Ib,'>',2);
N
N	if(tst_state[0]==tst1) sub_bgnd("ВКЛ.",'!',-3);
N	if(tst_state[0]==tst2) sub_bgnd("ВЫКЛ.",'!',-4);
N	else sub_bgnd("РАБОЧ.",'!',-5);
N
N	if(tst_state[1]==tst1) sub_bgnd("ВКЛ.",'@',-3);
N	if(tst_state[1]==tst2) sub_bgnd("ВЫКЛ.",'@',-4);
N	else sub_bgnd("РАБОЧ.",'@',-5);
N
N	if(tst_state[2]==tst1) sub_bgnd("ВКЛ.",'#',-3);
N	if(tst_state[2]==tst2) sub_bgnd("ВЫКЛ.",'#',-4);
N	else sub_bgnd("РАБОЧ.",'#',-5);
N
N	if(tst_state[3]==tst1) sub_bgnd("ВКЛ.",'$',-3);
N	if(tst_state[3]==tst2) sub_bgnd("ВЫКЛ.",'$',-4);
N	else sub_bgnd("РАБОЧ.",'$',-5);
N	
N	if(sub_ind==0)
X	if(a_ind . s_i==0)
N		{
N		if(tst_state[0]==tst1)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_1,1,5);
X		if(tst_state[0]==tst1)mess_send(210,101,1,5);
N		else if(tst_state[0]==tst2)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_1,0,5);
X		else if(tst_state[0]==tst2)mess_send(210,101,0,5);
N		}
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		if(tst_state[1]==tst1)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_2,1,5);
X		if(tst_state[1]==tst1)mess_send(210,102,1,5);
N		else if(tst_state[1]==tst2)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_2,0,5);
X		else if(tst_state[1]==tst2)mess_send(210,102,0,5);
N		}	
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N		if(tst_state[2]==tst1)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_3,1,5);
X		if(tst_state[2]==tst1)mess_send(210,103,1,5);
N		else if(tst_state[2]==tst2)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_3,0,5);
X		else if(tst_state[2]==tst2)mess_send(210,103,0,5);
N		}
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N		{
N		if(tst_state[3]==tst1)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_4,1,5);
X		if(tst_state[3]==tst1)mess_send(210,104,1,5);
N		else if(tst_state[3]==tst2)mess_send(MESS2RELE_HNDL,PARAM_RELE_AV_4,0,5);
X		else if(tst_state[3]==tst2)mess_send(210,104,0,5);
N		}
N	}
N
Nelse if(ind==iTst_bps)
Xelse if(a_ind . i==iTst_bps)
N	{
N	if(tst_state[5]==tstOFF)ptrs[0]=		" Выключен           ";
N	else if(tst_state[5]==tst1)ptrs[0]=		" Включен            ";
N//	else ptrs[0]=							" Автономно          ";
N    ptrs[1]=								" ШИМ              @ ";
N    ptrs[2]=								" U =  .$В  I =  .#A ";
N	ptrs[3]=								" Выход              ";
N
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par("     ТЕСТ БПС N!    ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("     ТЕСТ БПС N!    ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N
N	if(tst_state[6]==tst1) sub_bgnd("Umax",'@',-3); 
N	else sub_bgnd("Umin",'@',-3);
N
N
N
N
N	/*int2lcdyx(sub_ind,0,19,0);
N	int2lcdyx(index_set,0,17,0);
N	int2lcdyx(tst_state[5],0,3,0); */
N	//int2lcdyx(tst_state[6],0,1,0); 
N	//int2lcdyx(cntrl_stat,0,5,0); 
N
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd(bps[sub_ind1]._Ii,'#',1);
X	int2lcd(bps[a_ind . s_i1]._Ii,'#',1);
N	int2lcd(bps[sub_ind1]._Uii,'$',1);
X	int2lcd(bps[a_ind . s_i1]._Uii,'$',1);
N
N
N	if(tst_state[5]==tstOFF) mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,~(1<<sub_ind1),10);
X	if(tst_state[5]==tstOFF) mess_send(205,208,~(1<<a_ind . s_i1),10);
N	else mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X	else mess_send(205,208,(1<<a_ind . s_i1),10);
N	
N	//if(tst_state[5]==tst2) mess_send(MESS2NET_DRV,PARAM_BPS_NET_OFF,1,10);
N	
N	if(sub_ind==0)mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,1020,10);	
X	if(a_ind . s_i==0)mess_send(225,229,1020,10);	
N	else if(tst_state[6]==tstOFF) mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,30,10);
X	else if(tst_state[6]==tstOFF) mess_send(225,229,30,10);
N	else if(tst_state[6]==tst1) mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,1020,10);
X	else if(tst_state[6]==tst1) mess_send(225,229,1020,10);
N/*		mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,10);
N	    	mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,1000,10);
N          }
N     if(sub_ind==6)
N		{
N          mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
N          mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,40);
N          mess_send(MESS2UNECC_HNDL,PARAM_UNECC_SET,U_AVT,10);
N	    	mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_FAST_REG,0,10);
N
N          }
N
N     if(sub_ind==9)
N		{
N		if(phase==0)
N			{
N          	
N          	}
N      	else if(phase==1)
N			{
N          	mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
N			mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,10);
N          	}
N          mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_SET,1000,10);
N          }
N	*/
N
N
N
N
N	}	 
Nelse if(ind==iKlimat)
Xelse if(a_ind . i==iKlimat)
N	{
N	ptrs[0]=				" tшк.max=       !°C ";
N	ptrs[1]=				" tвент.max=     @°C ";
N	ptrs[2]=				" tшк.рег.=      #°C ";
N	ptrs[3]=				" tоткл.нагр.    $°C ";
N	ptrs[4]=				" tвкл.нагр.     %°C ";
N	ptrs[5]=				" tоткл.бат.     ^°C ";
N	ptrs[6]=				" tвкл.бат.      &°C ";
N	ptrs[7]=				" Выход              ";
N
N
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(				"   КЛИМАТКОНТРОЛЬ   ",
N						ptrs[index_set],
X						ptrs[a_ind . i_s],
N						ptrs[index_set+1],
X						ptrs[a_ind . i_s+1],
N						ptrs[index_set+2]);
X						ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N	int2lcd(TBOXMAX,'!',0); 
N	if((TBOXVENTMAX>=50)&&(TBOXVENTMAX<=80))int2lcd(TBOXVENTMAX,'@',0); 
N	else sub_bgnd("ВЫКЛ.",'@',-2);
N	int2lcd(TBOXREG,'#',0);
N	if((TLOADDISABLE>=50)&&(TLOADDISABLE<=80))int2lcd(TLOADDISABLE,'$',0);
N	else sub_bgnd("ВЫКЛ.",'$',-2);
N	if((TLOADDISABLE>=50)&&(TLOADDISABLE<=80)/*&&(TLOADENABLE>=50)&&(TLOADENABLE<=80)*/)int2lcd(TLOADENABLE,'%',0);
N	else sub_bgnd("ВЫКЛ.",'%',-2);
N	if((TBATDISABLE>=50)&&(TBATDISABLE<=90))int2lcd(TBATDISABLE,'^',0);
N	else sub_bgnd("ВЫКЛ.",'^',-2);
N	if((TBATDISABLE>=50)&&(TBATDISABLE<=90)/*&&(TBATENABLE>=50)&&(TBATENABLE<=80)*/)int2lcd(TBATENABLE,'&',0);
N	else sub_bgnd("ВЫКЛ.",'&',-2);
N	}
N
Nelse if(ind==iKlimat_kontur)
Xelse if(a_ind . i==iKlimat_kontur)
N	{
N	ptrs[0]=				" tшк.max=       !°C ";
N	ptrs[1]=				" tвент.max=     @°C ";
N	ptrs[2]=				" tшк.рег.=      #°C ";
N	ptrs[3]=				" tвкл.отопит.   $°C ";
N	ptrs[4]=				" tоткл.отопит.  %°C ";
N	ptrs[5]=				" tоткл.нагруз.  ^°C ";
N	ptrs[6]=				" tвкл.нагруз.   &°C ";
N	ptrs[7]=				" tоткл.бат.     *°C ";
N	ptrs[8]=				" tвкл.бат.      (°C ";
N	ptrs[9]=				" Выход              ";
N
N
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(				"   КЛИМАТКОНТРОЛЬ   ",
N						ptrs[index_set],
X						ptrs[a_ind . i_s],
N						ptrs[index_set+1],
X						ptrs[a_ind . i_s+1],
N						ptrs[index_set+2]);
X						ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N	int2lcd(TBOXMAX,'!',0); 
N/*	int2lcd(TBOXVENTON,'@',0); 
N	int2lcd(TBOXVENTOFF,'#',0);*/
N	if((TBOXVENTMAX>=50)&&(TBOXVENTMAX<=80))int2lcd(TBOXVENTMAX,'@',0); 
N	else sub_bgnd("ВЫКЛ.",'@',-2);
N	int2lcd(TBOXREG,'#',0);
N	int2lcd_mmm(TBOXWARMON,'$',0); 
N	int2lcd_mmm(TBOXWARMOFF,'%',0);
N	if((TLOADDISABLE>=50)&&(TLOADDISABLE<=80))int2lcd(TLOADDISABLE,'^',0);
N	else sub_bgnd("ВЫКЛ.",'^',-2);
N	if((TLOADDISABLE>=50)&&(TLOADDISABLE<=80))int2lcd(TLOADENABLE,'&',0);
N	else sub_bgnd("ВЫКЛ.",'&',-2);
N	if((TBATDISABLE>=50)&&(TBATDISABLE<=90))int2lcd(TBATDISABLE,'*',0);
N	else sub_bgnd("ВЫКЛ.",'*',-2);
N	if((TBATDISABLE>=50)&&(TBATDISABLE<=90))int2lcd(TBATENABLE,'(',0);
N	else sub_bgnd("ВЫКЛ.",'(',-2);
N
N//		int2lcdyx(t_box_vent_on_cnt,0,3,0);
N//	int2lcdyx(t_box_warm_on_cnt,0,7,0);
N//	int2lcdyx(vent_stat_k,0,10,0);
N//	int2lcdyx(warm_stat_k,0,13,0);
N	
N	int2lcdyx(t_box,0,19,0);	 
N	}
N#ifdef UKU_TELECORE2015
Selse if(ind==iKlimat_TELECORE)
S	{
S	ptrs[0]=				" Сигнал температуры ";
S	ptrs[1]=				" обогрева         ! ";
S	ptrs[2]=				" Сигнал температуры ";
S	ptrs[3]=				" вентилятора      @ ";
S	ptrs[4]=				" tвкл.отопит.   $°C ";
S	ptrs[5]=				" tоткл.отопит.  <°C ";
S	ptrs[6]=				" Qперкл.        *%  ";
S	ptrs[7]=				" tвкл.вент.     ^°C ";
S	ptrs[8]=				" tоткл.вент.    &°C ";
S	ptrs[9]=				" tвкл.вн.вент.  [°C ";
S	ptrs[10]=				" tоткл.вн.вент. ]°C ";
S	ptrs[11]=				" Выход              ";
S
S
S
S	if((sub_ind-index_set)>2)index_set=sub_ind-2;
S	else if(sub_ind<index_set)index_set=sub_ind;
S	bgnd_par(				"   КЛИМАТКОНТРОЛЬ   ",
S						ptrs[index_set],
S						ptrs[index_set+1],
S						ptrs[index_set+2]);
S	pointer_set(1);
S
S	if(TELECORE2015_KLIMAT_WARM_SIGNAL==0) sub_bgnd("ДТ 2",'!',-3);
S	else if(TELECORE2015_KLIMAT_WARM_SIGNAL==1) sub_bgnd("ДТ 1",'!',-3);
S	//else sub_bgnd("ДТ BMS",'!',-5);
S	if(TELECORE2015_KLIMAT_VENT_SIGNAL==0) sub_bgnd("ДТ 2",'@',-3);
S	else if(TELECORE2015_KLIMAT_VENT_SIGNAL==1) sub_bgnd("ДТ 1",'@',-3);
S	//else sub_bgnd("ДТ BMS",'@',-5);
S	int2lcd_mmm(TELECORE2015_KLIMAT_WARM_ON,'$',0); 
S	int2lcd_mmm(TELECORE2015_KLIMAT_WARM_OFF,'<',0);
S	int2lcd_mmm(TELECORE2015_KLIMAT_CAP,'*',0);	
S	int2lcd_mmm(TELECORE2015_KLIMAT_VENT_ON,'^',0);
S	int2lcd_mmm(TELECORE2015_KLIMAT_VENT_OFF,'&',0);
S	int2lcd_mmm(TELECORE2015_KLIMAT_VVENT_ON,'[',0);
S	int2lcd_mmm(TELECORE2015_KLIMAT_VVENT_OFF,']',0);
S
S	//int2lcd(TBOXMAX,'!',0); 
S	
S/*	int2lcd(TBOXVENTON,'@',0); 
S	int2lcd(TBOXVENTOFF,'#',0);*/
S	//if((TBOXVENTMAX>=50)&&(TBOXVENTMAX<=80))int2lcd(TBOXVENTMAX,'@',0); 
S	//else sub_bgnd("ВЫКЛ.",'@',-2);
S	//int2lcd(TBOXREG,'#',0);
S
S
S
S
S//	int2lcdyx(t_ext[0],0,3,0);
S//	int2lcdyx(t_ext[1],0,7,0);
S/*//	int2lcdyx(vent_stat_k,0,10,0);
S	int2lcdyx(TELECORE2015_KLIMAT_WARM_ON_temp,0,13,0);
S	
S	int2lcdyx(t_box,0,19,0);	 */
S	}
N#endif
N#ifdef UKU_TELECORE2017
Selse if(ind==iKlimat_TELECORE)
S	{
S	ptrs[0]=				" Сигнал температуры ";
S	ptrs[1]=				" обогрева         ! ";
S	ptrs[2]=				" Сигнал температуры ";
S	ptrs[3]=				" вентилятора      @ ";
S	ptrs[4]=				" tвкл.отопит.   $°C ";
S	ptrs[5]=				" tоткл.отопит.  <°C ";
S	ptrs[6]=				" Qперкл.        >%  ";
S	ptrs[7]=				" tвент.100%     y°C ";	
S	ptrs[8]=				" tвент.80%      f°C ";
S	ptrs[9]=				" tвент.60%      r°C ";
S	ptrs[10]=				" tвент.40%      e°C ";
S	ptrs[11]=				" tвент.20%      w°C ";
S	ptrs[12]=				" dtвент.100%    s°C ";
S	ptrs[13]=				" dtвент.80%     a°C ";
S	ptrs[14]=				" dtвент.60%     p°C ";
S	ptrs[15]=				" dtвент.40%     o°C ";
S	ptrs[16]=				" dtвент.20%     i°C ";
S	ptrs[17]=				" Выход              ";
S
S//	ptrs[7]=				" tвент.0%       q°C ";
S//	ptrs[13]=				" dtвент.0%      u°C ";
S
S	if((sub_ind-index_set)>2)index_set=sub_ind-2;
S	else if(sub_ind<index_set)index_set=sub_ind;
S	bgnd_par(				"   КЛИМАТКОНТРОЛЬ   ",
S						ptrs[index_set],
S						ptrs[index_set+1],
S						ptrs[index_set+2]);
S	pointer_set(1);
S
S	if(TELECORE2017_KLIMAT_WARM_SIGNAL==0) sub_bgnd("ДТ 2",'!',-3);
S	else if(TELECORE2017_KLIMAT_WARM_SIGNAL==1) sub_bgnd("ДТ 1",'!',-3);
S	//else sub_bgnd("ДТ BMS",'!',-5);
S	if(TELECORE2017_KLIMAT_VENT_SIGNAL==0) sub_bgnd("ДТ 2",'@',-3);
S	else if(TELECORE2017_KLIMAT_VENT_SIGNAL==1) sub_bgnd("ДТ 1",'@',-3);
S	//else sub_bgnd("ДТ BMS",'@',-5);
S	int2lcd_mmm(TELECORE2017_KLIMAT_WARM_ON,'$',0); 
S	int2lcd_mmm(TELECORE2017_KLIMAT_WARM_OFF,'<',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_CAP,'>',0);	
S//	int2lcd_mmm(TELECORE2017_KLIMAT_VENT_ON0,'q',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_VENT_ON20,'w',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_VENT_ON40,'e',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_VENT_ON60,'r',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_VENT_ON80,'f',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_VENT_ON100,'y',0);
S//	int2lcd_mmm(TELECORE2017_KLIMAT_DVENT_ON0,'u',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_DVENT_ON20,'i',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_DVENT_ON40,'o',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_DVENT_ON60,'p',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_DVENT_ON80,'a',0);
S	int2lcd_mmm(TELECORE2017_KLIMAT_DVENT_ON100,'s',0);
S
S	//int2lcd(TBOXMAX,'!',0); 
S	
S/*	int2lcd(TBOXVENTON,'@',0); 
S	int2lcd(TBOXVENTOFF,'#',0);*/
S	//if((TBOXVENTMAX>=50)&&(TBOXVENTMAX<=80))int2lcd(TBOXVENTMAX,'@',0); 
S	//else sub_bgnd("ВЫКЛ.",'@',-2);
S	//int2lcd(TBOXREG,'#',0);
S
S
S
S
S//	int2lcdyx(t_ext[0],0,3,0);
S//	int2lcdyx(t_ext[1],0,7,0);
S/*//	int2lcdyx(vent_stat_k,0,10,0);
S	int2lcdyx(TELECORE2015_KLIMAT_WARM_ON_temp,0,13,0);
S	
S	int2lcdyx(t_box,0,19,0);	 */
S	}
N#endif
N
Nelse if(ind==iNpn_set)
Xelse if(a_ind . i==iNpn_set)
N	{
N	ptrs[0]=				" Вывод          !   ";
N	if(NPN_OUT==npnoOFF)
N		{
N		ptrs[1]=			" Выход              ";
N		ptrs[2]=			"                    ";
N		simax=1;
N		}
N	else 
N		{
N/*		ptrs[1]=			" Сигнал         @   ";
N 		if(NPN_SIGN==npnsAVNET)
N			{
N			ptrs[2]=		" Tз.н.п.н.       #с.";
N			ptrs[3]=		" Выход              ";
N			simax=3;
N			}
N		else if(NPN_SIGN==npnsULOAD)
N			{
N			ptrs[2]=		" Uоткл.н.п.н.    $В ";
N			ptrs[3]=		" Uвкл.н.п.н.     %В ";
N			ptrs[4]=		" Tз.н.п.н.       #с.";
N			ptrs[5]=		" Выход              ";
N			simax=5;
N			}*/
N
N			ptrs[1]=		" Uоткл.н.п.н.    $В ";
N			ptrs[2]=		" Uвкл.н.п.н.     %В ";
N			ptrs[3]=		" Tз.н.п.н.       #с.";
N			ptrs[4]=		" Выход              ";
N			simax=4;
N		}
N
N
N	if((sub_ind-index_set)>2)index_set=sub_ind-2;
X	if((a_ind . s_i-a_ind . i_s)>2)a_ind . i_s=a_ind . s_i-2;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(				" Отключение Н.П.Н.  ",
N							ptrs[index_set],
X							ptrs[a_ind . i_s],
N							ptrs[index_set+1],
X							ptrs[a_ind . i_s+1],
N							ptrs[index_set+2]);
X							ptrs[a_ind . i_s+2]);
N	pointer_set(1);
N	
N	if(NPN_OUT==npnoRELEVENT) sub_bgnd("Реле вент-ра",'!',-8);
N	else if(NPN_OUT==npnoRELEAVBAT2) sub_bgnd("Реле АВ.БАТ2",'!',-8);
N	else sub_bgnd("Выкл.",'!',-1);
N//	if(NPN_SIGN==npnsAVNET) sub_bgnd("Ав.сети",'@',-3);
N//	else sub_bgnd("Uнагр.",'@',-2);
N	int2lcd(TZNPN,'#',0);
N	int2lcd(UONPN,'$',1);
N	int2lcd(UVNPN,'%',1);
N
N	}
N
N#endif
N
Nelse if(ind==iBps_list)
Xelse if(a_ind . i==iBps_list)
N     {
N     if(sub_ind==0)
X     if(a_ind . s_i==0)
N     	{
N     	bgnd_par(" N  L   U    I    t ",
N     	         " !  @    ^    $    #",
N     	         " !  @    ^    $    #",
N     	         " !  @    ^    $    #");
N      
N
N     	}     
N
N    else if(sub_ind==1) 
X    else if(a_ind . s_i==1) 
N     	{
N      	bgnd_par(" N  L   U    I   Uн ",
N     	         " !  @    ^    $    %",
N     	         " !  @    ^    $    %",
N     	         " !  @    ^    $    %");
N
N		} 
N
N    else if(sub_ind==2) 
X    else if(a_ind . s_i==2) 
N     	{
N      	bgnd_par(" N   U    I   pwm ВТ",
N     	         " !    ^    $   &   (",
N     	         " !    ^    $   &   (",
N     	         " !    ^    $   &   (");
N
N		}
N
N 	else if(sub_ind==3) 
X 	else if(a_ind . s_i==3) 
N     	{
N      	bgnd_par(" N   U    I   pwm пр",
N     	         " !    ^    $   &   )",
N     	         " !    ^    $   &   )",
N     	         " !    ^    $   &   )");
N
N		}
N
N
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd(sub_ind1+2,'!',0);
X	int2lcd(a_ind . s_i1+2,'!',0);
N	if(sub_ind1==NUMIST-2) sub_bgnd("Ш",'!',0);
X	if(a_ind . s_i1==NUMIST-2) sub_bgnd("Ш",'!',0);
N	else int2lcd(sub_ind1+3,'!',0);
X	else int2lcd(a_ind . s_i1+3,'!',0);
N
N	int2lcd(bps[sub_ind1]._cnt,'@',0);
X	int2lcd(bps[a_ind . s_i1]._cnt,'@',0);
N	int2lcd(bps[sub_ind1+1]._cnt,'@',0);
X	int2lcd(bps[a_ind . s_i1+1]._cnt,'@',0);
N	if(sub_ind1==NUMIST-2)int2lcd(ibat_metr_cnt,'@',0);
X	if(a_ind . s_i1==NUMIST-2)int2lcd(ibat_metr_cnt,'@',0);
N	else int2lcd(bps[sub_ind1+2]._cnt,'@',0);		
X	else int2lcd(bps[a_ind . s_i1+2]._cnt,'@',0);		
N		
N	int2lcd(bps[sub_ind1]._Uii/10,'^',0);
X	int2lcd(bps[a_ind . s_i1]._Uii/10,'^',0);
N	int2lcd(bps[sub_ind1+1]._Uii/10,'^',0);
X	int2lcd(bps[a_ind . s_i1+1]._Uii/10,'^',0);
N	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2]._Uii/10,'^',0);
X	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2]._Uii/10,'^',0);
N	else sub_bgnd(" ",'^',0);
N
N     int2lcd(bps[sub_ind1]._Ii,'$',1); 
X     int2lcd(bps[a_ind . s_i1]._Ii,'$',1); 
N	int2lcd(bps[sub_ind1+1]._Ii,'$',1); 
X	int2lcd(bps[a_ind . s_i1+1]._Ii,'$',1); 
N	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2]._Ii,'$',1); 
X	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2]._Ii,'$',1); 
N	else int2lcd_mmm(Ib_ips_termokompensat,'$',0);
N
N	int2lcd(bps[sub_ind1]._Uin/10,'%',0);
X	int2lcd(bps[a_ind . s_i1]._Uin/10,'%',0);
N	int2lcd(bps[sub_ind1+1]._Uin/10,'%',0);
X	int2lcd(bps[a_ind . s_i1+1]._Uin/10,'%',0);
N	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2]._Uin/10,'%',0);
X	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2]._Uin/10,'%',0);
N	else sub_bgnd(" ",'%',0);
N
N	int2lcd(bps[sub_ind1]._Ti,'#',0);
X	int2lcd(bps[a_ind . s_i1]._Ti,'#',0);
N	int2lcd(bps[sub_ind1+1]._Ti,'#',0); 
X	int2lcd(bps[a_ind . s_i1+1]._Ti,'#',0); 
N   	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2]._Ti,'#',0);
X   	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2]._Ti,'#',0);
N	else sub_bgnd(" ",'#',0);
N
N	int2lcd(bps[sub_ind1].debug_info_to_uku0,'&',0);
X	int2lcd(bps[a_ind . s_i1].debug_info_to_uku0,'&',0);
N	int2lcd(bps[sub_ind1+1].debug_info_to_uku0,'&',0);
X	int2lcd(bps[a_ind . s_i1+1].debug_info_to_uku0,'&',0);
N	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2].debug_info_to_uku0,'&',0);
X	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2].debug_info_to_uku0,'&',0);
N	else sub_bgnd(" ",'&',0);
N
N	int2lcd(bps[sub_ind1]._x_+50,'(',0);
X	int2lcd(bps[a_ind . s_i1]._x_+50,'(',0);
N	int2lcd(bps[sub_ind1+1]._x_+50,'(',0);
X	int2lcd(bps[a_ind . s_i1+1]._x_+50,'(',0);
N	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2]._x_+50,'(',0);
X	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2]._x_+50,'(',0);
N	else sub_bgnd(" ",'(',0);
N
N	int2lcd(bps[sub_ind1]._avg,')',0);
X	int2lcd(bps[a_ind . s_i1]._avg,')',0);
N	int2lcd(bps[sub_ind1+1]._avg,')',0);
X	int2lcd(bps[a_ind . s_i1+1]._avg,')',0);
N	if(sub_ind1<NUMIST-2) int2lcd(bps[sub_ind1+2]._avg,')',0);
X	if(a_ind . s_i1<NUMIST-2) int2lcd(bps[a_ind . s_i1+2]._avg,')',0);
N	else sub_bgnd(" ",')',0);
N
N	}
N	
Nelse if(ind==iAvt_set_sel)
Xelse if(a_ind . i==iAvt_set_sel)
N	{
N	ptrs[0]=						" БПС N1             ";
N     ptrs[1]=						" БПС N2             ";
N     ptrs[2]=						" БПС N3             ";
N	ptrs[3]=						" БПС N4             ";
N     ptrs[4]=						" БПС N5             ";
N     ptrs[5]=						" БПС N6             ";
N	ptrs[6]=						" БПС N7             ";
N     ptrs[7]=						" БПС N8             ";
N     ptrs[8]=						" БПС N9             ";
N	ptrs[9]=						" БПС N10            ";
N     ptrs[10]=						" БПС N11            ";
N     ptrs[11]=						" БПС N12            ";               
N	ptrs[NUMIST]=					" Выход              ";
N	ptrs[1+NUMIST]=				"                    ";
N	ptrs[2+NUMIST]=				"                    ";
N
N
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(				"УСТАНОВКА НАПРЯЖЕНИЯ",
N						" АВТОНОМНОЙ РАБОТЫ  ",
N						ptrs[index_set],
X						ptrs[a_ind . i_s],
N						ptrs[index_set+1]);
X						ptrs[a_ind . i_s+1]);
N	pointer_set(2);
N
N	}		 
N
Nelse if(ind==iAvt_set)
Xelse if(a_ind . i==iAvt_set)
N	{
N	ptrs[0]=" Uавтон =   $В      ";
N	if(bFL_)
N		{
N		ptrs[1]=" установите Uавтон  ";
N     	ptrs[2]="  нажатием љ или њ  ";
N     	}
N     else 
N     	{
N		ptrs[1]=" удерживайте ¤ для  ";
N     	ptrs[2]="    запоминания     ";     	
N     	}	
N
N     ptrs[3]=sm_exit;
N     ptrs[4]=sm_;
N     ptrs[5]=sm_;     	     	    
N	
N
N     if((sub_ind==0)||(sub_ind==1)||(sub_ind==2))index_set=0;
X     if((a_ind . s_i==0)||(a_ind . s_i==1)||(a_ind . s_i==2))a_ind . i_s=0;
N	else index_set=3;
X	else a_ind . i_s=3;
N	
N	bgnd_par("       БПС N!      ",ptrs[index_set],ptrs[index_set+1],ptrs[index_set+2]);
X	bgnd_par("       БПС N!      ",ptrs[a_ind . i_s],ptrs[a_ind . i_s+1],ptrs[a_ind . i_s+2]);
N
N	pointer_set(1);	
N	int2lcd(sub_ind1+1,'!',0);
X	int2lcd(a_ind . s_i1+1,'!',0);
N	int2lcd(U_AVT,'$',1);
N	 
N	
N     if(sub_ind==0)
X     if(a_ind . s_i==0)
N		{
N        mess_send(MESS2BPS_HNDL,PARAM_BPS_MASK_ON_OFF_AFTER_2SEC,(1<<sub_ind1),10);
X        mess_send(205,208,(1<<a_ind . s_i1),10);
N        mess_send(MESS2BAT_HNDL,PARAM_BAT_ALL_OFF_AFTER_2SEC,0,40);
X        mess_send(200,201,0,40);
N        mess_send(MESS2UNECC_HNDL,PARAM_UNECC_SET,U_AVT,10);
X        mess_send(190,191,U_AVT,10);
N	    mess_send(MESS2CNTRL_HNDL,PARAM_CNTRL_STAT_FAST_REG,0,10);
X	    mess_send(225,230,0,10);
N
N        }
N
N 	if(mess_find( (MESS2IND_HNDL)) && (mess_data[0]==PARAM_U_AVT_GOOD) )
X 	if(mess_find( (215)) && (mess_data[0]==217) )
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		show_mess(	"     Установка      ",
N	          		"    напряжения      ",
N	          		" автономной работы  ",
N	          		"    произведена     ",3000);
N		
N		}
N	//int2lcdyx(sub_ind,0,4,0);		      
N	 }
Nelse if(ind==iOut_volt_contr)
Xelse if(a_ind . i==iOut_volt_contr)
N	{
N	ptrs[0]=" Uвыхmax         !В ";
N    ptrs[1]=" Uвыхmin         @В ";
N    ptrs[2]=" Tздрж.ав.       #с.";     	
N    ptrs[3]=sm_exit;
N    ptrs[4]=sm_;
N    ptrs[5]=sm_;     	     	    
N	
N
N	if((sub_ind-index_set)>1)index_set=sub_ind-1;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i-1;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	
N	bgnd_par(	"КОНТРОЛЬ ВЫХОДНОГО ",
N				"    НАПРЯЖЕНИЯ     ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1]);
X				ptrs[a_ind . i_s+1]);
N
N	pointer_set(2);	
N	int2lcd(U_OUT_KONTR_MAX,'!',1);
N	int2lcd(U_OUT_KONTR_MIN,'@',1);
N	int2lcd(U_OUT_KONTR_DELAY,'#',0);
N	}
Nelse if(ind==iDop_rele_set)
Xelse if(a_ind . i==iDop_rele_set)
N	{
N	if(DOP_RELE_FUNC==0)
N		{
N		ptrs[0]=	" Индикация          ";
N		ptrs[1]=	" ускоренного заряда ";
N		}
N	else /*if(DOP_RELE_FUNC==0)*/
N		{
N		ptrs[0]=	" Индикация          ";
N		ptrs[1]=	" разряженной батареи";
N		}
N	ptrs[2]=		" Выход              ";
N	ptrs[3]=		"                    ";
N
N
N	if((sub_ind-index_set)>1)index_set=sub_ind;
X	if((a_ind . s_i-a_ind . i_s)>1)a_ind . i_s=a_ind . s_i;
N	else if(sub_ind<index_set)index_set=sub_ind;
X	else if(a_ind . s_i<a_ind . i_s)a_ind . i_s=a_ind . s_i;
N	bgnd_par(			"ДОПОПЛНИТЕЛЬНОЕ РЕЛЕ",
N						"  ФУНКЦИОНАЛЬНОСТЬ  ",
N						ptrs[index_set],
X						ptrs[a_ind . i_s],
N						ptrs[index_set+1]);
X						ptrs[a_ind . i_s+1]);
N	pointer_set(2);
N
N	//int2lcdyx(sub_ind,0,6,0);
N	//int2lcdyx(index_set,0,9,0);
N	
N	}
N
Nelse if (ind==iIps_Curr_Avg_Set)
Xelse if (a_ind . i==iIps_Curr_Avg_Set)
N	{ 
N	if(ICA_EN==0)
N		{
N		ptrs[0]=		" Выключено          ";
N		simax=1;
N		}
N	else 
N		{
N		ptrs[0]=		" Включено           ";
N		if(ICA_CH==0)
N			{
N			ptrs[1]=	" КАНАЛ  MODBUS-RTU  ";
N			ptrs[2]=	" АДРЕС ВЕДОМОГО   ! ";
N			simax=3;
N			}
N		else
N			{
N			ptrs[1]=	" КАНАЛ   MODBUS-TCP ";
N			ptrs[2]=	" IP 00@.00#.00$.00% ";
N			ptrs[3]=	" АДРЕС ВЕДОМОГО   ^ ";
N			simax=4;
N			}
N		} 
N	ptrs[simax]=		" Выход              ";
N	
N	if(sub_ind<index_set) index_set=sub_ind;
X	if(a_ind . s_i<a_ind . i_s) a_ind . i_s=a_ind . s_i;
N	else if((sub_ind-index_set)>1) index_set=sub_ind-1;	
X	else if((a_ind . s_i-a_ind . i_s)>1) a_ind . i_s=a_ind . s_i-1;	
N	bgnd_par(	" ВЫРАВНИВАНИЕ ТОКОВ ",
N				"        ИПС         ",
N				ptrs[index_set],
X				ptrs[a_ind . i_s],
N				ptrs[index_set+1]);
X				ptrs[a_ind . i_s+1]);
N	
N	pointer_set(2);
N	int2lcd(ICA_MODBUS_ADDRESS,'!',0);
N	if((sub_ind==2)&&(sub_ind1==0)&&bFL2)sub_bgnd("   ",'@',-2);
X	if((a_ind . s_i==2)&&(a_ind . s_i1==0)&&bFL2)sub_bgnd("   ",'@',-2);
N	else int2lcd(ICA_MODBUS_TCP_IP1,'@',0);
N	if((sub_ind==2)&&(sub_ind1==1)&&bFL2)sub_bgnd("   ",'#',-2);
X	if((a_ind . s_i==2)&&(a_ind . s_i1==1)&&bFL2)sub_bgnd("   ",'#',-2);
N	else int2lcd(ICA_MODBUS_TCP_IP2,'#',0);
N	if((sub_ind==2)&&(sub_ind1==2)&&bFL2)sub_bgnd("   ",'$',-2);
X	if((a_ind . s_i==2)&&(a_ind . s_i1==2)&&bFL2)sub_bgnd("   ",'$',-2);
N	else int2lcd(ICA_MODBUS_TCP_IP3,'$',0);
N	if((sub_ind==2)&&(sub_ind1==3)&&bFL2)sub_bgnd("   ",'%',-2);
X	if((a_ind . s_i==2)&&(a_ind . s_i1==3)&&bFL2)sub_bgnd("   ",'%',-2);
N	else int2lcd(ICA_MODBUS_TCP_IP4,'%',0);
N	int2lcd(ICA_MODBUS_TCP_UNIT_ID,'^',0);	
N     
N 	} 
N
N/*
Nconst char sm7[]	={" Источник N2        "}; //
Nconst char sm8[]	={" Нагрузка           "}; //
Nconst char sm9[]	={" Сеть               "}; //
Nconst char sm10[]	={" Спецфункции        "}; // 
Nconst char sm11[]	={" Журнал аварий      "}; //
Nconst char sm12[]	=" Батарейный журнал  "}; //
Nconst cha		=" Паспорт            "}; //
N*/
N
N
N//char2lcdhyx(bat_rel_stat[0],0,10);
N//char2lcdhyx(bat_rel_stat[1],0,15);
N//int2lcdyx(u_necc,0,19,0);
N//int2lcdyx(cntrl_stat,0,5,0); 	   mess_cnt[i]
N
N//char2lcdhyx(bat_rel_stat[0],0,5);
N//char2lcdhyx(bat_rel_stat[1],0,10);
N//int2lcdyx(mess_cnt[1],0,2,0);
N//int2lcdyx(GET_REG(IOPIN1,21,1),0,5,0); 
N//int2lcdyx(samokalibr_cnt,0,10,0);
N//char2lcdhyx(rele_stat,0,19);
N//char2lcdhyx(mess_cnt[1],0,16); 
N
N//int2lcdyx(ad7705_res1,0,8,0);
N//int2lcdyx(ad7705_res2,0,16,0); 
N//	int2lcdyx(bat[0]._cnt_to_block,0,1,0);
N//	int2lcdyx(bat[1]._cnt_to_block,0,3,0);
N//	int2lcdyx(bat[0]._rel_stat,0,5,0);
N/*	int2lcdyx(ind,0,3,0); 
N	int2lcdyx(sub_ind,0,6,0);
N	int2lcdyx(index_set,0,9,0);
N	int2lcdyx(ptr_ind,0,14,0);
N	;*/
N/*int2lcdyx(ind,0,19,0);
Nint2lcdyx(retindsec,0,15,0);
Nint2lcdyx(retcnt,0,11,0);
Nint2lcdyx(retcntsec,0,7,0);	*/
N//int2lcdyx(bps[0]._vol_i,0,15,0);
N//int2lcdyx(cntrl_stat,0,19,0); 
N//int2lcdyx(bps[0]._Uin,0,4,0);
W "main.c" 1402 6 variable "ii_" was declared but never referenced
W "main.c" 1403 20 variable "cnt_ind_bat" was declared but never referenced
N}							    
N
N
N#define BUT0	16
N#define BUT1	17
N#define BUT2	18
N#define BUT3	19
N#define BUT4	20   
N#define BUT_MASK (1UL<<BUT0)|(1UL<<BUT1)|(1UL<<BUT2)|(1UL<<BUT3)|(1UL<<BUT4)
N
N#define BUT_ON 4
N#define BUT_ONL 20 
N
N#define butLUR_  101
N#define butU   253
N#define butU_  125
N#define butD   251
N#define butD_  123
N#define butL   247
N#define butL_  119
N#define butR   239
N#define butR_  111
N#define butE   254
N#define butE_  126
N#define butEL_  118
N#define butUD  249
N#define butUD_  121
N#define butLR   231
N#define butLR_   103
N#define butED_  122
N#define butDR_  107
N#define butDL_  115
N
N#define BUT_ON 4
N#define BUT_ONL 20 
N//-----------------------------------------------
Nvoid but_drv(void)
N{
Nchar i;
NLPC_GPIO1->FIODIR|=(1<<21);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIODIR|=(1<<21);
NLPC_GPIO1->FIOPIN&=~(1<<21);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIOPIN&=~(1<<21);
NLPC_GPIO1->FIODIR&=~((1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<26));
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIODIR&=~((1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<26));
NLPC_PINCON->PINMODE3&=~((1<<12)|(1<<13)|(1<<14)|(1<<15)|(1<<16)|(1<<17)|(1<<18)|(1<<19)|(1<<20)|(1<<21));
X((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINMODE3&=~((1<<12)|(1<<13)|(1<<14)|(1<<15)|(1<<16)|(1<<17)|(1<<18)|(1<<19)|(1<<20)|(1<<21));
N
NLPC_GPIO2->FIODIR|=(1<<8);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR|=(1<<8);
NLPC_GPIO2->FIOPIN&=~(1<<8);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOPIN&=~(1<<8);
Nfor(i=0;i<200;i++)
N{
N__nop();
N__nop();
N__nop();
N__nop();
N__nop();
N__nop();
N__nop();
N__nop();
N}
N
N			LPC_GPIO2->FIODIR|=(1<<8);
X			((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR|=(1<<8);
N			LPC_GPIO2->FIOPIN|=(1<<8);
X			((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOPIN|=(1<<8);
N
Nbut_n=((LPC_GPIO1->FIOPIN|(~((1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<26))))>>22)/*&0x0000001f*/;
Xbut_n=((((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIOPIN|(~((1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<26))))>>22) ;
N
N
N
Nif((but_n==1023UL)||(but_n!=but_s))
N 	{
N	speed=0;
N 
N   	if (((but0_cnt>=BUT_ON)||(but1_cnt!=0))&&(!l_but))
X   	if (((but0_cnt>=4)||(but1_cnt!=0))&&(!l_but))
N  		{
N   	     n_but=1;
N          but=but_s;
N
N          }
N   	if (but1_cnt>=but_onL_temp)
N  		{
N   	     n_but=1;
N 
N          but=but_s&0x7f;
N          }
N    	l_but=0;
N   	but_onL_temp=BUT_ONL;
X   	but_onL_temp=20;
N    	but0_cnt=0;
N  	but1_cnt=0;          
N     goto but_drv_out;
N  	}
Nelse if(but_n==but_s)
N 	{
N  	but0_cnt++;
N  	if(but0_cnt>=BUT_ON)
X  	if(but0_cnt>=4)
N  		{
N   		but0_cnt=0;
N   		but1_cnt++;
N   		if(but1_cnt>=but_onL_temp)
N   			{              
N    			but=but_s&0x7f;
N    			but1_cnt=0;
N    			n_but=1;
N    			     
N    			l_but=1;
N			if(speed)
N				{
N    				but_onL_temp=but_onL_temp>>1;
N        			if(but_onL_temp<=2) but_onL_temp=2;
N				}    
N   			}
N  		}
N 	}
Nbut_drv_out: 
Nbut_s=but_n; 
N   
N}
N
N//-----------------------------------------------
Nvoid but_an(void)
N{
Nsigned short temp_SS;
Nsigned short deep,i,cap,ptr;
Nchar av_head[4];
Nif(!n_but)return;
N/*else  					
N	{
N	plazma_but_an++;
N	goto but_an_end;
N	}*/
Nav_beep=0x0000;
Nav_rele=0x0000;
Nmnemo_cnt=MNEMO_TIME;
Nips_bat_av_stat=0;
N//bat_ips._av&=~1;
N
Nif((main_1Hz_cnt<10)&&((but==butU)||(but==butU_)||(but==butD)||(but==butD_)||(but==butL)||(but==butL_)||(but==butR)||(but==butR_)||(but==butE)||(but==butE_)))
Xif((main_1Hz_cnt<10)&&((but==253)||(but==125)||(but==251)||(but==123)||(but==247)||(but==119)||(but==239)||(but==111)||(but==254)||(but==126)))
N	{
N	__ee_spc_stat=spcOFF;
N	spc_stat=spcOFF;
N	}
Nif(but==butUD)
Xif(but==249)
N     {
N     if(ind!=iDeb)
X     if(a_ind . i!=iDeb)
N          {
N		c_ind=a_ind;
N		tree_up(iDeb,5,0,0);
N		
N          }
N     else 
N          {
N		tree_down(0,0);
N          }
N		
N		     
N     }
Nelse if(but==butLR)
Xelse if(but==231)
N	{
N	bSILENT=1;
N	beep_init(0x00000000,'S');
N	}
Nelse if(but==butUD_)
Xelse if(but==121)
N     {
N	//avar_bat_as_hndl(0,1);
N	}
N
Nelse if(but==butED_)
Xelse if(but==122)
N     {
N	if(!bCAN_OFF)bCAN_OFF=1;
N	else bCAN_OFF=0;
N	speed=0;
N	}
N
Nelse if(ind==iDeb)
Xelse if(a_ind . i==iDeb)
N	{
N	if(but==butR)
X	if(but==239)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		index_set=0;
X		a_ind . i_s=0;
N		gran_ring_char(&sub_ind,0,12);
X		gran_ring_char(&a_ind . s_i,0,12);
N		}
N	else if(but==butL)
X	else if(but==247)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		index_set=0;
X		a_ind . i_s=0;
N		gran_ring_char(&sub_ind,0,12);
X		gran_ring_char(&a_ind . s_i,0,12);
N		}
N		
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if(but==butU)
X		if(but==253)
N	     	{
N	     	sub_ind1--;
X	     	a_ind . s_i1--;
N	     	gran_char(&sub_ind1,0,30);
X	     	gran_char(&a_ind . s_i1,0,30);
N	     	}
N		if(but==butD)
X		if(but==251)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N	     	gran_char(&sub_ind1,0,30);
X	     	gran_char(&a_ind . s_i1,0,30);
N	     	}
N	     
N		if(but==butE)
X		if(but==254)
N	     	{
N	     	/*SET_REG(C2GSR,3,24,8);
N			C2MOD=0;
N			 bOUT_FREE2=1;*/
N
N			 // CAN interface 1, use IRQVec7, at 125kbit
N//can2_init(7,8,CANBitrate250k_60MHz);
N
N// Receive message with ID 102h on CAN 1
N//FullCAN_SetFilter(2,0x18e);
N			 }
N
N		if(but==butE)
X		if(but==254)
N	     	{
N			//lc640_write_int(EE_BAT1_ZAR_CNT,10);
N			ind_pointer=0;
N			ind=(i_enum)0;
X			a_ind . i=(i_enum)0;
N			sub_ind=0;
X			a_ind . s_i=0;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			sub_ind2=0;
X			a_ind . s_i2=0;
N			index_set=0;
X			a_ind . i_s=0;
N			}
N	     
N			
N		} 
N
N	 else if(sub_ind==5)
X	 else if(a_ind . s_i==5)
N	 	{
N		if(but==butE_)	numOfForvardBps_init();
X		if(but==126)	numOfForvardBps_init();
N		}
N				
N	 else if(sub_ind==5)
X	 else if(a_ind . s_i==5)
N	 	{
N		if(but==butE_)
X		if(but==126)
N		{
N		//can1_init(BITRATE62_5K6_25MHZ);
N		//FullCAN_SetFilter(0,0x18e);
N		LPC_CAN1->MOD&=~(1<<0);
X		((LPC_CAN_TypeDef *) ((0x40000000UL) + 0x44000) )->MOD&=~(1<<0);
N		}
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if(but==butU)
X		if(but==253)
N	     	{
N	     	sub_ind1--;
X	     	a_ind . s_i1--;
N	     	gran_char(&sub_ind1,0,1);
X	     	gran_char(&a_ind . s_i1,0,1);
N	     	}
N		if(but==butD)
X		if(but==251)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N	     	gran_char(&sub_ind1,0,1);
X	     	gran_char(&a_ind . s_i1,0,1);
N	     	}
N		}		
N		
N		
N			
N     else if(but==butU)
X     else if(but==253)
N	     {
N	     index_set--;
X	     a_ind . i_s--;
N	     gran_char(&index_set,0,4);
X	     gran_char(&a_ind . i_s,0,4);
N	     //lc640_write_int(ptr_ki_src[0],lc640_read_int(ptr_ki_src[0])+10);
N	     }	
N     else if(but==butD)
X     else if(but==251)
N	     {
N	     index_set++;
X	     a_ind . i_s++;
N	     gran_char(&index_set,0,4); 
X	     gran_char(&a_ind . i_s,0,4); 
N	     //lc640_write_int(ptr_ki_src[0],lc640_read_int(ptr_ki_src[0])-10);
N	     }	
N     else if(but==butE)
X     else if(but==254)
N         	{
N          //a=b[--ptr_ind];
N          can1_out(1,2,3,4,5,6,7,8);
X          mcp2515_transmit(1,2,3,4,5,6,7,8);
N          }   
N          
N     else if(but==butE_)
X     else if(but==126)
N         	{
N          //a=b[--ptr_ind];
N          can1_out_adr(TXBUFF,3);
N          }                      				
N	}
N
Nelse if(ind==iMn_VD)
Xelse if(a_ind . i==iMn_VD)
N	{
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,6+NUMIST);
X		gran_char(&a_ind . s_i,0,6+NUMIST);
N		}
N		
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,6+NUMIST);
X		gran_char(&a_ind . s_i,0,6+NUMIST);
N		}	
N
N	else if(but==butR)
X	else if(but==239)
N		{
N		//ind=iMn;
N		sub_ind=0;
X		a_ind . s_i=0;
N
N		}
N	else if(but==butL)
X	else if(but==247)
N		{
N		//ind=iMn;
N		sub_ind=0;
X		a_ind . s_i=0;
N
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=0;
X		a_ind . s_i=0;
N		}
N
N	else if(but==butLR_)
X	else if(but==103)
N		{
N		if(klbr_en)klbr_en=0;
N		else klbr_en=1;
N		}
N				
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			if(avar_ind_stat)
N				{
N				//ind=iAv_view;
N				//sub_ind=0;
N				tree_up(iAv_view,0,0,0);
N				while(!(avar_ind_stat&(1<<sub_ind)))
X				while(!(avar_ind_stat&(1<<a_ind . s_i)))
N					{
N					sub_ind++;
X					a_ind . s_i++;
N					if(sub_ind>=32)
X					if(a_ind . s_i>=32)
N						{
N						tree_down(0,0);
N						avar_ind_stat=0;
N						}
N					}
N				}																							
N			}
N
N		else if((sub_ind>1)&&(sub_ind<=(1+NUMIST)))
X		else if((a_ind . s_i>1)&&(a_ind . s_i<=(1+NUMIST)))
N		    	{
N		    	tree_up(iBps_elteh,0,0,sub_ind-2);
X		    	tree_up(iBps_elteh,0,0,a_ind . s_i-2);
N		    	} 
N
N
N		else if(sub_ind==(2+NUMIST))
X		else if(a_ind . s_i==(2+NUMIST))
N			{
N	     	tree_up(iBps_list,0,0,0);
N		    }		
N		else if(sub_ind==(3+NUMIST))
X		else if(a_ind . s_i==(3+NUMIST))
N			{
N			tree_up(iSet_prl,0,0,0);
N		    ret(50);
N		    parol_init();
N			}
N		else if(sub_ind==(4+NUMIST))
X		else if(a_ind . s_i==(4+NUMIST))
N			{
N			if(but==butE_)avar_uout_hndl(1);
X			if(but==126)avar_uout_hndl(1);
N			tree_up(iLog,0,0,0);
N		    ret(1000);
N			}
N		else if(sub_ind==(5+NUMIST))
X		else if(a_ind . s_i==(5+NUMIST))
N			{
N			sub_ind=0;
X			a_ind . s_i=0;
N			}
N		else if(sub_ind==(6+NUMIST))
X		else if(a_ind . s_i==(6+NUMIST))
N			{
N	     	tree_up(iPrltst,0,0,0);
N		    parol_init();
N			//tree_up(iRele_set,0,0,0);
N			}
N 		}
N	else if(but==butU_)
X	else if(but==125)
N		{
W "main.c" 6559 18 function "avar_sys_t_hndl" declared implicitly
N		if(sysTAvar==0)avar_sys_t_hndl(1,456);
N		else avar_sys_t_hndl(0,789);
N		}
N    }
N
N
N
Nelse if(ind==iMakb)
Xelse if(a_ind . i==iMakb)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind>7)sub_ind=7;
X		if(a_ind . s_i>7)a_ind . s_i=7;
N		//else if(sub_ind==1)sub_ind=0;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind<3)sub_ind=3;
X		if(a_ind . s_i<3)a_ind . s_i=3;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if((but==butL)||((sub_ind==simax)&&(but==butE)))
X	else if((but==247)||((a_ind . s_i==simax)&&(but==254)))
N	     {
N	     tree_down(0,0);
N	     ret(0);
N	     }
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=simax;
X		a_ind . s_i=simax;
N		}		    
N	}
N
N#ifndef _DEBUG_
Nelse if(ind==iBps)
Xelse if(a_ind . i==iBps)
N	{
N	ret_ind(0,0,0);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==3)sub_ind=1;
X		if(a_ind . s_i==3)a_ind . s_i=1;
N		else if(sub_ind==1)sub_ind=0;
X		else if(a_ind . s_i==1)a_ind . s_i=0;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind<3)sub_ind=3;
X		if(a_ind . s_i<3)a_ind . s_i=3;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N		
N	else if((but==butE)&&(sub_ind==4))
X	else if((but==254)&&(a_ind . s_i==4))
N		{
N		can1_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0x16,0x63,0,0,0,0);
N		}
N				
N	else if(((but==butE)&&(sub_ind==5))||(but))
X	else if(((but==254)&&(a_ind . s_i==5))||(but))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}	
N		
N	}	
Nelse if(ind==iBps_elteh)
Xelse if(a_ind . i==iBps_elteh)
N	{
N	ret_ind(0,0,0);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==4)sub_ind=2;
X		if(a_ind . s_i==4)a_ind . s_i=2;
N		else if(sub_ind==1)sub_ind=0;
X		else if(a_ind . s_i==1)a_ind . s_i=0;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind<3)sub_ind=3;
X		if(a_ind . s_i<3)a_ind . s_i=3;
N		if(sub_ind==4)index_set=4;
X		if(a_ind . s_i==4)a_ind . i_s=4;
N		if(sub_ind==5)sub_ind=7;
X		if(a_ind . s_i==5)a_ind . s_i=7;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if (but==butR)
X	else if (but==239)
N		{      
N		//bps[sub_ind1]._x_++;
N		//gran(&bps[sub_ind1]._x_,-50,50);
N		}
N		
N/*	else if (but==butL)
N		{      
N		bps[sub_ind1]._x_--;
N		gran(&bps[sub_ind1]._x_,-50,50);
N		}*/
N	
N	else if((but==butE)&&(sub_ind==7))
X	else if((but==254)&&(a_ind . s_i==7))
N		{
N		can1_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0x16,0x63,0,0,0,0);
N		}
N				
N	else if(((but==butE)&&(sub_ind==8))||(but==butL))
X	else if(((but==254)&&(a_ind . s_i==8))||(but==247))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}	
N	else if((but==butE)&&(sub_ind==9))
X	else if((but==254)&&(a_ind . s_i==9))
N		{
N		can1_out(sub_ind1,sub_ind1,CMND,VENT_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0x16,0x64,0,0,0,0);
N		}			
N	}			
Nelse if(ind==iNet)
Xelse if(a_ind . i==iNet)
N	{
N	ret(1000);
N	if((but==butL)||(but==butE))
X	if((but==247)||(but==254))
N	     {
N	     tree_down(0,0);
N	     ret(0);
N	     }
N	}
N
Nelse if(ind==iNet3)
Xelse if(a_ind . i==iNet3)
N	{
N	ret(1000);
N	ret_ind(0,0,0);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N	else if((but==butL)||((but==butE)&&(sub_ind==4)))
X	else if((but==247)||((but==254)&&(a_ind . s_i==4)))
N	     {
N	     tree_down(0,0);
N	     ret(0);
N	     }
N	}
Nelse if(ind==iNetEM)
Xelse if(a_ind . i==iNetEM)
N	{
N	ret(1000);
N	ret_ind(0,0,0);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N	else if((but==butL)||((but==butE)&&(sub_ind==4)))
X	else if((but==247)||((but==254)&&(a_ind . s_i==4)))
N	     {
N	     tree_down(0,0);
N	     ret(0);
N	     }
N	}
N
Nelse if(ind==iLoad)
Xelse if(a_ind . i==iLoad)
N	{
N	ret(1000);
N	if((but==butL)||(but==butE))
X	if((but==247)||(but==254))
N	     {
N	     tree_down(0,0);
N	     ret(0);
N	     }
N	}	
N
Nelse if(ind==iExtern)
Xelse if(a_ind . i==iExtern)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,8);
X		gran_char(&a_ind . s_i,0,8);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,8);		
X		gran_char(&a_ind . s_i,0,8);		
N		}
N
N	else if((but==butE)&&(sub_ind==8))
X	else if((but==254)&&(a_ind . s_i==8))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}	
N	}
N
Nelse if(ind==iVent)
Xelse if(a_ind . i==iVent)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,1,2);
X		gran_char(&a_ind . s_i,1,2);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,1,2);		
X		gran_char(&a_ind . s_i,1,2);		
N		}
N
N	else if (sub_ind==1)
X	else if (a_ind . s_i==1)
N		{
N          if((but==butR)||(but==butR_))
X          if((but==239)||(but==111))
N               {
N               pos_vent++;
N               }
N          else if((but==butL)||(but==butL_))
X          else if((but==247)||(but==119))
N               {
N               pos_vent--;
N               }
N
N		gran(&pos_vent,1,11);
N          lc640_write_int(EE_POS_VENT,pos_vent);		
X          lc640_write_int(0x10+500+92,pos_vent);		
N		}
N		
N	else if((but==butE)&&(sub_ind==2))
X	else if((but==254)&&(a_ind . s_i==2))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}	
N	}
Nelse if(ind==iAvt)
Xelse if(a_ind . i==iAvt)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMAVT);
X		gran_char(&a_ind . s_i,0,NUMAVT);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMAVT);		
X		gran_char(&a_ind . s_i,0,NUMAVT);		
N		}
N
N	else if((but==butE)&&(sub_ind==NUMAVT))
X	else if((but==254)&&(a_ind . s_i==NUMAVT))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}
N	}
Nelse if(ind==iEnerg)
Xelse if(a_ind . i==iEnerg)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4);		
X		gran_char(&a_ind . s_i,0,4);		
N		}
N
N	else if((but==butE)&&(sub_ind==4))
X	else if((but==254)&&(a_ind . s_i==4))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}
N     }
N
Nelse if(ind==iEnerg3)
Xelse if(a_ind . i==iEnerg3)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,8);
X		gran_char(&a_ind . s_i,0,8);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,8);		
X		gran_char(&a_ind . s_i,0,8);		
N		}
N
N	else if((but==butE)&&(sub_ind==8))
X	else if((but==254)&&(a_ind . s_i==8))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}
N     }
N
Nelse if((ind==iPrl_bat_in_out)||(ind==iSet_prl)||(ind==iK_prl)
Xelse if((a_ind . i==iPrl_bat_in_out)||(a_ind . i==iSet_prl)||(a_ind . i==iK_prl)
N	||(ind==iAusw_prl)
X	||(a_ind . i==iAusw_prl)
N	||(ind==iPrltst))
X	||(a_ind . i==iPrltst))
N	{
N	ret(50);
N	if(but==butR)
X	if(but==239)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_ring_char(&sub_ind,0,2);
X		gran_ring_char(&a_ind . s_i,0,2);
N		}
N	else if(but==butL)
X	else if(but==247)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_ring_char(&sub_ind,0,2);
X		gran_ring_char(&a_ind . s_i,0,2);
N		}	
N	else if(but==butU)
X	else if(but==253)
N		{
N		parol[sub_ind]++;
X		parol[a_ind . s_i]++;
N		gran_ring_char(&parol[sub_ind],0,9);
X		gran_ring_char(&parol[a_ind . s_i],0,9);
N		}	
N	else if(but==butD)
X	else if(but==251)
N		{
N		parol[sub_ind]--;
X		parol[a_ind . s_i]--;
N		gran_ring_char(&parol[sub_ind],0,9);
X		gran_ring_char(&parol[a_ind . s_i],0,9);
N		}	
N	else if(but==butE)
X	else if(but==254)
N		{
N		unsigned short tempU;
N		tempU=parol[2]+(parol[1]*10U)+(parol[0]*100U);
N		
N		if(ind==iPrl_bat_in_out)
X		if(a_ind . i==iPrl_bat_in_out)
N		     {
N		     if(BAT_IS_ON[sub_ind1]!=bisON)
X		     if(BAT_IS_ON[a_ind . s_i1]!=bisON)
N		          {
N		          if(tempU==PAROL_BAT_IN)
X		          if(tempU==722)
N		               {
N					//tree_up(iPrl_bat_in_sel,0,0,sub_ind1);
N					
N		               lc640_write_int(ADR_EE_BAT_IS_ON[sub_ind1],bisON);
X		               lc640_write_int(ADR_EE_BAT_IS_ON[a_ind . s_i1],bisON);
N					lc640_write_int(EE_BAT_TYPE,0);
X					lc640_write_int(0x10+100+142,0);
N		               lc640_write_int(ADR_EE_BAT_DAY_OF_ON[sub_ind1],LPC_RTC->DOM);
X		               lc640_write_int(ADR_EE_BAT_DAY_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM);
N		               lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[sub_ind1],LPC_RTC->MONTH);
X		               lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH);
N		               lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[sub_ind1],LPC_RTC->YEAR);
X		               lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR);
N		               lc640_write_int(ADR_EE_BAT_C_REAL[sub_ind1],0x5555);
X		               lc640_write_int(ADR_EE_BAT_C_REAL[a_ind . s_i1],0x5555);
N		               lc640_write_int(ADR_EE_BAT_RESURS[sub_ind1],0);
X		               lc640_write_int(ADR_EE_BAT_RESURS[a_ind . s_i1],0);
N					lc640_write_int(ADR_EE_BAT_ZAR_CNT[sub_ind1],0);
X					lc640_write_int(ADR_EE_BAT_ZAR_CNT[a_ind . s_i1],0);
N		               
N		               lc640_write(KE_PTR,0);
X		               lc640_write(996,0);
N					lc640_write(VZ_PTR,0);
X					lc640_write(1016,0);
N					lc640_write(WRK_PTR,0);
X					lc640_write(1020,0);
N					lc640_write(KE_CNT,0);
X					lc640_write(998,0);
N					lc640_write(VZ_CNT,0);
X					lc640_write(1018,0);
N					lc640_write(WRK_CNT,0);
X					lc640_write(1022,0);
N					lc640_write(BAT_AVAR_CNT,0);
X					lc640_write(1014,0);
N					lc640_write(BAT_AVAR_PTR,0);					
X					lc640_write(1012,0);					
N		               
N                         tree_down(0,0);
N                         ret(0); 
N		               }
N		          else
N		               {
N		               tree_down(0,0);
N	    	               show_mess("                    ",
N	          				"       Пароль       ",
N	          				"     неверный!!!    ",
N	          				"                    ",1000);
N     	               }
N		          }      
N               else		          
N		          {
N		          if(tempU==PAROL_BAT_OUT)
X		          if(tempU==722)
N		               {
N		               lc640_write_int(ADR_EE_BAT_IS_ON[sub_ind1],bisOFF);
X		               lc640_write_int(ADR_EE_BAT_IS_ON[a_ind . s_i1],bisOFF);
N		               lc640_write_int(ADR_EE_BAT_DAY_OF_ON[sub_ind1],LPC_RTC->DOM);
X		               lc640_write_int(ADR_EE_BAT_DAY_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM);
N		               lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[sub_ind1],LPC_RTC->MONTH);
X		               lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH);
N		               lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[sub_ind1],LPC_RTC->YEAR);
X		               lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR);
N
N		               tree_down(0,0);
N		               ret(0);
N		               
N		               }
N	               else
N		               {
N		               tree_down(0,0);
N	    	               show_mess("                    ",
N	          				"       Пароль       ",
N	          				"     неверный!!!    ",
N	          				"                    ",1000);
N		               }		               
N		          }     
N               }
N		
N		else if(ind==iSet_prl)
X		else if(a_ind . i==iSet_prl)
N			{
N	     	if(tempU==PAROL_SET) 
X	     	if(tempU==184) 
N				{
N				tree_down(0,0);
N
N				#ifdef UKU_VD
N				tree_up(iSet_VD,0,0,0);
N				#endif
N
N				ret(1000);
N				}
N			else 
N				{
N		          tree_down(0,0);
N	    	          show_mess("                    ",
N	          			"       Пароль       ",
N	          			"     неверный!!!    ",
N	          			"                    ",1000);
N				}
N			}
N		else	if(ind==iK_prl)
X		else	if(a_ind . i==iK_prl)
N			{
N	     	if(tempU==PAROL_KALIBR) 
X	     	if(tempU==873) 
N				{
N				tree_down(0,0);
N				tree_up(iK_VD,0,0,0);
N				ret(100);				
N				}
N			else 
N				{
N		          tree_down(0,0);
N	    	          show_mess("                    ",
N	          			"       Пароль       ",
N	          			"     неверный!!!    ",
N	          			"                    ",1000);
N				}
N			} 
N	
N		else	if(ind==iAusw_prl)
X		else	if(a_ind . i==iAusw_prl)
N			{
N	     	if(tempU==PAROL_AUSW) 
X	     	if(tempU==949) 
N				{
N				tree_down(0,0);
N				tree_up(iAusw_set,1,0,0);
N				default_temp=10;
N				ret(0);
N				}
N			else 
N				{
N		          tree_down(0,0);
N	    	          show_mess("                    ",
N	          			"       Пароль       ",
N	          			"     неверный!!!    ",
N	          			"                    ",1000);
N				}
N			} 	
N			
N		else	if(ind==iSet_st_prl)
X		else	if(a_ind . i==iSet_st_prl)
N			{
N	     	if(tempU==PAROL_DEFAULT) 
X	     	if(tempU==295) 
N				{
N	//			ind=iDefault;
N				sub_ind=1;
X				a_ind . s_i=1;
N				index_set=0;
X				a_ind . i_s=0;
N				default_temp=10;
N				}
N			else 
N				{
N		          tree_down(0,0);
N	    	          show_mess("                    ",
N	          			"       Пароль       ",
N	          			"     неверный!!!    ",
N	          			"                    ",1000);
N				}
N			} 
N						
N		else if(ind==iPrltst)
X		else if(a_ind . i==iPrltst)
N			{
N			if(tempU==PAROL_TST) 
X			if(tempU==999) 
N				{
N				tree_down(0,0);
N
N				tree_up(iTst_VD,0,0,0);
N				
N				tst_state[0]=tstOFF;
N				tst_state[1]=tstOFF;
N				tst_state[2]=tstOFF;
N				tst_state[3]=tstOFF;
N				tst_state[4]=tstOFF;
N				tst_state[5]=tstOFF;
N				tst_state[6]=tstOFF;
N				tst_state[7]=tstOFF;
N				tst_state[9]=tstOFF;
N				tst_state[10]=(enum_tst_state)0;
N				ret(10000);				
N
N
N				}
N	  		else 
N				{
N		          tree_down(0,0);
N	    	          show_mess("                    ",
N	          			"       Пароль       ",
N	          			"     неверный!!!    ",
N	          			"                    ",1000);
N				}
N			}
N		}
N	}
N
N
N#endif
Nelse if(ind==iPrl_bat_in_sel)
Xelse if(a_ind . i==iPrl_bat_in_sel)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,1);
X		gran_char(&a_ind . s_i,0,1);
N		}
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,1);
X		gran_char(&a_ind . s_i,0,1);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			lc640_write_int(ADR_EE_BAT_IS_ON[sub_ind1],bisON);
X			lc640_write_int(ADR_EE_BAT_IS_ON[a_ind . s_i1],bisON);
N		     lc640_write_int(ADR_EE_BAT_DAY_OF_ON[sub_ind1],LPC_RTC->DOM);
X		     lc640_write_int(ADR_EE_BAT_DAY_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM);
N		     lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[sub_ind1],LPC_RTC->MONTH);
X		     lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH);
N		     lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[sub_ind1],LPC_RTC->YEAR);
X		     lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR);
N		     lc640_write_int(ADR_EE_BAT_C_REAL[sub_ind1],0x5555);
X		     lc640_write_int(ADR_EE_BAT_C_REAL[a_ind . s_i1],0x5555);
N		     lc640_write_int(ADR_EE_BAT_RESURS[sub_ind1],0);
X		     lc640_write_int(ADR_EE_BAT_RESURS[a_ind . s_i1],0);
N			lc640_write_int(ADR_EE_BAT_ZAR_CNT[sub_ind1],0);
X			lc640_write_int(ADR_EE_BAT_ZAR_CNT[a_ind . s_i1],0);
N			//lc640_write_int(ADR_EE_BAT_TYPE[sub_ind1],0);
N		               
N		     lc640_write(KE_PTR,0);
X		     lc640_write(996,0);
N			lc640_write(VZ_PTR,0);
X			lc640_write(1016,0);
N			lc640_write(WRK_PTR,0);
X			lc640_write(1020,0);
N			lc640_write(KE_CNT,0);
X			lc640_write(998,0);
N			lc640_write(VZ_CNT,0);
X			lc640_write(1018,0);
N			lc640_write(WRK_CNT,0);
X			lc640_write(1022,0);
N			lc640_write(BAT_AVAR_CNT,0);
X			lc640_write(1014,0);
N			lc640_write(BAT_AVAR_PTR,0);					
X			lc640_write(1012,0);					
N		               
N               tree_down(-1,0);
N               ret(0);
N 
N			}
N		else if (sub_ind==1)
X		else if (a_ind . s_i==1)
N			{
N			lc640_write_int(ADR_EE_BAT_IS_ON[sub_ind1],bisON);
X			lc640_write_int(ADR_EE_BAT_IS_ON[a_ind . s_i1],bisON);
N		     lc640_write_int(ADR_EE_BAT_DAY_OF_ON[sub_ind1],LPC_RTC->DOM);
X		     lc640_write_int(ADR_EE_BAT_DAY_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM);
N		     lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[sub_ind1],LPC_RTC->MONTH);
X		     lc640_write_int(ADR_EE_BAT_MONTH_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH);
N		     lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[sub_ind1],LPC_RTC->YEAR);
X		     lc640_write_int(ADR_EE_BAT_YEAR_OF_ON[a_ind . s_i1],((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR);
N		     lc640_write_int(ADR_EE_BAT_C_REAL[sub_ind1],0x5555);
X		     lc640_write_int(ADR_EE_BAT_C_REAL[a_ind . s_i1],0x5555);
N		     lc640_write_int(ADR_EE_BAT_RESURS[sub_ind1],0);
X		     lc640_write_int(ADR_EE_BAT_RESURS[a_ind . s_i1],0);
N			lc640_write_int(ADR_EE_BAT_ZAR_CNT[sub_ind1],0);
X			lc640_write_int(ADR_EE_BAT_ZAR_CNT[a_ind . s_i1],0);
N			//lc640_write_int(ADR_EE_BAT_TYPE[sub_ind1],1);
N		               
N		     lc640_write(KE_PTR,0);
X		     lc640_write(996,0);
N			lc640_write(VZ_PTR,0);
X			lc640_write(1016,0);
N			lc640_write(WRK_PTR,0);
X			lc640_write(1020,0);
N			lc640_write(KE_CNT,0);
X			lc640_write(998,0);
N			lc640_write(VZ_CNT,0);
X			lc640_write(1018,0);
N			lc640_write(WRK_CNT,0);
X			lc640_write(1022,0);
N			lc640_write(BAT_AVAR_CNT,0);
X			lc640_write(1014,0);
N			lc640_write(BAT_AVAR_PTR,0);					
X			lc640_write(1012,0);					
N		               
N               tree_down(-1,0);
N               ret(0);
N	    	     show_mess("    Не забудьте     ",
N	          		"  настроить канал   ",
N	          		"       связи        ",
N	          		"     с батареей.    ",3000);			 
N			}
N		}
N	}
N
Nelse if(ind==iSpc)
Xelse if(a_ind . i==iSpc)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{   
N            //   tree_up(iSpc_prl_vz,0,0,0);
N			parol_init();
N			}
N		else if(sub_ind==1)
X		else if(a_ind . s_i==1)
N			{
N            //tree_up(iAvz,0,0,0);
N            parol_init();
N			}			
N		else if((sub_ind==2)||(sub_ind==3))
X		else if((a_ind . s_i==2)||(a_ind . s_i==3))
N			{
N            //tree_up(iSpc_prl_ke,0,0,sub_ind-2);
N            parol_init();
N			} 
N		else if(sub_ind==4)
X		else if(a_ind . s_i==4)
N			{
N			tree_down(0,0);
N			ret(0);
N			}	
N		}
N	else if(but==butL)
X	else if(but==247)
N		{
N		tree_down(0,0);
N		ret(0);
N		}			
N	}
Nelse if(ind==iSpc_termocompensat)
Xelse if(a_ind . i==iSpc_termocompensat)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{   
N            //tree_up(iSpc_prl_vz,0,0,0);
N			parol_init();
N			}
N		else if(sub_ind==1)
X		else if(a_ind . s_i==1)
N			{
N            //tree_up(iAvz,0,0,0);
N            parol_init();
N			}			
N		else if(sub_ind==2)
X		else if(a_ind . s_i==2)
N			{
N            //tree_up(iSpc_prl_ke,0,0,0);
N            parol_init();
N			} 
N		else if(sub_ind==3)
X		else if(a_ind . s_i==3)
N			{
N			tree_down(0,0);
N			ret(0);
N			}	
N		}
N	else if(but==butL)
X	else if(but==247)
N		{
N		tree_down(0,0);
N		ret(0);
N		}
N	}
N
N
N
Nelse if(ind==iLog)
Xelse if(a_ind . i==iLog)
N	{
N	ret_ind_sec(0,0);
N	ret_ind(0,0,0);
N	if (but==butU)
X	if (but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,av_j_si_max+1);
X		gran_char(&a_ind . s_i,0,av_j_si_max+1);
N		}
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,av_j_si_max+1);
X		gran_char(&a_ind . s_i,0,av_j_si_max+1);
N          
N		}  
N
N	else if (but==butD_)
X	else if (but==123)
N		{
N		sub_ind=av_j_si_max;
X		a_ind . s_i=av_j_si_max;
N		} 
N		 
N	else if (but==butL)
X	else if (but==247)
N		{
N		tree_down(0,0);
N		ret(0);
N		}  
N		
N	else if(but==butE)
X	else if(but==254)
N		{  
N		if(sub_ind==av_j_si_max+1)
X		if(a_ind . s_i==av_j_si_max+1)
N			{
N			lc640_write(CNT_EVENT_LOG,0);
X			lc640_write(1024+1024+512+1024+2,0);
N			lc640_write(PTR_EVENT_LOG,0);
X			lc640_write(1024+1024+512+1024,0);
N			tree_down(0,0);
N			avar_ind_stat=0;
N			avar_stat=0;
N			avar_stat_old=0;				
N			}
N					
N		else if(sub_ind==av_j_si_max)
X		else if(a_ind . s_i==av_j_si_max)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N			
N		else 
N			{
N			/*ind=iLog_;
N			sub_ind1=sub_ind;
N			index_set=0;
N			sub_ind=0;*/
N			tree_up(iLog_,0,0,sub_ind);
X			tree_up(iLog_,0,0,a_ind . s_i);
N			}	
N			
N		} 
N
N	else if(but==butR)
X	else if(but==239)
N		{
N	    //	avar_bat_hndl(0,1);	
N		}
N	else if(but==butR_)
X	else if(but==111)
N		{
N	    	//avar_bat_hndl(0,0);	
N		}		
N	else if(but==butL)
X	else if(but==247)
N		{
N	    	//avar_s_hndl(1,0,1);	
N		}
N				
N	else if(but==butL_)
X	else if(but==119)
N		{           
N		/*lc640_write(CNT_EVENT_LOG,0);
N		lc640_write(PTR_EVENT_LOG,0);
N		ind=iMn;
N		sub_ind=cnt_of_slave+10;
N		index_set=0;*/				
N	
N		}	 		
N	}
N
Nelse if(ind==iLog_)
Xelse if(a_ind . i==iLog_)
N	{          
N	if(but==butU)
X	if(but==253)
N		{
N		index_set--;
X		a_ind . i_s--;
N		gran_char(&index_set,0,av_j_si_max);
X		gran_char(&a_ind . i_s,0,av_j_si_max);
N		}
N	else if(but==butD)
X	else if(but==251)
N		{
N		index_set++;
X		a_ind . i_s++;
N		gran_char(&index_set,0,av_j_si_max);
X		gran_char(&a_ind . i_s,0,av_j_si_max);
N		}
N	else 
N		{
N		/*ind=iLog;
N		sub_ind=sub_ind1;*/
N		tree_down(0,0/*sub_ind1-sub_ind*/);
N		}		
N	}	
N
Nelse if(ind==iSet)
Xelse if(a_ind . i==iSet)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==7)index_set=6;
X		if(a_ind . s_i==7)a_ind . i_s=6;
N		if(sub_ind==8)sub_ind=9;
X		if(a_ind . s_i==8)a_ind . s_i=9;
N		if(sub_ind==11)index_set=10;
X		if(a_ind . s_i==11)a_ind . i_s=10;
N		if(sub_ind==12)sub_ind=13;
X		if(a_ind . s_i==12)a_ind . s_i=13;
N          if(sub_ind==32)
X          if(a_ind . s_i==32)
N               {
N               index_set=31;
X               a_ind . i_s=31;
N               }
N          if(sub_ind==34)
X          if(a_ind . s_i==34)
N               {
N               sub_ind=35;
X               a_ind . s_i=35;
N               //index_set=31;
N               }
N		
N		gran_char(&sub_ind,0,37);
X		gran_char(&a_ind . s_i,0,37);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==8)sub_ind=7;
X		if(a_ind . s_i==8)a_ind . s_i=7;
N		if(sub_ind==12)sub_ind=9;
X		if(a_ind . s_i==12)a_ind . s_i=9;
N          if(sub_ind==33)
X          if(a_ind . s_i==33)
N               {
N               sub_ind=32;
X               a_ind . s_i=32;
N		     //index_set=29;
N               }
N		gran_char(&sub_ind,0,37);
X		gran_char(&a_ind . s_i,0,37);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=35;
X		a_ind . s_i=35;
N		}
N		
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N			#ifdef UKU_GLONASS
S	          tree_up(iDef_GLONASS,0,0,0);
N			#endif
N			#ifdef UKU_3U
S	          tree_up(iDef_3U,0,0,0);
N			#endif
N			#ifdef UKU
S	          tree_up(iDef,0,0,0);
N			#endif
N			#ifdef UKU_6U
S	          tree_up(iDef_6U,0,0,0);
N			#endif
N	          ret(1000);
N	          default_temp=10;
N	          }
N
N
N	     }	
N	
N     else if(sub_ind==1)
X     else if(a_ind . s_i==1)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_up(iSet_T,0,0,0);
N		     ret(1000);
N		     phase=0;
N		     }
N		}	
N					 
N     else if(sub_ind==2)
X     else if(a_ind . s_i==2)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N			#ifdef UKU_3U
S		     tree_up(iStr_3U,0,0,0);
S		     ret(1000);
S		     index_set=0;
N			#endif
N			#ifdef UKU_GLONASS
S		     tree_up(iStr_GLONASS,0,0,0);
S		     ret(1000);
S		     index_set=0;
N			#endif
N			#ifdef UKU_RSTKM
S		     tree_up(iStr_RSTKM,0,0,0);
S		     ret(1000);
S		     index_set=0;
N			#endif
N			#ifdef UKU_KONTUR
S		     tree_up(iStr_KONTUR,0,0,0);
S		     ret(1000);
S		     index_set=0;
N			#endif
N			#ifdef UKU_6U
S		     tree_up(iStr_6U,0,0,0);
S		     ret(1000);
S		     index_set=0;
N			#endif
N
N			#ifdef UKU
S		     tree_up(iStr,0,0,0);
S		     ret(1000);
S		     index_set=0;
N			#endif
N
N
N
N		     }
N		}	
N	
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N	     {
N		if(but==butE)
X		if(but==254)
N		     {		
N			tree_up(iKlimat,0,0,0);
N			}
N	     }
N
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N	     {
N	     if(but==butR)MNEMO_TIME++;
X	     if(but==239)MNEMO_TIME++;
N	     else if(but==butR_)MNEMO_TIME+=10;
X	     else if(but==111)MNEMO_TIME+=10;
N	     else if(but==butL)MNEMO_TIME--;
X	     else if(but==247)MNEMO_TIME--;
N	     else if(but==butL_)MNEMO_TIME-=10;
X	     else if(but==119)MNEMO_TIME-=10;
N
N	     if(((MNEMO_TIME<5)||(MNEMO_TIME>60))&&(MNEMO_ON!=mnOFF))lc640_write_int(EE_MNEMO_ON,mnOFF);	
X	     if(((MNEMO_TIME<5)||(MNEMO_TIME>60))&&(MNEMO_ON!=mnOFF))lc640_write_int(0x10+100+72,mnOFF);	
N	     if(((MNEMO_TIME>=5)&&(MNEMO_TIME<=60))&&(MNEMO_ON!=mnON))lc640_write_int(EE_MNEMO_ON,mnON);
X	     if(((MNEMO_TIME>=5)&&(MNEMO_TIME<=60))&&(MNEMO_ON!=mnON))lc640_write_int(0x10+100+72,mnON);
N	     gran((signed short*)&MNEMO_TIME,4,61);
N	     lc640_write_int(EE_MNEMO_TIME,MNEMO_TIME);
X	     lc640_write_int(0x10+100+74,MNEMO_TIME);
N	     speed=1;
N	     }
N				     		
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N	     {
N		if(ZV_ON)ZV_ON=0;
N		else ZV_ON=1;
N	     lc640_write_int(EE_ZV_ON,ZV_ON);
X	     lc640_write_int(0x10+100+18,ZV_ON);
N	     speed=1;
N	     }	
N	
N	else if(sub_ind==7)
X	else if(a_ind . s_i==7)
N	     {
N		if(AV_OFF_AVT)AV_OFF_AVT=0;
N		else AV_OFF_AVT=1;
N	     lc640_write_int(EE_AV_OFF_AVT,AV_OFF_AVT);
X	     lc640_write_int(0x10+100+12,AV_OFF_AVT);
N	     speed=1;
N	     }	
N
N	else if(sub_ind==9)
X	else if(a_ind . s_i==9)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N	          tree_up(iApv,0,0,0);
N	          ret(1000);
N	          }
N	     }	
N
N	else if(sub_ind==10)
X	else if(a_ind . s_i==10)
N	     {
N//		if(PAR)PAR=0;
N//		else PAR=1;
N//	     lc640_write_int(EE_PAR,PAR);
N	     speed=1;
N	     }
N
N	else if(sub_ind==11)
X	else if(a_ind . s_i==11)
N	     {
N	     if(but==butR)TBAT++;
X	     if(but==239)TBAT++;
N	     else if(but==butR_)TBAT+=10;
X	     else if(but==111)TBAT+=10;
N	     else if(but==butL)TBAT--;
X	     else if(but==247)TBAT--;
N	     else if(but==butL_)TBAT-=10;
X	     else if(but==119)TBAT-=10;
N	     gran(&TBAT,5,60);
N	     lc640_write_int(EE_TBAT,TBAT);
X	     lc640_write_int(0x10+100+78,TBAT);
N	     speed=1;
N	     }	
N	                    	     	
N	else if(sub_ind==13)
X	else if(a_ind . s_i==13)
N	     {
N	     if(but==butR)UMAX++;
X	     if(but==239)UMAX++;
N	     else if(but==butR_)UMAX+=10;
X	     else if(but==111)UMAX+=10;
N	     else if(but==butL)UMAX--;
X	     else if(but==247)UMAX--;
N	     else if(but==butL_)UMAX-=10;
X	     else if(but==119)UMAX-=10;
N		#ifdef UKU206_220
S		gran(&UMAX,2000,3000);
N		#else
N	     gran(&UMAX,10,1000);
N		#endif
N	     lc640_write_int(EE_UMAX,UMAX);
X	     lc640_write_int(0x10+100+4,UMAX);
N	     speed=1;
N	     }
N	else if(sub_ind==14)
X	else if(a_ind . s_i==14)
N	     {
N/*	     if(but==butR)DU++;
N	     else if(but==butR_)DU+=10;
N	     else if(but==butL)DU--;
N	     else if(but==butL_)DU-=10;
N	     gran(&DU,10,1000);*/
N/*	     if(but==butL)DU++;
N	     else if(but==butL_)DU+=10;
N	     else if(but==butR)DU--;
N	     else if(but==butR_)DU-=10;
N	     gran(&DU,50,UB20-250);
N	     lc640_write_int(EE_DU,DU);
N	     speed=1;*/
N	     }	     
N	else if(sub_ind==15)
X	else if(a_ind . s_i==15)
N	     {
N	     /*if(but==butR)UB0++;
N	     else if(but==butR_)UB0+=10;
N	     else if(but==butL)UB0--;
N	     else if(but==butL_)UB0-=10;
N		gran(&UB0,400,800);
N          lc640_write_int(EE_UB0,UB0);
N	     speed=1; */
N	     }
N	     
N	else if(sub_ind==16)
X	else if(a_ind . s_i==16)
N	     {
N/*	     if(but==butR)UB20++;
N	     else if(but==butR_)UB20+=10;
N	     else if(but==butL)UB20--;
N	     else if(but==butL_)UB20-=10;
N		gran(&UB20,400,800);
N	     lc640_write_int(EE_UB20,UB20);
N	     speed=1; */
N	     }	
N
N	else if(sub_ind==17)
X	else if(a_ind . s_i==17)
N	     {
N	     if(but==butR)USIGN++;
X	     if(but==239)USIGN++;
N	     else if(but==butR_)USIGN+=10;
X	     else if(but==111)USIGN+=10;
N	     else if(but==butL)USIGN--;
X	     else if(but==247)USIGN--;
N	     else if(but==butL_)USIGN-=10;
X	     else if(but==119)USIGN-=10;
N		gran(&USIGN,40,100);
N	     lc640_write_int(EE_USIGN,USIGN);
X	     lc640_write_int(0x10+100+14,USIGN);
N	     speed=1;
N	     }	
N	else if(sub_ind==18)
X	else if(a_ind . s_i==18)
N	     {
N	     if(but==butR)UMN++;
X	     if(but==239)UMN++;
N	     else if(but==butR_)UMN+=10;
X	     else if(but==111)UMN+=10;
N	     else if(but==butL)UMN--;
X	     else if(but==247)UMN--;
N	     else if(but==butL_)UMN-=10;
X	     else if(but==119)UMN-=10;
N	     gran(&UMN,1,220);
N	     lc640_write_int(EE_UMN,UMN);
X	     lc640_write_int(0x10+100+16,UMN);
N	     speed=1;
N	     }	
N
N	else if(sub_ind==19)
X	else if(a_ind . s_i==19)
N	     {
N	     if(but==butR)U0B++;
X	     if(but==239)U0B++;
N	     else if(but==butR_)U0B+=10;
X	     else if(but==111)U0B+=10;
N	     else if(but==butL)U0B--;
X	     else if(but==247)U0B--;
N	     else if(but==butL_)U0B-=10;
X	     else if(but==119)U0B-=10;
N		gran(&U0B,400,800);
N	     lc640_write_int(EE_U0B,U0B);
X	     lc640_write_int(0x10+100+32,U0B);
N	     speed=1;
N	     }	
N	     
N	else if(sub_ind==20)
X	else if(a_ind . s_i==20)
N	     {
N	     if(but==butR)IKB++;
X	     if(but==239)IKB++;
N	     else if(but==butR_)IKB+=10;
X	     else if(but==111)IKB+=10;
N	     else if(but==butL)IKB--;
X	     else if(but==247)IKB--;
N	     else if(but==butL_)IKB-=10;
X	     else if(but==119)IKB-=10;
N	     gran(&IKB,1,500);
N	     lc640_write_int(EE_IKB,IKB);
X	     lc640_write_int(0x10+100+20,IKB);
N	     speed=1;
N	     }		
N            
N	else if(sub_ind==21)
X	else if(a_ind . s_i==21)
N	     {
N	     if(but==butR)IZMAX++;
X	     if(but==239)IZMAX++;
N	     else if(but==butR_)IZMAX+=10;
X	     else if(but==111)IZMAX+=10;
N	     else if(but==butL)IZMAX--;
X	     else if(but==247)IZMAX--;
N	     else if(but==butL_)IZMAX-=10;
X	     else if(but==119)IZMAX-=10;
N		gran(&IZMAX,10,1000);
N	     lc640_write_int(EE_IZMAX,IZMAX);
X	     lc640_write_int(0x10+100+30,IZMAX);
N	     speed=1;
N	     }   
N
N	else if(sub_ind==22)
X	else if(a_ind . s_i==22)
N	     {
N	     if(but==butR)IMAX++;
X	     if(but==239)IMAX++;
N	     else if(but==butR_)IMAX+=10;
X	     else if(but==111)IMAX+=10;
N	     else if(but==butL)IMAX--;
X	     else if(but==247)IMAX--;
N	     else if(but==butL_)IMAX-=10;
X	     else if(but==119)IMAX-=10;
N		gran(&IMAX,10,1000);
N	     lc640_write_int(EE_IMAX,IMAX);
X	     lc640_write_int(0x10+100+24,IMAX);
N	     speed=1;
N	     }		
N	     
N	else if(sub_ind==23)
X	else if(a_ind . s_i==23)
N	     {
N	     if(but==butR)IMIN++;
X	     if(but==239)IMIN++;
N	     else if(but==butR_)IMIN+=10;
X	     else if(but==111)IMIN+=10;
N	     else if(but==butL)IMIN--;
X	     else if(but==247)IMIN--;
N	     else if(but==butL_)IMIN-=10;
X	     else if(but==119)IMIN-=10;
N	     gran(&IMIN,40,IMAX-10);
N	     lc640_write_int(EE_IMIN,IMIN);
X	     lc640_write_int(0x10+100+26,IMIN);
N	     speed=1;
N	     }
N	
N	else if(sub_ind==24)
X	else if(a_ind . s_i==24)
N	     {
N/*	     if ((but==butR)||(but==butR_))UVZ+=1;
N		if ((but==butL)||(but==butL_))UVZ-=1;
N		gran(&UVZ,UB20,UMAX); 	          
N		lc640_write_int(EE_UVZ,UVZ);
N	     speed=1;					 */
N	     }
N	     
N	else if(sub_ind==25)
X	else if(a_ind . s_i==25)
N		{
N		if ((but==butR)||(but==butR_))TZAS++;
X		if ((but==239)||(but==111))TZAS++;
N		if ((but==butL)||(but==butL_))TZAS--;
X		if ((but==247)||(but==119))TZAS--;
N		gran(&TZAS,0,3);
N		lc640_write_int(EE_TZAS,TZAS);
X		lc640_write_int(0x10+100+34,TZAS);
N		speed=1; 
N		}	
N			       	        
N	else if(sub_ind==26)
X	else if(a_ind . s_i==26)
N	     {
N	     if(but==butR)TMAX++;
X	     if(but==239)TMAX++;
N	     else if(but==butR_)TMAX+=2;
X	     else if(but==111)TMAX+=2;
N	     else if(but==butL)TMAX--;
X	     else if(but==247)TMAX--;
N	     else if(but==butL_)TMAX-=2;
X	     else if(but==119)TMAX-=2;
N	     gran(&TMAX,10,100);
N	     lc640_write_int(EE_TMAX,TMAX);
X	     lc640_write_int(0x10+100+10,TMAX);
N	     speed=1;
N	     }	
N	
N	else if(sub_ind==27)
X	else if(a_ind . s_i==27)
N	     {
N	     if(but==butR)TSIGN++;
X	     if(but==239)TSIGN++;
N	     else if(but==butR_)TSIGN+=2;
X	     else if(but==111)TSIGN+=2;
N	     else if(but==butL)TSIGN--;
X	     else if(but==247)TSIGN--;
N	     else if(but==butL_)TSIGN-=2;
X	     else if(but==119)TSIGN-=2;
N	     gran(&TSIGN,10,100);
N	     lc640_write_int(EE_TSIGN,TSIGN);
X	     lc640_write_int(0x10+100+82,TSIGN);
N	     speed=1;
N	     }	     
N	else if(sub_ind==28)
X	else if(a_ind . s_i==28)
N	     {
N	     if(but==butR)TBATMAX++;
X	     if(but==239)TBATMAX++;
N	     else if(but==butR_)TBATMAX+=2;
X	     else if(but==111)TBATMAX+=2;
N	     else if(but==butL)TBATMAX--;
X	     else if(but==247)TBATMAX--;
N	     else if(but==butL_)TBATMAX-=2;
X	     else if(but==119)TBATMAX-=2;
N	     gran(&TBATMAX,10,100);
N	     lc640_write_int(EE_TBATMAX,TBATMAX);
X	     lc640_write_int(0x10+100+88,TBATMAX);
N	     speed=1;
N	     }	
N	
N	else if(sub_ind==29)
X	else if(a_ind . s_i==29)
N	     {
N	     if(but==butR)TBATSIGN++;
X	     if(but==239)TBATSIGN++;
N	     else if(but==butR_)TBATSIGN+=2;
X	     else if(but==111)TBATSIGN+=2;
N	     else if(but==butL)TBATSIGN--;
X	     else if(but==247)TBATSIGN--;
N	     else if(but==butL_)TBATSIGN-=2;
X	     else if(but==119)TBATSIGN-=2;
N	     gran(&TBATSIGN,10,100);
N	     lc640_write_int(EE_TBATSIGN,TBATSIGN);
X	     lc640_write_int(0x10+100+90,TBATSIGN);
N	     speed=1;
N	     }	
N     	     	     		     	     
N    else if(sub_ind==30)
X    else if(a_ind . s_i==30)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_up(iExt_set,0,0,0);
N		     ret(1000);
N		     }
N		}
N
N    else if(sub_ind==31)
X    else if(a_ind . s_i==31)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_up(iLan_set,0,0,0);
N		     ret(1000);
N		     }
N		}
N	else if(sub_ind==32)
X	else if(a_ind . s_i==32)
N	     {
N	     if(but==butR)POWER_CNT_ADRESS++;
X	     if(but==239)POWER_CNT_ADRESS++;
N	     else if(but==butR_)POWER_CNT_ADRESS+=10;
X	     else if(but==111)POWER_CNT_ADRESS+=10;
N	     else if(but==butL)POWER_CNT_ADRESS--;
X	     else if(but==247)POWER_CNT_ADRESS--;
N	     else if(but==butL_)POWER_CNT_ADRESS-=10;
X	     else if(but==119)POWER_CNT_ADRESS-=10;
N	     gran(&POWER_CNT_ADRESS,0,10000);
N	     lc640_write_int(EE_POWER_CNT_ADRESS,POWER_CNT_ADRESS);
X	     lc640_write_int(0x10+500+94,POWER_CNT_ADRESS);
N	     speed=1;
N	     } 
N	else if(sub_ind==33)
X	else if(a_ind . s_i==33)
N	     {
N	     if(but==butR)UBM_AV++;
X	     if(but==239)UBM_AV++;
N	     else if(but==butR_)UBM_AV++;
X	     else if(but==111)UBM_AV++;
N	     else if(but==butL)UBM_AV--;
X	     else if(but==247)UBM_AV--;
N	     else if(but==butL_)UBM_AV--;
X	     else if(but==119)UBM_AV--;
N	     gran(&UBM_AV,0,50);
N	     lc640_write_int(EE_UBM_AV,UBM_AV);
X	     lc640_write_int(0x10+500+96,UBM_AV);
N	     speed=1;
N	     }
N
N	else if(sub_ind==34)
X	else if(a_ind . s_i==34)
N	     {
N	     if(but==butR)AUSW_MAIN_NUMBER++;
X	     if(but==239)AUSW_MAIN_NUMBER++;
N	     else if(but==butR_)AUSW_MAIN_NUMBER+=20;
X	     else if(but==111)AUSW_MAIN_NUMBER+=20;
N	     else if(but==butL)AUSW_MAIN_NUMBER--;
X	     else if(but==247)AUSW_MAIN_NUMBER--;
N	     else if(but==butL_)AUSW_MAIN_NUMBER-=20;
X	     else if(but==119)AUSW_MAIN_NUMBER-=20;
N		else if(but==butEL_)AUSW_MAIN_NUMBER=15000;
X		else if(but==118)AUSW_MAIN_NUMBER=15000;
N		if(AUSW_MAIN_NUMBER<13000)AUSW_MAIN_NUMBER=100000;
N		if(AUSW_MAIN_NUMBER>100000)AUSW_MAIN_NUMBER=13000;
N	     lc640_write_int(EE_AUSW_MAIN_NUMBER,(short)(AUSW_MAIN_NUMBER&0x0000ffffUL));
X	     lc640_write_int(0x10+100+226,(short)(AUSW_MAIN_NUMBER&0x0000ffffUL));
N		lc640_write_int(EE_AUSW_MAIN_NUMBER+2,(short)((AUSW_MAIN_NUMBER&0xffff0000UL)>>16UL));
X		lc640_write_int(0x10+100+226+2,(short)((AUSW_MAIN_NUMBER&0xffff0000UL)>>16UL));
N	     speed=1;
N	     }                    		
N 
N     else if((sub_ind==36) || (sub_ind==4))
X     else if((a_ind . s_i==36) || (a_ind . s_i==4))
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_down(0,0);
N		     ret(0);
N		     }
N		}
N				
N	else if(sub_ind==37)
X	else if(a_ind . s_i==37)
N		{
N		if(but==butE)
X		if(but==254)
N		     {		
N			tree_up(iK_prl,0,0,0);
N			parol_init();
N			ret(50);
N			}						
N		}
N		/*			
N	else if(sub_ind==37)
N		{
N		if(but==butE)
N		     {
N		     tree_up(iPrltst,0,0,0);
N		     parol_init();
N		     }
N		}*/	
N     }
N
N
N
N
Nelse if(ind==iSet_VD)
Xelse if(a_ind . i==iSet_VD)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==5)index_set=6;
X		if(a_ind . s_i==5)a_ind . i_s=6;
N		if(sub_ind==6)sub_ind=7;
X		if(a_ind . s_i==6)a_ind . s_i=7;
N		if(sub_ind==20)
X		if(a_ind . s_i==20)
N        	{
N			index_set=18;
X			a_ind . i_s=18;
N			}
N		if(sub_ind==21)
X		if(a_ind . s_i==21)
N        	{
N			sub_ind=22;
X			a_ind . s_i=22;
N            index_set=19;
X            a_ind . i_s=19;
N            }
N		if(sub_ind==25)
X		if(a_ind . s_i==25)
N        	{
N			//sub_ind=27;
N            index_set=24;
X            a_ind . i_s=24;
N            }
N		if(sub_ind==26)
X		if(a_ind . s_i==26)
N        	{
N			sub_ind=27;
X			a_ind . s_i=27;
N            //index_set=19;
N            }
N		if(sub_ind==28)
X		if(a_ind . s_i==28)
N        	{
N			sub_ind=29;
X			a_ind . s_i=29;
N            //index_set=19;
N            }																			
N		gran_char(&sub_ind,0,30);
X		gran_char(&a_ind . s_i,0,30);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==6)
X		if(a_ind . s_i==6)
N			{
N			sub_ind=5;
X			a_ind . s_i=5;
N			}
N		if(sub_ind==21)
X		if(a_ind . s_i==21)
N			{
N			sub_ind=20;
X			a_ind . s_i=20;
N			}
N		if(sub_ind==26)
X		if(a_ind . s_i==26)
N        	{
N			sub_ind=25;
X			a_ind . s_i=25;
N            //index_set=19;
N            }
N		if(sub_ind==28)
X		if(a_ind . s_i==28)
N        	{
N			sub_ind=27;
X			a_ind . s_i=27;
N            //index_set=19;
N            }
N		gran_char(&sub_ind,0,30);
X		gran_char(&a_ind . s_i,0,30);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=29;
X		a_ind . s_i=29;
N		}
N
N	else if(but==butLR_)
X	else if(but==103)
N		{
N		lc640_write_int(EE_SPEED_CHRG_CURR,20);
X		lc640_write_int(0x10+100+162,20);
N		lc640_write_int(EE_SPEED_CHRG_VOLT,2400);
X		lc640_write_int(0x10+100+164,2400);
N		lc640_write_int(EE_SPEED_CHRG_TIME,1);
X		lc640_write_int(0x10+100+166,1);
N		lc640_write_int(EE_SPEED_CHRG_D_U,50);
X		lc640_write_int(0x10+100+170,50);
N		lc640_write_int(EE_SPEED_CHRG_AVT_EN,0);
X		lc640_write_int(0x10+100+168,0);
N		lc640_write_int(EE_SPEED_CHRG_BLOCK_SRC,1);
X		lc640_write_int(0x10+100+172,1);
N		lc640_write_int(EE_SPEED_CHRG_BLOCK_LOG,1);
X		lc640_write_int(0x10+100+174,1);
N		lc640_write_int(EE_AUSW_MAIN_NUMBER,20000);
X		lc640_write_int(0x10+100+226,20000);
N		}
N		
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	        {
N	          //tree_up(iDef_220_IPS_TERMOKOMPENSAT,0,0,0);
N	          //ret(1000);
N	          //default_temp=10;
N
N			lc640_write_int(EE_ZV_ON,1);
X			lc640_write_int(0x10+100+18,1);
N			lc640_write_int(EE_AV_OFF_AVT,1);
X			lc640_write_int(0x10+100+12,1);
N			lc640_write_int(EE_APV_ON1,apvON);
X			lc640_write_int(0x10+100+44,apvON);
N			lc640_write_int(EE_APV_ON2,apvON);
X			lc640_write_int(0x10+100+46,apvON);
N			lc640_write_int(EE_APV_ON2_TIME,1);
X			lc640_write_int(0x10+100+48,1);
N			lc640_write_int(EE_UOUT,2300);
X			lc640_write_int(0x10+100+6,2300);
N			lc640_write_int(EE_UAVT,2300);
X			lc640_write_int(0x10+100+8,2300);
N			lc640_write_int(EE_TSIGN,70);
X			lc640_write_int(0x10+100+82,70);
N			lc640_write_int(EE_TMAX,80);
X			lc640_write_int(0x10+100+10,80);
N			lc640_write_int(EE_TSYSMAX,50);
X			lc640_write_int(0x10+100+106,50);
N			lc640_write_int(EE_DU,200);
X			lc640_write_int(0x10+100+84,200);
N			lc640_write_int(EE_UMAX,700);
X			lc640_write_int(0x10+100+4,700);
N			lc640_write_int(EE_UINMAX,2500);
X			lc640_write_int(0x10+100+144,2500);
N			lc640_write_int(EE_UINMIN,1700);
X			lc640_write_int(0x10+100+146,1700);
N			lc640_write_int(EE_UOUTMAX,2500);
X			lc640_write_int(0x10+100+148,2500);
N			lc640_write_int(EE_UOUTMIN,2200);
X			lc640_write_int(0x10+100+150,2200);
N			lc640_write_int(EE_TZAS,5);
X			lc640_write_int(0x10+100+34,5);
N			lc640_write_int(EE_TVENTMAX,6000);
X			lc640_write_int(0x10+350+2,6000);
N			lc640_write_int(ADR_EE_RELE_SET_MASK[0],0x01);
N			lc640_write_int(ADR_EE_RELE_SET_MASK[1],0x78);
N			lc640_write_int(ADR_EE_RELE_SET_MASK[2],0x02);
N			lc640_write_int(ADR_EE_RELE_SET_MASK[3],0x84);
N
N	        }
N		}	
N	
N     else if(sub_ind==1)
X     else if(a_ind . s_i==1)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_up(iSet_T,0,0,0);
N		     ret(1000);
N		     phase=0;
N		     }
N		}	
N					 
N     else if(sub_ind==2)
X     else if(a_ind . s_i==2)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_up(iStr_VD,0,0,0);
N		     ret(1000);
N		     index_set=0;
X		     a_ind . i_s=0;
N 		     }
N		}	
N	
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N	     {
N		if(ZV_ON)ZV_ON=0;
N		else ZV_ON=1;
N	     lc640_write_int(EE_ZV_ON,ZV_ON);
X	     lc640_write_int(0x10+100+18,ZV_ON);
N	     speed=1;
N	     }	
N	
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N	     {
N		if(AV_OFF_AVT)AV_OFF_AVT=0;
N		else AV_OFF_AVT=1;
N	     lc640_write_int(EE_AV_OFF_AVT,AV_OFF_AVT);
X	     lc640_write_int(0x10+100+12,AV_OFF_AVT);
N	     speed=1;
N	     }	
N
N	else if(sub_ind==7)
X	else if(a_ind . s_i==7)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N	          tree_up(iApv,0,0,0);
N	          ret(1000);
N	          }
N	     }	
N 
N	else if(sub_ind==8)
X	else if(a_ind . s_i==8)
N	     {
N	     if(but==butR)UOUT++;
X	     if(but==239)UOUT++;
N	     else if(but==butR_)UOUT+=10;
X	     else if(but==111)UOUT+=10;
N	     else if(but==butL)UOUT--;
X	     else if(but==247)UOUT--;
N	     else if(but==butL_)UOUT-=10;
X	     else if(but==119)UOUT-=10;
N
N	     gran(&UOUT,2250,2350);
N
N	     lc640_write_int(EE_UOUT,UOUT);
X	     lc640_write_int(0x10+100+6,UOUT);
N	     speed=1;
N	     }
N	else if(sub_ind==9)
X	else if(a_ind . s_i==9)
N	     {
N	     if(but==butR)UAVT++;
X	     if(but==239)UAVT++;
N	     else if(but==butR_)UAVT+=10;
X	     else if(but==111)UAVT+=10;
N	     else if(but==butL)UAVT--;
X	     else if(but==247)UAVT--;
N	     else if(but==butL_)UAVT-=10;
X	     else if(but==119)UAVT-=10;
N
N	     gran(&UAVT,2250,2350);
N
N	     lc640_write_int(EE_UAVT,UAVT);
X	     lc640_write_int(0x10+100+8,UAVT);
N	     speed=1;
N	     }
N		 	     
N	else if(sub_ind==10)
X	else if(a_ind . s_i==10)
N	     {
N	     if(but==butR)TSIGN++;
X	     if(but==239)TSIGN++;
N	     else if(but==butR_)TSIGN+=2;
X	     else if(but==111)TSIGN+=2;
N	     else if(but==butL)TSIGN--;
X	     else if(but==247)TSIGN--;
N	     else if(but==butL_)TSIGN-=2;
X	     else if(but==119)TSIGN-=2;
N	     gran(&TSIGN,10,100);
N	     lc640_write_int(EE_TSIGN,TSIGN);
X	     lc640_write_int(0x10+100+82,TSIGN);
N	     speed=1;
N	     }
N
N 	else if(sub_ind==11)
X 	else if(a_ind . s_i==11)
N	     {
N	     if(but==butR)TMAX++;
X	     if(but==239)TMAX++;
N	     else if(but==butR_)TMAX+=2;
X	     else if(but==111)TMAX+=2;
N	     else if(but==butL)TMAX--;
X	     else if(but==247)TMAX--;
N	     else if(but==butL_)TMAX-=2;
X	     else if(but==119)TMAX-=2;
N	     gran(&TMAX,10,100);
N	     lc640_write_int(EE_TMAX,TMAX);
X	     lc640_write_int(0x10+100+10,TMAX);
N	     speed=1;
N	     }
N
N 	else if(sub_ind==12)
X 	else if(a_ind . s_i==12)
N	     {
N	     if(but==butR)TSYSMAX++;
X	     if(but==239)TSYSMAX++;
N	     else if(but==butR_)TSYSMAX+=2;
X	     else if(but==111)TSYSMAX+=2;
N	     else if(but==butL)TSYSMAX--;
X	     else if(but==247)TSYSMAX--;
N	     else if(but==butL_)TSYSMAX-=2;
X	     else if(but==119)TSYSMAX-=2;
N	     gran(&TSYSMAX,10,100);
N	     lc640_write_int(EE_TSYSMAX,TSYSMAX);
X	     lc640_write_int(0x10+100+106,TSYSMAX);
N	     speed=1;
N	     }		 	
N	else if(sub_ind==13)
X	else if(a_ind . s_i==13)
N	    {
N		if(but==butR)DU++;
X		if(but==239)DU++;
N	    else if(but==butR_)DU+=10;
X	    else if(but==111)DU+=10;
N	    else if(but==butL)DU--;
X	    else if(but==247)DU--;
N	    else if(but==butL_)DU-=10;
X	    else if(but==119)DU-=10;
N	    gran(&DU,50,1000);
N	    lc640_write_int(EE_DU,DU);
X	    lc640_write_int(0x10+100+84,DU);
N	    speed=1;
N	    }
N		 	
N	else if(sub_ind==14)
X	else if(a_ind . s_i==14)
N		{
N	    if(but==butR)UMAX++;
X	    if(but==239)UMAX++;
N	    else if(but==butR_)UMAX+=10;
X	    else if(but==111)UMAX+=10;
N	    else if(but==butL)UMAX--;
X	    else if(but==247)UMAX--;
N	    else if(but==butL_)UMAX-=10;
X	    else if(but==119)UMAX-=10;
N		gran(&UMAX,10,3000);
N		lc640_write_int(EE_UMAX,UMAX);
X		lc640_write_int(0x10+100+4,UMAX);
N	    speed=1;
N	    }
N
N	else if(sub_ind==15)
X	else if(a_ind . s_i==15)
N		{
N	    if(but==butR)UINMAX=(UINMAX*10+100)/10;
X	    if(but==239)UINMAX=(UINMAX*10+100)/10;
N	    else if(but==butR_)UINMAX=(UINMAX*10+1000)/10;
X	    else if(but==111)UINMAX=(UINMAX*10+1000)/10;
N	    else if(but==butL)UINMAX=(UINMAX*10-100)/10;
X	    else if(but==247)UINMAX=(UINMAX*10-100)/10;
N	    else if(but==butL_)UINMAX=(UINMAX*10-1000)/10;
X	    else if(but==119)UINMAX=(UINMAX*10-1000)/10;
N		gran(&UINMAX,10,3000);
N		lc640_write_int(EE_UINMAX,UINMAX);
X		lc640_write_int(0x10+100+144,UINMAX);
N	    speed=1;
N	    }
N
N	else if(sub_ind==16)
X	else if(a_ind . s_i==16)
N		{
N	    if(but==butR)UINMIN=(UINMIN*10+100)/10;
X	    if(but==239)UINMIN=(UINMIN*10+100)/10;
N	    else if(but==butR_)UINMIN=(UINMIN*10+1000)/10;
X	    else if(but==111)UINMIN=(UINMIN*10+1000)/10;
N	    else if(but==butL)UINMIN=(UINMIN*10-100)/10;
X	    else if(but==247)UINMIN=(UINMIN*10-100)/10;
N	    else if(but==butL_)UINMIN=(UINMIN*10-1000)/10;
X	    else if(but==119)UINMIN=(UINMIN*10-1000)/10;
N		gran(&UINMIN,10,3000);
N		lc640_write_int(EE_UINMIN,UINMIN);
X		lc640_write_int(0x10+100+146,UINMIN);
N	    speed=1;
N	    }
N
N	else if(sub_ind==17)
X	else if(a_ind . s_i==17)
N		{
N	    if(but==butR)UOUTMAX=(UOUTMAX*10+100)/10;
X	    if(but==239)UOUTMAX=(UOUTMAX*10+100)/10;
N	    else if(but==butR_)UOUTMAX=(UOUTMAX*10+1000)/10;
X	    else if(but==111)UOUTMAX=(UOUTMAX*10+1000)/10;
N	    else if(but==butL)UOUTMAX=(UOUTMAX*10-100)/10;
X	    else if(but==247)UOUTMAX=(UOUTMAX*10-100)/10;
N	    else if(but==butL_)UOUTMAX=(UOUTMAX*10-1000)/10;
X	    else if(but==119)UOUTMAX=(UOUTMAX*10-1000)/10;
N		gran(&UOUTMAX,10,3000);
N		lc640_write_int(EE_UOUTMAX,UOUTMAX);
X		lc640_write_int(0x10+100+148,UOUTMAX);
N	    speed=1;
N	    }
N
N	else if(sub_ind==18)
X	else if(a_ind . s_i==18)
N		{
N	    if(but==butR)UOUTMIN=(UOUTMIN*10+100)/10;
X	    if(but==239)UOUTMIN=(UOUTMIN*10+100)/10;
N	    else if(but==butR_)UOUTMIN=(UOUTMIN*10+1000)/10;
X	    else if(but==111)UOUTMIN=(UOUTMIN*10+1000)/10;
N	    else if(but==butL)UOUTMIN=(UOUTMIN*10-100)/10;
X	    else if(but==247)UOUTMIN=(UOUTMIN*10-100)/10;
N	    else if(but==butL_)UOUTMIN=(UOUTMIN*10-1000)/10;
X	    else if(but==119)UOUTMIN=(UOUTMIN*10-1000)/10;
N		gran(&UOUTMIN,10,3000);
N		lc640_write_int(EE_UOUTMIN,UOUTMIN);
X		lc640_write_int(0x10+100+150,UOUTMIN);
N	    speed=1;
N	    }
N
N	else if(sub_ind==19)
X	else if(a_ind . s_i==19)
N		{
N		if ((but==butR)||(but==butR_))TZAS++;
X		if ((but==239)||(but==111))TZAS++;
N		if ((but==butL)||(but==butL_))TZAS--;
X		if ((but==247)||(but==119))TZAS--;
N		gran(&TZAS,3,60);
N		lc640_write_int(EE_TZAS,TZAS);
X		lc640_write_int(0x10+100+34,TZAS);
N		speed=1; 
N		}
N
N	else if(sub_ind==20)
X	else if(a_ind . s_i==20)
N		{
N	    if(but==butR)		TVENTMAX=((TVENTMAX/100)+1)*100;
X	    if(but==239)		TVENTMAX=((TVENTMAX/100)+1)*100;
N	    else if(but==butR_)	TVENTMAX=((TVENTMAX/100)+1)*100;
X	    else if(but==111)	TVENTMAX=((TVENTMAX/100)+1)*100;
N	    else if(but==butL)	TVENTMAX=((TVENTMAX/100)-1)*100;
X	    else if(but==247)	TVENTMAX=((TVENTMAX/100)-1)*100;
N	    else if(but==butL_)	TVENTMAX=((TVENTMAX/100)-1)*100;
X	    else if(but==119)	TVENTMAX=((TVENTMAX/100)-1)*100;
N		else if(but==butE_)	TVENTMAX=1500;
X		else if(but==126)	TVENTMAX=1500;
N		gran(&TVENTMAX,1,6000);
N		lc640_write_int(EE_TVENTMAX,TVENTMAX);
X		lc640_write_int(0x10+350+2,TVENTMAX);
N	    speed=1;
N	    }
N
N	else if(sub_ind==22)
X	else if(a_ind . s_i==22)
N		{
N		if(but==butE)
X		if(but==254)
N		    {		
N			tree_up(iRele_set,0,0,0);
N			ret(500);
N			}						
N		}
N  	else if(sub_ind==23)
X  	else if(a_ind . s_i==23)
N		{
N		if(but==butE) 
X		if(but==254) 
N		     {
N		     tree_up(iLan_set,0,0,0);
N		     ret(1000);
N		     }
N		}
N  	else if(sub_ind==24)
X  	else if(a_ind . s_i==24)
N	    {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	MODBUS_ADRESS++;
N	     	gran(&MODBUS_ADRESS,1,100);
N	     	lc640_write_int(EE_MODBUS_ADRESS,MODBUS_ADRESS);
X	     	lc640_write_int(0x10+500+200+72,MODBUS_ADRESS);
N			speed=1;
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	MODBUS_ADRESS--;
N	     	gran(&MODBUS_ADRESS,1,100);
N	     	lc640_write_int(EE_MODBUS_ADRESS,MODBUS_ADRESS);
X	     	lc640_write_int(0x10+500+200+72,MODBUS_ADRESS);
N			speed=1;
N	     	}
N          }
N
N     else if(sub_ind==25)
X     else if(a_ind . s_i==25)
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N			if(MODBUS_BAUDRATE==120)MODBUS_BAUDRATE=240;
N			else if(MODBUS_BAUDRATE==240)MODBUS_BAUDRATE=480;
N	     	else if(MODBUS_BAUDRATE==480)MODBUS_BAUDRATE=960;
N			else if(MODBUS_BAUDRATE==960)MODBUS_BAUDRATE=1920;
N			else if(MODBUS_BAUDRATE==1920)MODBUS_BAUDRATE=3840;
N			else if(MODBUS_BAUDRATE==3840)MODBUS_BAUDRATE=5760;
N			//else if(MODBUS_BAUDRATE==3840)MODBUS_BAUDRATE=5760;
N			else if(MODBUS_BAUDRATE==5760)MODBUS_BAUDRATE=11520;
N			else MODBUS_BAUDRATE=120;
N	     	gran(&MODBUS_BAUDRATE,120,11520);
N	     	lc640_write_int(EE_MODBUS_BAUDRATE,MODBUS_BAUDRATE);
X	     	lc640_write_int(0x10+500+200+74,MODBUS_BAUDRATE);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N			if(MODBUS_BAUDRATE==120)MODBUS_BAUDRATE=11520;
N			else if(MODBUS_BAUDRATE==240)MODBUS_BAUDRATE=120;
N	     	else if(MODBUS_BAUDRATE==480)MODBUS_BAUDRATE=240;
N			else if(MODBUS_BAUDRATE==960)MODBUS_BAUDRATE=480;
N			else if(MODBUS_BAUDRATE==1920)MODBUS_BAUDRATE=960;
N			else if(MODBUS_BAUDRATE==3840)MODBUS_BAUDRATE=1920;
N			//else if(MODBUS_BAUDRATE==3840)MODBUS_BAUDRATE=3840;
N			else if(MODBUS_BAUDRATE==5760)MODBUS_BAUDRATE=3840;
N			else MODBUS_BAUDRATE=11520;
N	     	gran(&MODBUS_BAUDRATE,120,11520);
N	     	lc640_write_int(EE_MODBUS_BAUDRATE,MODBUS_BAUDRATE);
X	     	lc640_write_int(0x10+500+200+74,MODBUS_BAUDRATE);
N	     	}
N          }
N
N     else if(sub_ind==27)
X     else if(a_ind . s_i==27)
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	I_LOAD_MODE=1;
N	     	lc640_write_int(EE_I_LOAD_MODE,I_LOAD_MODE);
X	     	lc640_write_int(0x10+100+78,I_LOAD_MODE);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	I_LOAD_MODE=0;
N	     	lc640_write_int(EE_I_LOAD_MODE,I_LOAD_MODE);
X	     	lc640_write_int(0x10+100+78,I_LOAD_MODE);
N	     	}
N          }
N
N    else if((sub_ind==29) || (sub_ind==3))
X    else if((a_ind . s_i==29) || (a_ind . s_i==3))
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     tree_down(0,0);
N		     ret(0);
N		     }
N		}
N				
N	else if(sub_ind==30)
X	else if(a_ind . s_i==30)
N		{
N		if(but==butE)
X		if(but==254)
N		     {		
N			tree_up(iK_prl,0,0,0);
N			parol_init();
N			ret(50);
N			}						
N		}
N     }
N
N
Nelse if (ind==iDef_220_IPS_TERMOKOMPENSAT)
Xelse if (a_ind . i==iDef_220_IPS_TERMOKOMPENSAT)
N	{
N	simax=4;
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=simax;
X		a_ind . s_i=simax;
N		}
N	
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			def_ips_set(220);
N			//lc640_write_int(EE_DU,2315-1850);
N			lc640_write_int(EE_U_AVT,2200);
X			lc640_write_int(0x10+100+80,2200);
N			lc640_write_int(EE_IZMAX,50);
X			lc640_write_int(0x10+100+30,50);
N			//lc640_write_int(EE_IMAX,12);
N			//lc640_write_int(EE_IMIN,8);
N			lc640_write_int(EE_AUSW_MAIN,22043);
X			lc640_write_int(0x10+100+224,22043);
N			lc640_write_int(EE_NUMIST,3);
X			lc640_write_int(0x10+100+36,3);
N
N			lc640_write_int(EE_PAR,0);
X			lc640_write_int(0x10+100+86,0);
N			//lc640_write_int(EE_UMAX,2550);
N			lc640_write_int(EE_DU,2315-1110);
X			lc640_write_int(0x10+100+84,2315-1110);
N//			lc640_write_int(EE_UB0,2397);
N//			lc640_write_int(EE_UB20,2314);
N			//lc640_write_int(EE_IZMAX,20);
N			//lc640_write_int(EE_UVZ,2346);
N			lc640_write_int(EE_UBM_AV,0);
X			lc640_write_int(0x10+500+96,0);
N			lc640_write_int(EE_U_OUT_KONTR_MAX,2420);
X			lc640_write_int(0x10+100+182,2420);
N			lc640_write_int(EE_U_OUT_KONTR_MIN,2200);
X			lc640_write_int(0x10+100+184,2200);
N
N			}
N		else if(sub_ind==1)
X		else if(a_ind . s_i==1)
N			{
N			def_ips_set(220);
N			lc640_write_int(EE_DU,2315-1850);
X			lc640_write_int(0x10+100+84,2315-1850);
N			lc640_write_int(EE_U_AVT,2200);
X			lc640_write_int(0x10+100+80,2200);
N			//lc640_write_int(EE_IZMAX,50);
N			lc640_write_int(EE_AUSW_MAIN,22011);
X			lc640_write_int(0x10+100+224,22011);
N			lc640_write_int(EE_NUMIST,2);
X			lc640_write_int(0x10+100+36,2);
N			lc640_write_int(EE_TERMOKOMP,1);
X			lc640_write_int(0x10+100+126,1);
N			//lc640_write_int(EE_IMAX,30);
N		     //lc640_write_int(EE_IMIN,24);
N			//lc640_write_int(EE_UMAX,2450);
N	/*		}
N		else if(sub_ind==3)
N			{ */
N		//	def_ips_set(220);
N			//lc640_write_int(EE_DU,2315-1850);
N		//	lc640_write_int(EE_U_AVT,2200);
N			//lc640_write_int(EE_IZMAX,10);
N			//lc640_write_int(EE_IMAX,30);
N		//	lc640_write_int(EE_IMIN,24);
N			//lc640_write_int(EE_AUSW_MAIN,22023);
N			lc640_write_int(EE_NUMIST,2);
X			lc640_write_int(0x10+100+36,2);
N
N			lc640_write_int(EE_PAR,0);
X			lc640_write_int(0x10+100+86,0);
N			lc640_write_int(EE_UMAX,2550);
X			lc640_write_int(0x10+100+4,2550);
N			lc640_write_int(EE_DU,2315-1110);
X			lc640_write_int(0x10+100+84,2315-1110);
N			//lc640_write_int(EE_UB0,2397);
N			//lc640_write_int(EE_UB20,2314);
N			lc640_write_int(EE_IZMAX,50);
X			lc640_write_int(0x10+100+30,50);
N			//lc640_write_int(EE_UVZ,2440);
N			lc640_write_int(EE_UBM_AV,0);
X			lc640_write_int(0x10+500+96,0);
N			lc640_write_int(EE_UMAX,2450);
X			lc640_write_int(0x10+100+4,2450);
N			lc640_write_int(EE_U_OUT_KONTR_MAX,2420);
X			lc640_write_int(0x10+100+182,2420);
N			lc640_write_int(EE_U_OUT_KONTR_MIN,2200);
X			lc640_write_int(0x10+100+184,2200);
N
N			}
N		else if(sub_ind==2)
X		else if(a_ind . s_i==2)
N			{
N			def_ips_set(110);
N			//lc640_write_int(EE_DU,2315-1850);
N			//lc640_write_int(EE_U_AVT,2200);
N			//lc640_write_int(EE_IZMAX,50);
N			//lc640_write_int(EE_IMAX,12);
N			//lc640_write_int(EE_IMIN,8);
N			lc640_write_int(EE_AUSW_MAIN,22043);
X			lc640_write_int(0x10+100+224,22043);
N			//lc640_write_int(EE_NUMIST,3);
N
N			//lc640_write_int(EE_PAR,0);
N			//lc640_write_int(EE_UMAX,2550);
N			//lc640_write_int(EE_DU,2315-1110);
N			//lc640_write_int(EE_UB0,2397);
N			//lc640_write_int(EE_UB20,2314);
N			//lc640_write_int(EE_IZMAX,20);
N			//lc640_write_int(EE_UVZ,2346);
N			//lc640_write_int(EE_UBM_AV,0);
N			//lc640_write_int(EE_U_OUT_KONTR_MAX,2420);
N			//lc640_write_int(EE_U_OUT_KONTR_MIN,2200);
N
N			}
N		else if(sub_ind==3)
X		else if(a_ind . s_i==3)
N			{
N			def_ips_set(220);
N			//lc640_write_int(EE_DU,2315-1850);
N			lc640_write_int(EE_U_AVT,2200);
X			lc640_write_int(0x10+100+80,2200);
N			//lc640_write_int(EE_IZMAX,50);
N			lc640_write_int(EE_AUSW_MAIN,22018);
X			lc640_write_int(0x10+100+224,22018);
N			lc640_write_int(EE_NUMIST,2);
X			lc640_write_int(0x10+100+36,2);
N			lc640_write_int(EE_TERMOKOMP,1);
X			lc640_write_int(0x10+100+126,1);
N			//lc640_write_int(EE_IMAX,30);
N		     //lc640_write_int(EE_IMIN,24);
N			//lc640_write_int(EE_UMAX,2450);
N	/*		}
N		else if(sub_ind==3)
N			{ */
N		//	def_ips_set(220);
N			//lc640_write_int(EE_DU,2315-1850);
N		//	lc640_write_int(EE_U_AVT,2200);
N			//lc640_write_int(EE_IZMAX,10);
N			//lc640_write_int(EE_IMAX,30);
N		//	lc640_write_int(EE_IMIN,24);
N			//lc640_write_int(EE_AUSW_MAIN,22023);
N			lc640_write_int(EE_NUMIST,2);
X			lc640_write_int(0x10+100+36,2);
N
N			lc640_write_int(EE_PAR,0);
X			lc640_write_int(0x10+100+86,0);
N			lc640_write_int(EE_UMAX,2700);
X			lc640_write_int(0x10+100+4,2700);
N			lc640_write_int(EE_DU,2450-1200);
X			lc640_write_int(0x10+100+84,2450-1200);
N//			lc640_write_int(EE_UB0,2590);
N//			lc640_write_int(EE_UB20,2450);
N			lc640_write_int(EE_IZMAX,50);
X			lc640_write_int(0x10+100+30,50);
N			//lc640_write_int(EE_UVZ,2590);
N			lc640_write_int(EE_UBM_AV,0);
X			lc640_write_int(0x10+500+96,0);
N			//lc640_write_int(EE_UMAX,2450);
N			lc640_write_int(EE_U_OUT_KONTR_MAX,2420);
X			lc640_write_int(0x10+100+182,2420);
N			lc640_write_int(EE_U_OUT_KONTR_MIN,2200);
X			lc640_write_int(0x10+100+184,2200);
N
N			}
N		else if(sub_ind==simax)
X		else if(a_ind . s_i==simax)
N			{
N			tree_down(0,0);
N			}
N		default_temp=sub_ind;	
X		default_temp=a_ind . s_i;	
N		}
N     }
N
Nelse if(ind==iSet_T)
Xelse if(a_ind . i==iSet_T)
N	{
N	signed char temp;
N	if(but==butR)
X	if(but==239)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,5);
X		gran_char(&a_ind . s_i,0,5);
N		}
N	else if(but==butL)
X	else if(but==247)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,5);
X		gran_char(&a_ind . s_i,0,5);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		tree_down(0,0);
N		}	
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {			    
N	     temp=LPC_RTC->HOUR;
X	     temp=((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->HOUR;
N	     if((but==butU)||(but==butU_))
X	     if((but==253)||(but==125))
N	          {
N	          temp++;
N	          gran_ring_char(&temp,0,23);
N	          LPC_RTC->HOUR=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->HOUR=temp;
N	          }
N          else if((but==butD)||(but==butD_))
X          else if((but==251)||(but==123))
N	          {
N	          temp--;
N	          gran_ring_char(&temp,0,23);
N	          LPC_RTC->HOUR=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->HOUR=temp;
N	          }	
N	     speed=1;               
N	     }
N     else if(sub_ind==1)
X     else if(a_ind . s_i==1)
N	     {
N	     temp=LPC_RTC->MIN;
X	     temp=((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MIN;
N	     if((but==butU)||(but==butU_))
X	     if((but==253)||(but==125))
N	          {
N	          temp++;
N	          gran_ring_char(&temp,0,59);
N	          LPC_RTC->MIN=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MIN=temp;
N	          }
N          else if((but==butD)||(but==butD_))
X          else if((but==251)||(but==123))
N	          {
N	          temp--;
N	          gran_ring_char(&temp,0,59);
N	          LPC_RTC->MIN=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MIN=temp;
N	          }	
N	     speed=1;               
N	     }
N     else if(sub_ind==2)
X     else if(a_ind . s_i==2)
N	     {				  
N	     temp=LPC_RTC->SEC;
X	     temp=((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->SEC;
N	     if((but==butU)||(but==butU_))
X	     if((but==253)||(but==125))
N	          {
N	          temp=0;
N	          gran_ring_char(&temp,0,59);
N	          LPC_RTC->SEC=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->SEC=temp;
N	          }
N          else if((but==butD)||(but==butD_))
X          else if((but==251)||(but==123))
N	          {
N	          temp=0;
N	          gran_ring_char(&temp,0,59);
N	          LPC_RTC->SEC=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->SEC=temp;
N	          }	
N	     speed=1;               
N	     }
N
N     else if(sub_ind==3)
X     else if(a_ind . s_i==3)
N	     {
N	     temp=LPC_RTC->DOM;
X	     temp=((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM;
N	     if((but==butU)||(but==butU_))
X	     if((but==253)||(but==125))
N	          {
N	          temp++;
N	          gran_ring_char(&temp,1,31);
N	          LPC_RTC->DOM=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM=temp;
N	          }
N          else if((but==butD)||(but==butD_))
X          else if((but==251)||(but==123))
N	          {
N	          temp--;
N	          gran_ring_char(&temp,1,31);
N	          LPC_RTC->DOM=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->DOM=temp;
N	          }	
N	     speed=1;               
N	     }
N     else if(sub_ind==4)
X     else if(a_ind . s_i==4)
N	     {
N	     temp=LPC_RTC->MONTH;
X	     temp=((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH;
N	     if((but==butU)||(but==butU_))
X	     if((but==253)||(but==125))
N	          {
N	          temp++;
N	          gran_ring_char(&temp,1,12);
N	          LPC_RTC->MONTH=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH=temp;
N	          }
N          else if((but==butD)||(but==butD_))
X          else if((but==251)||(but==123))
N	          {
N	          temp--;
N	          gran_ring_char(&temp,1,12);
N	          LPC_RTC->MONTH=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->MONTH=temp;
N	          }	
N	     speed=1;               
N	     }	  
N     else if(sub_ind==5)
X     else if(a_ind . s_i==5)
N	     {
N	     temp=LPC_RTC->YEAR;
X	     temp=((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR;
N	     if((but==butU)||(but==butU_))
X	     if((but==253)||(but==125))
N	          {
N	          temp++;
N	          gran_ring_char(&temp,0,99);
N	          LPC_RTC->YEAR=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR=temp;
N	          }
N          else if((but==butD)||(but==butD_))
X          else if((but==251)||(but==123))
N	          {
N	          temp--;
N	          gran_ring_char(&temp,0,99);
N	          LPC_RTC->YEAR=temp;
X	          ((LPC_RTC_TypeDef *) ((0x40000000UL) + 0x24000) )->YEAR=temp;
N	          }	
N	     speed=1;               
N	     }		        
N	}  
N
Nelse if(ind==iStr)
Xelse if(a_ind . i==iStr)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)index_set=1;
X		if(a_ind . s_i==2)a_ind . i_s=1;
N		if(sub_ind==3)sub_ind++;
X		if(a_ind . s_i==3)a_ind . s_i++;
N		gran_char(&sub_ind,1,5);	
X		gran_char(&a_ind . s_i,1,5);	
N
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==3)sub_ind--;
X		if(a_ind . s_i==3)a_ind . s_i--;
N		gran_char(&sub_ind,1,5);	 
X		gran_char(&a_ind . s_i,1,5);	 
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N/**/		sub_ind=5;		 /**/
X 		a_ind . s_i=5;		  
N		}				
N     else if(sub_ind==1)
X     else if(a_ind . s_i==1)
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	NUMIST++;
N	     	gran(&NUMIST,0,12);
N	     	lc640_write_int(EE_NUMIST,NUMIST);
X	     	lc640_write_int(0x10+100+36,NUMIST);
N			numOfForvardBps_init();
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	NUMIST--;
N	     	gran(&NUMIST,0,12);
N	     	lc640_write_int(EE_NUMIST,NUMIST);
X	     	lc640_write_int(0x10+100+36,NUMIST);
N			numOfForvardBps_init();
N	     	}
N          }	
N/**/
N	  else if(sub_ind==2)
X	  else if(a_ind . s_i==2)
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	NUMINV++;
N	     	gran(&NUMINV,0,12-NUMIST);
N	     	lc640_write_int(EE_NUMINV,NUMINV);
X	     	lc640_write_int(0x10+100+38,NUMINV);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	NUMINV--;
N	     	gran(&NUMINV,0,12-NUMIST);
N	     	lc640_write_int(EE_NUMINV,NUMINV);
X	     	lc640_write_int(0x10+100+38,NUMINV);
N	     	}
N          }	
N/**/
N/**/     else if(sub_ind==3)  /**/
X      else if(a_ind . s_i==3)   
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	NUMAVT++;
N	     	gran(&NUMAVT,0,12);
N	     	lc640_write_int(EE_NUMAVT,NUMAVT);
X	     	lc640_write_int(0x10+500+98,NUMAVT);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	NUMAVT--;
N	     	gran(&NUMAVT,0,12);
N	     	lc640_write_int(EE_NUMAVT,NUMAVT);
X	     	lc640_write_int(0x10+500+98,NUMAVT);
N	     	}
N          }	
N          
N/**/    else if(sub_ind==5)	  /**/
X     else if(a_ind . s_i==5)	   
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N			tree_down(0,0);
N	          }
N          }	          
N	}
N
Nelse if(ind==iStr_VD)
Xelse if(a_ind . i==iStr_VD)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=4;
X		a_ind . s_i=4;
N		}				
N     else if(sub_ind==0)
X     else if(a_ind . s_i==0)
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	NUMIST++;
N	     	gran(&NUMIST,0,18);
N	     	lc640_write_int(EE_NUMIST,NUMIST);
X	     	lc640_write_int(0x10+100+36,NUMIST);
N			numOfForvardBps_init();
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	NUMIST--;
N	     	gran(&NUMIST,0,18);
N	     	lc640_write_int(EE_NUMIST,NUMIST);
X	     	lc640_write_int(0x10+100+36,NUMIST);
N			numOfForvardBps_init();
N	     	}
N          }	
N          
N     else if(sub_ind==1)
X     else if(a_ind . s_i==1)
N	     {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	     	{
N	     	NUMDT++;
N	     	gran(&NUMDT,0,3);
N	     	lc640_write_int(EE_NUMDT,NUMDT);
X	     	lc640_write_int(0x10+500+90,NUMDT);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
X	     else if((but==247)||(but==119))
N	     	{
N	     	NUMDT--;
N	     	gran(&NUMDT,0,3);
N	     	lc640_write_int(EE_NUMDT,NUMDT);
X	     	lc640_write_int(0x10+500+90,NUMDT);
N	     	}
N          }	
N
N /*    else if(sub_ind==2)
N	     {
N	     if((but==butR)||(but==butR_))
N	     	{
N	     	NUMMAKB++;
N			if(NUMMAKB==1)NUMMAKB++;
N			if(NUMMAKB==3)NUMMAKB++;
N	     	gran(&NUMMAKB,0,4);
N	     	lc640_write_int(EE_NUMMAKB,NUMMAKB);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
N	     	{
N	     	NUMMAKB--;
N			if(NUMMAKB==1)NUMMAKB--;
N			if(NUMMAKB==3)NUMMAKB--;
N	     	gran(&NUMMAKB,0,4);
N	     	lc640_write_int(EE_NUMMAKB,NUMMAKB);
N	     	}
N          }
N    else if(sub_ind==3)
N	     {
N	     if((but==butR)||(but==butR_))
N	     	{
N	     	NUMSK++;
N	     	gran(&NUMSK,0,4);
N	     	lc640_write_int(EE_NUMSK,NUMSK);
N	     	}
N	     
N	     else if((but==butL)||(but==butL_))
N	     	{
N	     	NUMSK--;
N	     	gran(&NUMSK,0,4);
N	     	lc640_write_int(EE_NUMSK,NUMSK);
N	     	}
N		}*/			  			                 
N    else if(sub_ind==2)
X    else if(a_ind . s_i==2)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N			tree_down(0,0);
N	          }
N          }
N	}
N 
Nelse if (ind==iLan_set)
Xelse if (a_ind . i==iLan_set)
N	{
N	char si_max;
N	ret(1000);
N
N	si_max=1;
N	if(ETH_IS_ON!=0)si_max=21;
N
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N
N		if((sub_ind==2)&&(index_set==0))
X		if((a_ind . s_i==2)&&(a_ind . i_s==0))
N			{
N			index_set=1;
X			a_ind . i_s=1;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==3) 
X		if(a_ind . s_i==3) 
N			{
N			sub_ind=4;
X			a_ind . s_i=4;
N			index_set=3;
X			a_ind . i_s=3;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==5) 
X		if(a_ind . s_i==5) 
N			{
N			sub_ind=6;
X			a_ind . s_i=6;
N			index_set=5;
X			a_ind . i_s=5;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==7) 
X		if(a_ind . s_i==7) 
N			{
N			sub_ind=8;
X			a_ind . s_i=8;
N			//index_set=3;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==10) 
X		if(a_ind . s_i==10) 
N			{
N			//sub_ind=6;
N			//index_set=9;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==11) 
X		if(a_ind . s_i==11) 
N			{
N			//sub_ind=6;
N			index_set=10;
X			a_ind . i_s=10;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==12) 
X		if(a_ind . s_i==12) 
N			{
N			sub_ind++;
X			a_ind . s_i++;
N			}
N		if(sub_ind==13) 
X		if(a_ind . s_i==13) 
N			{
N			//sub_ind=6;
N			index_set=12;
X			a_ind . i_s=12;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==14) 
X		if(a_ind . s_i==14) 
N			{
N			sub_ind++;
X			a_ind . s_i++;
N			}
N		if(sub_ind==15) 
X		if(a_ind . s_i==15) 
N			{
N			//sub_ind=6;
N			index_set=14;
X			a_ind . i_s=14;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==16) 
X		if(a_ind . s_i==16) 
N			{
N			sub_ind++;
X			a_ind . s_i++;
N			}
N		if(sub_ind==17) 
X		if(a_ind . s_i==17) 
N			{
N			//sub_ind=6;
N			index_set=16;
X			a_ind . i_s=16;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==18) 
X		if(a_ind . s_i==18) 
N			{
N			sub_ind++;
X			a_ind . s_i++;
N			}
N		if(sub_ind==19) 
X		if(a_ind . s_i==19) 
N			{
N			//sub_ind=6;
N			index_set=18;
X			a_ind . i_s=18;
N			sub_ind1=0;
X			a_ind . s_i1=0;
N			}
N		if(sub_ind==20) 
X		if(a_ind . s_i==20) 
N			{
N			sub_ind++;
X			a_ind . s_i++;
N			}
N	/*	if((sub_ind==4)&&(index_set==2))
N			{
N			index_set=3;
N			sub_ind1=0;
N			}*/
N		
N		gran_char(&sub_ind,0,si_max);
X		gran_char(&a_ind . s_i,0,si_max);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,si_max);
X		gran_char(&a_ind . s_i,0,si_max);
N		if(sub_ind==20) 
X		if(a_ind . s_i==20) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}		
N		if(sub_ind==18) 
X		if(a_ind . s_i==18) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}		
N		if(sub_ind==16) 
X		if(a_ind . s_i==16) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}
N		if(sub_ind==14) 
X		if(a_ind . s_i==14) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}
N		if(sub_ind==12) 
X		if(a_ind . s_i==12) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}
N		if(sub_ind==7) 
X		if(a_ind . s_i==7) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}
N		if(sub_ind==5) 
X		if(a_ind . s_i==5) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}
N		if(sub_ind==3) 
X		if(a_ind . s_i==3) 
N			{
N			sub_ind--;
X			a_ind . s_i--;
N			}
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=si_max;
X		a_ind . s_i=si_max;
N		}
N	else if(but==butLR_)
X	else if(but==103)
N		{
N		lc640_write_int(EE_ETH_IS_ON,1);
X		lc640_write_int(0x10+500+200,1);
N		lc640_write_int(EE_ETH_DHCP_ON,1);
X		lc640_write_int(0x10+500+200+2,1);
N		lc640_write_int(EE_ETH_IP_1,192);
X		lc640_write_int(0x10+500+200+4,192);
N		lc640_write_int(EE_ETH_IP_2,168);
X		lc640_write_int(0x10+500+200+6,168);
N		lc640_write_int(EE_ETH_IP_3,1);
X		lc640_write_int(0x10+500+200+8,1);
N		lc640_write_int(EE_ETH_IP_4,251);
X		lc640_write_int(0x10+500+200+10,251);
N		#ifdef UKU_KONTUR
S		lc640_write_int(EE_ETH_IP_4,230);
N		#endif
N		lc640_write_int(EE_ETH_MASK_1,255);
X		lc640_write_int(0x10+500+200+12,255);
N		lc640_write_int(EE_ETH_MASK_2,255);
X		lc640_write_int(0x10+500+200+14,255);
N		lc640_write_int(EE_ETH_MASK_3,255);
X		lc640_write_int(0x10+500+200+16,255);
N		lc640_write_int(EE_ETH_MASK_4,0);
X		lc640_write_int(0x10+500+200+18,0);
N		lc640_write_int(EE_ETH_GW_1,192);
X		lc640_write_int(0x10+500+200+64,192);
N		lc640_write_int(EE_ETH_GW_2,168);
X		lc640_write_int(0x10+500+200+66,168);
N		lc640_write_int(EE_ETH_GW_3,1);
X		lc640_write_int(0x10+500+200+68,1);
N		lc640_write_int(EE_ETH_GW_4,254);
X		lc640_write_int(0x10+500+200+70,254);
N		lc640_write_int(EE_ETH_SNMP_PORT_READ,161);
X		lc640_write_int(0x10+500+200+60,161);
N		lc640_write_int(EE_ETH_SNMP_PORT_WRITE,162);
X		lc640_write_int(0x10+500+200+62,162);
N		lc640_write_int(EE_COMMUNITY,'1');
X		lc640_write_int(0x10+500+200+270,'1');
N		lc640_write_int(EE_COMMUNITY+2,'2');
X		lc640_write_int(0x10+500+200+270+2,'2');
N		lc640_write_int(EE_COMMUNITY+4,'3');
X		lc640_write_int(0x10+500+200+270+4,'3');
N		lc640_write_int(EE_COMMUNITY+6,0);
X		lc640_write_int(0x10+500+200+270+6,0);
N		lc640_write_int(EE_COMMUNITY+8,0);
X		lc640_write_int(0x10+500+200+270+8,0);
N		lc640_write_int(EE_ETH_TRAP1_IP_1,255);
X		lc640_write_int(0x10+500+200+20,255);
N		lc640_write_int(EE_ETH_TRAP1_IP_2,255);
X		lc640_write_int(0x10+500+200+22,255);
N		lc640_write_int(EE_ETH_TRAP1_IP_3,255);
X		lc640_write_int(0x10+500+200+24,255);
N		lc640_write_int(EE_ETH_TRAP1_IP_4,255);
X		lc640_write_int(0x10+500+200+26,255);
N		lc640_write_int(EE_ETH_TRAP2_IP_1,255);
X		lc640_write_int(0x10+500+200+28,255);
N		lc640_write_int(EE_ETH_TRAP2_IP_2,255);
X		lc640_write_int(0x10+500+200+30,255);
N		lc640_write_int(EE_ETH_TRAP2_IP_3,255);
X		lc640_write_int(0x10+500+200+32,255);
N		lc640_write_int(EE_ETH_TRAP2_IP_4,255);
X		lc640_write_int(0x10+500+200+34,255);
N		lc640_write_int(EE_ETH_TRAP3_IP_1,255);
X		lc640_write_int(0x10+500+200+36,255);
N		lc640_write_int(EE_ETH_TRAP3_IP_2,255);
X		lc640_write_int(0x10+500+200+38,255);
N		lc640_write_int(EE_ETH_TRAP3_IP_3,255);
X		lc640_write_int(0x10+500+200+40,255);
N		lc640_write_int(EE_ETH_TRAP3_IP_4,255);
X		lc640_write_int(0x10+500+200+42,255);
N		lc640_write_int(EE_ETH_TRAP4_IP_1,255);
X		lc640_write_int(0x10+500+200+44,255);
N		lc640_write_int(EE_ETH_TRAP4_IP_2,255);
X		lc640_write_int(0x10+500+200+46,255);
N		lc640_write_int(EE_ETH_TRAP4_IP_3,255);
X		lc640_write_int(0x10+500+200+48,255);
N		lc640_write_int(EE_ETH_TRAP4_IP_4,255);
X		lc640_write_int(0x10+500+200+50,255);
N		lc640_write_int(EE_ETH_TRAP5_IP_1,255);
X		lc640_write_int(0x10+500+200+52,255);
N		lc640_write_int(EE_ETH_TRAP5_IP_2,255);
X		lc640_write_int(0x10+500+200+54,255);
N		lc640_write_int(EE_ETH_TRAP5_IP_3,255);
X		lc640_write_int(0x10+500+200+56,255);
N		lc640_write_int(EE_ETH_TRAP5_IP_4,255);
X		lc640_write_int(0x10+500+200+58,255);
N		}					
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {
N	     if((but==butE)||(but==butL)||(but==butR))
X	     if((but==254)||(but==247)||(but==239))
N	     	{
N	     	if(ETH_IS_ON)lc640_write_int(EE_ETH_IS_ON,0);
X	     	if(ETH_IS_ON)lc640_write_int(0x10+500+200,0);
N			else lc640_write_int(EE_ETH_IS_ON,1);
X			else lc640_write_int(0x10+500+200,1);
N	     	}
N	     }	
N     else if((sub_ind==1)&&(ETH_IS_ON))
X     else if((a_ind . s_i==1)&&(ETH_IS_ON))
N	     {
N		if((but==butE)||(but==butL)||(but==butR))
X		if((but==254)||(but==247)||(but==239))
N	     	{
N	     	if(ETH_DHCP_ON)lc640_write_int(EE_ETH_DHCP_ON,0);
X	     	if(ETH_DHCP_ON)lc640_write_int(0x10+500+200+2,0);
N			else lc640_write_int(EE_ETH_DHCP_ON,1);
X			else lc640_write_int(0x10+500+200+2,1);
N	     	}
N		}	
N     else if(sub_ind==2)
X     else if(a_ind . s_i==2)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_IP_1++;
N				gran_ring(&ETH_IP_1,0,255);
N				lc640_write_int(EE_ETH_IP_1,ETH_IP_1);
X				lc640_write_int(0x10+500+200+4,ETH_IP_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_IP_1--;
N				gran_ring(&ETH_IP_1,0,255);
N				lc640_write_int(EE_ETH_IP_1,ETH_IP_1);
X				lc640_write_int(0x10+500+200+4,ETH_IP_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_IP_2++;
N				gran_ring(&ETH_IP_2,0,255);
N				lc640_write_int(EE_ETH_IP_2,ETH_IP_2);
X				lc640_write_int(0x10+500+200+6,ETH_IP_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_IP_2--;
N				gran_ring(&ETH_IP_2,0,255);
N				lc640_write_int(EE_ETH_IP_2,ETH_IP_2);
X				lc640_write_int(0x10+500+200+6,ETH_IP_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_IP_3++;
N				gran_ring(&ETH_IP_3,0,255);
N				lc640_write_int(EE_ETH_IP_3,ETH_IP_3);
X				lc640_write_int(0x10+500+200+8,ETH_IP_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_IP_3--;
N				gran_ring(&ETH_IP_3,0,255);
N				lc640_write_int(EE_ETH_IP_3,ETH_IP_3);
X				lc640_write_int(0x10+500+200+8,ETH_IP_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_IP_4++;
N				gran_ring(&ETH_IP_4,0,255);
N				lc640_write_int(EE_ETH_IP_4,ETH_IP_4);
X				lc640_write_int(0x10+500+200+10,ETH_IP_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_IP_4--;
N				gran_ring(&ETH_IP_4,0,255);
N				lc640_write_int(EE_ETH_IP_4,ETH_IP_4);
X				lc640_write_int(0x10+500+200+10,ETH_IP_4);
N				}
N			speed=1;
N			}
N
N          }
N     else if(sub_ind==4)
X     else if(a_ind . s_i==4)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_MASK_1++;
N				gran_ring(&ETH_MASK_1,0,255);
N				lc640_write_int(EE_ETH_MASK_1,ETH_MASK_1);
X				lc640_write_int(0x10+500+200+12,ETH_MASK_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_MASK_1--;
N				gran_ring(&ETH_MASK_1,0,255);
N				lc640_write_int(EE_ETH_MASK_1,ETH_MASK_1);
X				lc640_write_int(0x10+500+200+12,ETH_MASK_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_MASK_2++;
N				gran_ring(&ETH_MASK_2,0,255);
N				lc640_write_int(EE_ETH_MASK_2,ETH_MASK_2);
X				lc640_write_int(0x10+500+200+14,ETH_MASK_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_MASK_2--;
N				gran_ring(&ETH_MASK_2,0,255);
N				lc640_write_int(EE_ETH_MASK_2,ETH_MASK_2);
X				lc640_write_int(0x10+500+200+14,ETH_MASK_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_MASK_3++;
N				gran_ring(&ETH_MASK_3,0,255);
N				lc640_write_int(EE_ETH_MASK_3,ETH_MASK_3);
X				lc640_write_int(0x10+500+200+16,ETH_MASK_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_MASK_3--;
N				gran_ring(&ETH_MASK_3,0,255);
N				lc640_write_int(EE_ETH_MASK_3,ETH_MASK_3);
X				lc640_write_int(0x10+500+200+16,ETH_MASK_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_MASK_4++;
N				gran_ring(&ETH_MASK_4,0,255);
N				lc640_write_int(EE_ETH_MASK_4,ETH_MASK_4);
X				lc640_write_int(0x10+500+200+18,ETH_MASK_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_MASK_4--;
N				gran_ring(&ETH_MASK_4,0,255);
N				lc640_write_int(EE_ETH_MASK_4,ETH_MASK_4);
X				lc640_write_int(0x10+500+200+18,ETH_MASK_4);
N				}
N			speed=1;
N			}
N		}
N     else if(sub_ind==6)
X     else if(a_ind . s_i==6)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_GW_1++;
N				gran_ring(&ETH_GW_1,0,255);
N				lc640_write_int(EE_ETH_GW_1,ETH_GW_1);
X				lc640_write_int(0x10+500+200+64,ETH_GW_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_GW_1--;
N				gran_ring(&ETH_GW_1,0,255);
N				lc640_write_int(EE_ETH_GW_1,ETH_GW_1);
X				lc640_write_int(0x10+500+200+64,ETH_GW_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_GW_2++;
N				gran_ring(&ETH_GW_2,0,255);
N				lc640_write_int(EE_ETH_GW_2,ETH_GW_2);
X				lc640_write_int(0x10+500+200+66,ETH_GW_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_GW_2--;
N				gran_ring(&ETH_GW_2,0,255);
N				lc640_write_int(EE_ETH_GW_2,ETH_GW_2);
X				lc640_write_int(0x10+500+200+66,ETH_GW_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_GW_3++;
N				gran_ring(&ETH_GW_3,0,255);
N				lc640_write_int(EE_ETH_GW_3,ETH_GW_3);
X				lc640_write_int(0x10+500+200+68,ETH_GW_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_GW_3--;
N				gran_ring(&ETH_GW_3,0,255);
N				lc640_write_int(EE_ETH_GW_3,ETH_GW_3);
X				lc640_write_int(0x10+500+200+68,ETH_GW_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_GW_4++;
N				gran_ring(&ETH_GW_4,0,255);
N				lc640_write_int(EE_ETH_GW_4,ETH_GW_4);
X				lc640_write_int(0x10+500+200+70,ETH_GW_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_GW_4--;
N				gran_ring(&ETH_GW_4,0,255);
N				lc640_write_int(EE_ETH_GW_4,ETH_GW_4);
X				lc640_write_int(0x10+500+200+70,ETH_GW_4);
N				}
N			speed=1;
N			}
N		}
N      else if(sub_ind==8)
X      else if(a_ind . s_i==8)
N	     {
N		if(but==butR)ETH_SNMP_PORT_READ++;
X		if(but==239)ETH_SNMP_PORT_READ++;
N		else if(but==butR_)ETH_SNMP_PORT_READ+=2;
X		else if(but==111)ETH_SNMP_PORT_READ+=2;
N		else if(but==butL)ETH_SNMP_PORT_READ--;
X		else if(but==247)ETH_SNMP_PORT_READ--;
N		else if(but==butL_)ETH_SNMP_PORT_READ-=2;
X		else if(but==119)ETH_SNMP_PORT_READ-=2;
N		speed=1;
N		lc640_write_int(EE_ETH_SNMP_PORT_READ,ETH_SNMP_PORT_READ);
X		lc640_write_int(0x10+500+200+60,ETH_SNMP_PORT_READ);
N		}
N
N     else if(sub_ind==9)
X     else if(a_ind . s_i==9)
N	     {
N		if(but==butR)ETH_SNMP_PORT_WRITE++;
X		if(but==239)ETH_SNMP_PORT_WRITE++;
N		else if(but==butR_)ETH_SNMP_PORT_WRITE+=2;
X		else if(but==111)ETH_SNMP_PORT_WRITE+=2;
N		else if(but==butL)ETH_SNMP_PORT_WRITE--;
X		else if(but==247)ETH_SNMP_PORT_WRITE--;
N		else if(but==butL_)ETH_SNMP_PORT_WRITE-=2;
X		else if(but==119)ETH_SNMP_PORT_WRITE-=2;
N		speed=1;
N		lc640_write_int(EE_ETH_SNMP_PORT_WRITE,ETH_SNMP_PORT_WRITE);
X		lc640_write_int(0x10+500+200+62,ETH_SNMP_PORT_WRITE);
N		}					
N     else if(sub_ind==10)
X     else if(a_ind . s_i==10)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,8);
X			gran_ring_char(&a_ind . s_i1,0,8);
N	     	}
N		if((but==butR)||(but==butR_))
X		if((but==239)||(but==111))
N			{
N			snmp_community[sub_ind1]++;
X			snmp_community[a_ind . s_i1]++;
N			if(snmp_community[sub_ind1]<32) snmp_community[sub_ind1]=32;
X			if(snmp_community[a_ind . s_i1]<32) snmp_community[a_ind . s_i1]=32;
N			else if ((snmp_community[sub_ind1]>32)&&(snmp_community[sub_ind1]<48)) snmp_community[sub_ind1]=48;
X			else if ((snmp_community[a_ind . s_i1]>32)&&(snmp_community[a_ind . s_i1]<48)) snmp_community[a_ind . s_i1]=48;
N			else if ((snmp_community[sub_ind1]>57)&&(snmp_community[sub_ind1]<65)) snmp_community[sub_ind1]=65;
X			else if ((snmp_community[a_ind . s_i1]>57)&&(snmp_community[a_ind . s_i1]<65)) snmp_community[a_ind . s_i1]=65;
N			else if ((snmp_community[sub_ind1]>90)&&(snmp_community[sub_ind1]<97)) snmp_community[sub_ind1]=97;
X			else if ((snmp_community[a_ind . s_i1]>90)&&(snmp_community[a_ind . s_i1]<97)) snmp_community[a_ind . s_i1]=97;
N			else if (snmp_community[sub_ind1]>122) snmp_community[sub_ind1]=32;
X			else if (snmp_community[a_ind . s_i1]>122) snmp_community[a_ind . s_i1]=32;
N				//gran_ring(&ETH_GW_1,0,255);
N			lc640_write_int(EE_COMMUNITY+(sub_ind1*2),snmp_community[sub_ind1]);
X			lc640_write_int(0x10+500+200+270+(a_ind . s_i1*2),snmp_community[a_ind . s_i1]);
N			speed=1;
N			}
N		if((but==butL)||(but==butL_))
X		if((but==247)||(but==119))
N			{
N			snmp_community[sub_ind1]--;
X			snmp_community[a_ind . s_i1]--;
N			if(snmp_community[sub_ind1]<32) snmp_community[sub_ind1]=122;
X			if(snmp_community[a_ind . s_i1]<32) snmp_community[a_ind . s_i1]=122;
N			else if ((snmp_community[sub_ind1]>32)&&(snmp_community[sub_ind1]<48)) snmp_community[sub_ind1]=32;
X			else if ((snmp_community[a_ind . s_i1]>32)&&(snmp_community[a_ind . s_i1]<48)) snmp_community[a_ind . s_i1]=32;
N			else if ((snmp_community[sub_ind1]>57)&&(snmp_community[sub_ind1]<65)) snmp_community[sub_ind1]=57;
X			else if ((snmp_community[a_ind . s_i1]>57)&&(snmp_community[a_ind . s_i1]<65)) snmp_community[a_ind . s_i1]=57;
N			else if ((snmp_community[sub_ind1]>90)&&(snmp_community[sub_ind1]<97)) snmp_community[sub_ind1]=90;
X			else if ((snmp_community[a_ind . s_i1]>90)&&(snmp_community[a_ind . s_i1]<97)) snmp_community[a_ind . s_i1]=90;
N			else if (snmp_community[sub_ind1]>122) snmp_community[sub_ind1]=122;
X			else if (snmp_community[a_ind . s_i1]>122) snmp_community[a_ind . s_i1]=122;
N			//gran_ring(&ETH_GW_1,0,255);
N			lc640_write_int(EE_COMMUNITY+(sub_ind1*2),snmp_community[sub_ind1]);
X			lc640_write_int(0x10+500+200+270+(a_ind . s_i1*2),snmp_community[a_ind . s_i1]);
N			speed=1;
N			}
N		}
N 
N     else if(sub_ind==11)
X     else if(a_ind . s_i==11)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP1_IP_1++;
N				gran_ring(&ETH_TRAP1_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_1,ETH_TRAP1_IP_1);
X				lc640_write_int(0x10+500+200+20,ETH_TRAP1_IP_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP1_IP_1--;
N				gran_ring(&ETH_TRAP1_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_1,ETH_TRAP1_IP_1);
X				lc640_write_int(0x10+500+200+20,ETH_TRAP1_IP_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP1_IP_2++;
N				gran_ring(&ETH_TRAP1_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_2,ETH_TRAP1_IP_2);
X				lc640_write_int(0x10+500+200+22,ETH_TRAP1_IP_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP1_IP_2--;
N				gran_ring(&ETH_TRAP1_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_2,ETH_TRAP1_IP_2);
X				lc640_write_int(0x10+500+200+22,ETH_TRAP1_IP_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP1_IP_3++;
N				gran_ring(&ETH_TRAP1_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_3,ETH_TRAP1_IP_3);
X				lc640_write_int(0x10+500+200+24,ETH_TRAP1_IP_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP1_IP_3--;
N				gran_ring(&ETH_TRAP1_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_3,ETH_TRAP1_IP_3);
X				lc640_write_int(0x10+500+200+24,ETH_TRAP1_IP_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP1_IP_4++;
N				gran_ring(&ETH_TRAP1_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_4,ETH_TRAP1_IP_4);
X				lc640_write_int(0x10+500+200+26,ETH_TRAP1_IP_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP1_IP_4--;
N				gran_ring(&ETH_TRAP1_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP1_IP_4,ETH_TRAP1_IP_4);
X				lc640_write_int(0x10+500+200+26,ETH_TRAP1_IP_4);
N				}
N			speed=1;
N			}
N		}	
N     else if(sub_ind==13)
X     else if(a_ind . s_i==13)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP2_IP_1++;
N				gran_ring(&ETH_TRAP2_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_1,ETH_TRAP2_IP_1);
X				lc640_write_int(0x10+500+200+28,ETH_TRAP2_IP_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP2_IP_1--;
N				gran_ring(&ETH_TRAP2_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_1,ETH_TRAP2_IP_1);
X				lc640_write_int(0x10+500+200+28,ETH_TRAP2_IP_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP2_IP_2++;
N				gran_ring(&ETH_TRAP2_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_2,ETH_TRAP2_IP_2);
X				lc640_write_int(0x10+500+200+30,ETH_TRAP2_IP_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP2_IP_2--;
N				gran_ring(&ETH_TRAP2_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_2,ETH_TRAP2_IP_2);
X				lc640_write_int(0x10+500+200+30,ETH_TRAP2_IP_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP2_IP_3++;
N				gran_ring(&ETH_TRAP2_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_3,ETH_TRAP2_IP_3);
X				lc640_write_int(0x10+500+200+32,ETH_TRAP2_IP_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP2_IP_3--;
N				gran_ring(&ETH_TRAP2_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_3,ETH_TRAP2_IP_3);
X				lc640_write_int(0x10+500+200+32,ETH_TRAP2_IP_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP2_IP_4++;
N				gran_ring(&ETH_TRAP2_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_4,ETH_TRAP2_IP_4);
X				lc640_write_int(0x10+500+200+34,ETH_TRAP2_IP_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP2_IP_4--;
N				gran_ring(&ETH_TRAP2_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP2_IP_4,ETH_TRAP2_IP_4);
X				lc640_write_int(0x10+500+200+34,ETH_TRAP2_IP_4);
N				}
N			speed=1;
N			}
N		}	
N     else if(sub_ind==15)
X     else if(a_ind . s_i==15)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP3_IP_1++;
N				gran_ring(&ETH_TRAP3_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_1,ETH_TRAP3_IP_1);
X				lc640_write_int(0x10+500+200+36,ETH_TRAP3_IP_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP3_IP_1--;
N				gran_ring(&ETH_TRAP3_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_1,ETH_TRAP3_IP_1);
X				lc640_write_int(0x10+500+200+36,ETH_TRAP3_IP_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP3_IP_2++;
N				gran_ring(&ETH_TRAP3_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_2,ETH_TRAP3_IP_2);
X				lc640_write_int(0x10+500+200+38,ETH_TRAP3_IP_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP3_IP_2--;
N				gran_ring(&ETH_TRAP3_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_2,ETH_TRAP3_IP_2);
X				lc640_write_int(0x10+500+200+38,ETH_TRAP3_IP_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP3_IP_3++;
N				gran_ring(&ETH_TRAP3_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_3,ETH_TRAP3_IP_3);
X				lc640_write_int(0x10+500+200+40,ETH_TRAP3_IP_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP3_IP_3--;
N				gran_ring(&ETH_TRAP3_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_3,ETH_TRAP3_IP_3);
X				lc640_write_int(0x10+500+200+40,ETH_TRAP3_IP_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP3_IP_4++;
N				gran_ring(&ETH_TRAP3_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_4,ETH_TRAP3_IP_4);
X				lc640_write_int(0x10+500+200+42,ETH_TRAP3_IP_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP3_IP_4--;
N				gran_ring(&ETH_TRAP3_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP3_IP_4,ETH_TRAP3_IP_4);
X				lc640_write_int(0x10+500+200+42,ETH_TRAP3_IP_4);
N				}
N			speed=1;
N			}
N		}	
N     else if(sub_ind==17)
X     else if(a_ind . s_i==17)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP4_IP_1++;
N				gran_ring(&ETH_TRAP4_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_1,ETH_TRAP4_IP_1);
X				lc640_write_int(0x10+500+200+44,ETH_TRAP4_IP_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP4_IP_1--;
N				gran_ring(&ETH_TRAP4_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_1,ETH_TRAP4_IP_1);
X				lc640_write_int(0x10+500+200+44,ETH_TRAP4_IP_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP4_IP_2++;
N				gran_ring(&ETH_TRAP4_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_2,ETH_TRAP4_IP_2);
X				lc640_write_int(0x10+500+200+46,ETH_TRAP4_IP_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP4_IP_2--;
N				gran_ring(&ETH_TRAP4_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_2,ETH_TRAP4_IP_2);
X				lc640_write_int(0x10+500+200+46,ETH_TRAP4_IP_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP4_IP_3++;
N				gran_ring(&ETH_TRAP4_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_3,ETH_TRAP4_IP_3);
X				lc640_write_int(0x10+500+200+48,ETH_TRAP4_IP_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP4_IP_3--;
N				gran_ring(&ETH_TRAP4_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_3,ETH_TRAP4_IP_3);
X				lc640_write_int(0x10+500+200+48,ETH_TRAP4_IP_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP4_IP_4++;
N				gran_ring(&ETH_TRAP4_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_4,ETH_TRAP4_IP_4);
X				lc640_write_int(0x10+500+200+50,ETH_TRAP4_IP_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP4_IP_4--;
N				gran_ring(&ETH_TRAP4_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP4_IP_4,ETH_TRAP4_IP_4);
X				lc640_write_int(0x10+500+200+50,ETH_TRAP4_IP_4);
N				}
N			speed=1;
N			}
N		}	
N     else if(sub_ind==19)
X     else if(a_ind . s_i==19)
N	     {
N		if(but==butE_)
X		if(but==126)
N	     	{
N	     	sub_ind1++;
X	     	a_ind . s_i1++;
N			gran_ring_char(&sub_ind1,0,3);
X			gran_ring_char(&a_ind . s_i1,0,3);
N	     	}
N		else if(sub_ind1==0)
X		else if(a_ind . s_i1==0)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP5_IP_1++;
N				gran_ring(&ETH_TRAP5_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_1,ETH_TRAP5_IP_1);
X				lc640_write_int(0x10+500+200+52,ETH_TRAP5_IP_1);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP5_IP_1--;
N				gran_ring(&ETH_TRAP5_IP_1,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_1,ETH_TRAP5_IP_1);
X				lc640_write_int(0x10+500+200+52,ETH_TRAP5_IP_1);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==1)
X		else if(a_ind . s_i1==1)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP5_IP_2++;
N				gran_ring(&ETH_TRAP5_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_2,ETH_TRAP5_IP_2);
X				lc640_write_int(0x10+500+200+54,ETH_TRAP5_IP_2);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP5_IP_2--;
N				gran_ring(&ETH_TRAP5_IP_2,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_2,ETH_TRAP5_IP_2);
X				lc640_write_int(0x10+500+200+54,ETH_TRAP5_IP_2);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==2)
X		else if(a_ind . s_i1==2)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP5_IP_3++;
N				gran_ring(&ETH_TRAP5_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_3,ETH_TRAP5_IP_3);
X				lc640_write_int(0x10+500+200+56,ETH_TRAP5_IP_3);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP5_IP_3--;
N				gran_ring(&ETH_TRAP5_IP_3,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_3,ETH_TRAP5_IP_3);
X				lc640_write_int(0x10+500+200+56,ETH_TRAP5_IP_3);
N				}
N			speed=1;
N			}
N		else if(sub_ind1==3)
X		else if(a_ind . s_i1==3)
N			{
N			if((but==butR)||(but==butR_))
X			if((but==239)||(but==111))
N				{
N				ETH_TRAP5_IP_4++;
N				gran_ring(&ETH_TRAP5_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_4,ETH_TRAP5_IP_4);
X				lc640_write_int(0x10+500+200+58,ETH_TRAP5_IP_4);
N				}
N			else if((but==butL)||(but==butL_))
X			else if((but==247)||(but==119))
N				{
N				ETH_TRAP5_IP_4--;
N				gran_ring(&ETH_TRAP5_IP_4,0,255);
N				lc640_write_int(EE_ETH_TRAP5_IP_4,ETH_TRAP5_IP_4);
X				lc640_write_int(0x10+500+200+58,ETH_TRAP5_IP_4);
N				}
N			speed=1;
N			}
N		}													          
N    else if(sub_ind==si_max)
X    else if(a_ind . s_i==si_max)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N	          tree_down(0,0);
N	          }
N          }	          	
N	}
N
N
Nelse if (ind==iBlok_ips_set)
Xelse if (a_ind . i==iBlok_ips_set)
N	{
N    ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)sub_ind=3;
X		if(a_ind . s_i==2)a_ind . s_i=3;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}			
N     
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if((but==butR)||(but==butR_))
X		if((but==239)||(but==111))
N			{
N			ipsBlckSrc++;
N			gran(&ipsBlckSrc,0,2);
N			lc640_write_int(EE_IPS_BLOCK_SRC,ipsBlckSrc);
X			lc640_write_int(0x10+100+190,ipsBlckSrc);
N			}
N		else if((but==butL)||(but==butL_))
X		else if((but==247)||(but==119))
N			{
N			ipsBlckSrc--;
N			gran(&ipsBlckSrc,0,2);
N			lc640_write_int(EE_IPS_BLOCK_SRC,ipsBlckSrc);
X			lc640_write_int(0x10+100+190,ipsBlckSrc);
N			}
N		speed=1;
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if((but==butR)||(but==butR_))
X		if((but==239)||(but==111))
N			{
N			ipsBlckLog=1;
N			lc640_write_int(EE_IPS_BLOCK_LOG,ipsBlckLog);
X			lc640_write_int(0x10+100+192,ipsBlckLog);
N			}
N		else if((but==butL)||(but==butL_))
X		else if((but==247)||(but==119))
N			{
N			ipsBlckLog=0;
N			lc640_write_int(EE_IPS_BLOCK_LOG,ipsBlckLog);
X			lc640_write_int(0x10+100+192,ipsBlckLog);
N			}
N		speed=1;
N		}
N
N	else if((sub_ind==3)&&(but==butE))
X	else if((a_ind . s_i==3)&&(but==254))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		} 												
N	}
N
Nelse if (ind==iApv)
Xelse if (a_ind . i==iApv)
N	{
N     ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=simax;
X		a_ind . s_i=simax;
N		}			
N	else if(but==butE)
X	else if(but==254)
N	     {
N	     if(sub_ind==simax)
X	     if(a_ind . s_i==simax)
N	          {
N	          //a=b[--ptr_ind];
N	          tree_down(0,0);
N	          }
N	     else if(sub_ind==0)   
X	     else if(a_ind . s_i==0)   
N	          {
N	          if(APV_ON1==apvON)lc640_write_int(EE_APV_ON1,apvOFF);
X	          if(APV_ON1==apvON)lc640_write_int(0x10+100+44,apvOFF);
N	          else lc640_write_int(EE_APV_ON1,apvON);
X	          else lc640_write_int(0x10+100+44,apvON);
N	          }
N          else if((sub_ind==1)&&(APV_ON1==apvON))   
X          else if((a_ind . s_i==1)&&(APV_ON1==apvON))   
N	          {
N	          if(APV_ON2==apvON)lc640_write_int(EE_APV_ON2,apvOFF);
X	          if(APV_ON2==apvON)lc640_write_int(0x10+100+46,apvOFF);
N	          else lc640_write_int(EE_APV_ON2,apvON);
X	          else lc640_write_int(0x10+100+46,apvON);
N	          }	 
N          }
N     
N     else if((sub_ind==2)&&(APV_ON2==apvON))   
X     else if((a_ind . s_i==2)&&(APV_ON2==apvON))   
N          {
N	     if((but==butR)||(but==butR_))
X	     if((but==239)||(but==111))
N	          {
N	          signed short tempSS;
N	          tempSS=APV_ON2_TIME;
N	          tempSS++;
N	          gran(&tempSS,1,24);
N	          lc640_write_int(EE_APV_ON2_TIME,tempSS);
X	          lc640_write_int(0x10+100+48,tempSS);
N	          }
N          else if((but==butL)||(but==butL_))
X          else if((but==247)||(but==119))
N	          {
N	          signed short tempSS;
N	          tempSS=APV_ON2_TIME;
N	          tempSS--;
N	          gran(&tempSS,1,24);
N	          lc640_write_int(EE_APV_ON2_TIME,tempSS);
X	          lc640_write_int(0x10+100+48,tempSS);
N	          }	          
N	     speed=1;
N	     }	 
N  	} 
N
Nelse if (ind==iExt_set)
Xelse if (a_ind . i==iExt_set)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);		
X		gran_char(&a_ind . s_i,0,3);		
N		}
N
N	else if((but==butE)&&(sub_ind==0))
X	else if((but==254)&&(a_ind . s_i==0))
N		{
N	     tree_up(iExt_ddv,0,0,0);
N	     ret(0);
N		}
N
N	else if((but==butE)&&(sub_ind==1))
X	else if((but==254)&&(a_ind . s_i==1))
N		{
N	     tree_up(iExt_ddi,0,0,0);
N	     ret(0);
N		}
N	else if((but==butE)&&(sub_ind==2))
X	else if((but==254)&&(a_ind . s_i==2))
N		{
N	     tree_up(iExt_dud,0,0,0);
N	     ret(0);
N		}
N/*	else if((but==butE)&&(sub_ind==3))
N		{
N	     tree_up(iExt_dp,0,0,0);
N	     ret(0);
N		} */
N		
N	else if((but==butE)&&(sub_ind==3))
X	else if((but==254)&&(a_ind . s_i==3))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}        	
N	}
N
Nelse if (ind==iExt_set_3U)
Xelse if (a_ind . i==iExt_set_3U)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMSK);
X		gran_char(&a_ind . s_i,0,NUMSK);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMSK);		
X		gran_char(&a_ind . s_i,0,NUMSK);		
N		}
N 	else if((but==butE)&&(sub_ind==NUMSK))
X 	else if((but==254)&&(a_ind . s_i==NUMSK))
N		{
N	     tree_down(0,0);
N	     ret(0);
N		}
N	else if((but==butE)&&(sub_ind==0))
X	else if((but==254)&&(a_ind . s_i==0))
N		{
N	     tree_up(iExt_sk_3U,0,0,0);
N	     ret(0);
N		}
N	else if((but==butE)&&(sub_ind==1))
X	else if((but==254)&&(a_ind . s_i==1))
N		{
N	     tree_up(iExt_sk_3U,0,0,1);
N	     ret(0);
N		}
N	else if((but==butE)&&(sub_ind==2))
X	else if((but==254)&&(a_ind . s_i==2))
N		{
N	     tree_up(iExt_sk_3U,0,0,2);
N	     ret(0);
N		}
N	else if((but==butE)&&(sub_ind==3))
X	else if((but==254)&&(a_ind . s_i==3))
N		{
N	     tree_up(iExt_sk_3U,0,0,3);
N	     ret(0);
N		} 
N	}
N
Nelse if (ind==iExt_dt)
Xelse if (a_ind . i==iExt_dt)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,1,7);
X		gran_char(&a_ind . s_i,1,7);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		if(sub_ind==1)index_set=0;
X		if(a_ind . s_i==1)a_ind . i_s=0;
N		else sub_ind--;
X		else a_ind . s_i--;
N		gran_char(&sub_ind,1,7);
X		gran_char(&a_ind . s_i,1,7);
N		}	
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=7;
X		a_ind . s_i=7;
N		}			
N		
N	else if(sub_ind==1) 
X	else if(a_ind . s_i==1) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!TMAX_EXT_EN[sub_ind1])lc640_write_int(ADR_TMAX_EXT_EN[sub_ind1],0xffff);
X			if(!TMAX_EXT_EN[a_ind . s_i1])lc640_write_int(ADR_TMAX_EXT_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_TMAX_EXT_EN[sub_ind1],0);
X			else lc640_write_int(ADR_TMAX_EXT_EN[a_ind . s_i1],0);
N			}
N		else if((but==butR)||(but==butR_))
X		else if((but==239)||(but==111))
N			{
N			TMAX_EXT[sub_ind1]++;
X			TMAX_EXT[a_ind . s_i1]++;
N			}	
N		else if((but==butL)||(but==butL_))
X		else if((but==247)||(but==119))
N			{
N			TMAX_EXT[sub_ind1]--;
X			TMAX_EXT[a_ind . s_i1]--;
N			}	
N		gran(&TMAX_EXT[sub_ind1],-50,100);
X		gran(&TMAX_EXT[a_ind . s_i1],-50,100);
N		if(lc640_read_int(ADR_TMAX_EXT[sub_ind1])!=TMAX_EXT[sub_ind1]) lc640_write_int(ADR_TMAX_EXT[sub_ind1],TMAX_EXT[sub_ind1]);			
X		if(lc640_read_int(ADR_TMAX_EXT[a_ind . s_i1])!=TMAX_EXT[a_ind . s_i1]) lc640_write_int(ADR_TMAX_EXT[a_ind . s_i1],TMAX_EXT[a_ind . s_i1]);			
N		speed=1;
N		}
N	else if(sub_ind==2) 
X	else if(a_ind . s_i==2) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!TMIN_EXT_EN[sub_ind1])lc640_write_int(ADR_TMIN_EXT_EN[sub_ind1],0xffff);
X			if(!TMIN_EXT_EN[a_ind . s_i1])lc640_write_int(ADR_TMIN_EXT_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_TMIN_EXT_EN[sub_ind1],0);
X			else lc640_write_int(ADR_TMIN_EXT_EN[a_ind . s_i1],0);
N			}
N		else if((but==butR)||(but==butR_))
X		else if((but==239)||(but==111))
N			{
N			TMIN_EXT[sub_ind1]++;
X			TMIN_EXT[a_ind . s_i1]++;
N			}	
N		else if((but==butL)||(but==butL_))
X		else if((but==247)||(but==119))
N			{
N			TMIN_EXT[sub_ind1]--;
X			TMIN_EXT[a_ind . s_i1]--;
N			}	
N		gran(&TMIN_EXT[sub_ind1],-50,100);
X		gran(&TMIN_EXT[a_ind . s_i1],-50,100);
N		if(lc640_read_int(ADR_TMIN_EXT[sub_ind1])!=TMIN_EXT[sub_ind1]) lc640_write_int(ADR_TMIN_EXT[sub_ind1],TMIN_EXT[sub_ind1]);			
X		if(lc640_read_int(ADR_TMIN_EXT[a_ind . s_i1])!=TMIN_EXT[a_ind . s_i1]) lc640_write_int(ADR_TMIN_EXT[a_ind . s_i1],TMIN_EXT[a_ind . s_i1]);			
N		speed=1;
N		}		
N	else if(sub_ind==3) 
X	else if(a_ind . s_i==3) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!T_EXT_REL_EN[sub_ind1])lc640_write_int(ADR_T_EXT_REL_EN[sub_ind1],0xffff);
X			if(!T_EXT_REL_EN[a_ind . s_i1])lc640_write_int(ADR_T_EXT_REL_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_T_EXT_REL_EN[sub_ind1],0);
X			else lc640_write_int(ADR_T_EXT_REL_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==4) 
X	else if(a_ind . s_i==4) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!T_EXT_ZVUK_EN[sub_ind1])lc640_write_int(ADR_T_EXT_ZVUK_EN[sub_ind1],0xffff);
X			if(!T_EXT_ZVUK_EN[a_ind . s_i1])lc640_write_int(ADR_T_EXT_ZVUK_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_T_EXT_ZVUK_EN[sub_ind1],0);
X			else lc640_write_int(ADR_T_EXT_ZVUK_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==5) 
X	else if(a_ind . s_i==5) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!T_EXT_LCD_EN[sub_ind1])lc640_write_int(ADR_T_EXT_LCD_EN[sub_ind1],0xffff);
X			if(!T_EXT_LCD_EN[a_ind . s_i1])lc640_write_int(ADR_T_EXT_LCD_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_T_EXT_LCD_EN[sub_ind1],0);
X			else lc640_write_int(ADR_T_EXT_LCD_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==6) 
X	else if(a_ind . s_i==6) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!T_EXT_RS_EN[sub_ind1])lc640_write_int(ADR_T_EXT_RS_EN[sub_ind1],0xffff);
X			if(!T_EXT_RS_EN[a_ind . s_i1])lc640_write_int(ADR_T_EXT_RS_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_T_EXT_RS_EN[sub_ind1],0);
X			else lc640_write_int(ADR_T_EXT_RS_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==7) 
X	else if(a_ind . s_i==7) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			//a=b[--ptr_ind];
N			}
N		}												
N	}	
N
Nelse if (ind==iExt_sk)
Xelse if (a_ind . i==iExt_sk)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)sub_ind=3;
X		if(a_ind . s_i==2)a_ind . s_i=3;
N		gran_char(&sub_ind,1,7);
X		gran_char(&a_ind . s_i,1,7);
N		
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		if(sub_ind==1)index_set=0;
X		if(a_ind . s_i==1)a_ind . i_s=0;
N		else sub_ind--;
X		else a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		gran_char(&sub_ind,1,7);
X		gran_char(&a_ind . s_i,1,7);
N		}	
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=7;
X		a_ind . s_i=7;
N		}			
N	else if(sub_ind==1) 
X	else if(a_ind . s_i==1) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_SIGN[sub_ind1])lc640_write_int(ADR_SK_SIGN[sub_ind1],0xffff);
X			if(!SK_SIGN[a_ind . s_i1])lc640_write_int(ADR_SK_SIGN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_SIGN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_SIGN[a_ind . s_i1],0);
N			}
N		}
N	else if(sub_ind==3) 
X	else if(a_ind . s_i==3) 
N		{
N	//	if(but==butE)
N		//	{
N	//		if(!SK_REL_EN[sub_ind1])lc640_write_int(ADR_SK_REL_EN[sub_ind1],0xffff);
N	//		else lc640_write_int(ADR_SK_REL_EN[sub_ind1],0);
N	//		}
N		}	
N	else if(sub_ind==4) 
X	else if(a_ind . s_i==4) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_ZVUK_EN[sub_ind1])lc640_write_int(ADR_SK_ZVUK_EN[sub_ind1],0xffff);
X			if(!SK_ZVUK_EN[a_ind . s_i1])lc640_write_int(ADR_SK_ZVUK_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_ZVUK_EN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_ZVUK_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==5) 
X	else if(a_ind . s_i==5) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_LCD_EN[sub_ind1])lc640_write_int(ADR_SK_LCD_EN[sub_ind1],0xffff);
X			if(!SK_LCD_EN[a_ind . s_i1])lc640_write_int(ADR_SK_LCD_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_LCD_EN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_LCD_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==6) 
X	else if(a_ind . s_i==6) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_RS_EN[sub_ind1])lc640_write_int(ADR_SK_RS_EN[sub_ind1],0xffff);
X			if(!SK_RS_EN[a_ind . s_i1])lc640_write_int(ADR_SK_RS_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_RS_EN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_RS_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==7) 
X	else if(a_ind . s_i==7) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			//a=b[--ptr_ind];
N			tree_down(0,0);
N			}
N		}												
N	}	
N
Nelse if (ind==iExt_sk_3U)
Xelse if (a_ind . i==iExt_sk_3U)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)sub_ind=3;
X		if(a_ind . s_i==2)a_ind . s_i=3;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		if(sub_ind==1)index_set=0;
X		if(a_ind . s_i==1)a_ind . i_s=0;
N		else sub_ind--;
X		else a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		}	
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=5;
X		a_ind . s_i=5;
N		}			
N	else if(sub_ind==1) 
X	else if(a_ind . s_i==1) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_SIGN[sub_ind1])lc640_write_int(ADR_SK_SIGN[sub_ind1],0xffff);
X			if(!SK_SIGN[a_ind . s_i1])lc640_write_int(ADR_SK_SIGN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_SIGN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_SIGN[a_ind . s_i1],0);
N			}
N		}
N	else if(sub_ind==3) 
X	else if(a_ind . s_i==3) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_ZVUK_EN[sub_ind1])lc640_write_int(ADR_SK_ZVUK_EN[sub_ind1],0xffff);
X			if(!SK_ZVUK_EN[a_ind . s_i1])lc640_write_int(ADR_SK_ZVUK_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_ZVUK_EN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_ZVUK_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==4) 
X	else if(a_ind . s_i==4) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_LCD_EN[sub_ind1])lc640_write_int(ADR_SK_LCD_EN[sub_ind1],0xffff);
X			if(!SK_LCD_EN[a_ind . s_i1])lc640_write_int(ADR_SK_LCD_EN[a_ind . s_i1],0xffff);
N			else lc640_write_int(ADR_SK_LCD_EN[sub_ind1],0);
X			else lc640_write_int(ADR_SK_LCD_EN[a_ind . s_i1],0);
N			}
N		}	
N	else if(sub_ind==5) 
X	else if(a_ind . s_i==5) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			}
N		}												
N	}	
N
Nelse if (ind==iExt_ddv)
Xelse if (a_ind . i==iExt_ddv)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)sub_ind=3;
X		if(a_ind . s_i==2)a_ind . s_i=3;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		if(sub_ind==1)index_set=0;
X		if(a_ind . s_i==1)a_ind . i_s=0;
N		else sub_ind--;
X		else a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		}	
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=7;
X		a_ind . s_i=7;
N		}			
N	else if(sub_ind==1) 
X	else if(a_ind . s_i==1) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_SIGN[0])lc640_write_int(ADR_SK_SIGN[0],0xffff);
N			else lc640_write_int(ADR_SK_SIGN[0],0);
N			}
N		}
N	else if(sub_ind==3) 
X	else if(a_ind . s_i==3) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(SK_REL_EN[0])lc640_write_int(ADR_SK_REL_EN[0],0);
N			else lc640_write_int(ADR_SK_REL_EN[0],0xffff);
N			}
N		}	
N
N	else if(sub_ind==4) 
X	else if(a_ind . s_i==4) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(SK_LCD_EN[0])lc640_write_int(ADR_SK_LCD_EN[0],0);
N			else lc640_write_int(ADR_SK_LCD_EN[0],0xffff);
N			}
N		}	
N	else if(sub_ind==5) 
X	else if(a_ind . s_i==5) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			}
N		}												
N	}	
N
Nelse if (ind==iExt_ddi)
Xelse if (a_ind . i==iExt_ddi)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)sub_ind=3;
X		if(a_ind . s_i==2)a_ind . s_i=3;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		if(sub_ind==1)index_set=0;
X		if(a_ind . s_i==1)a_ind . i_s=0;
N		else sub_ind--;
X		else a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		}	
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=7;
X		a_ind . s_i=7;
N		}			
N	else if(sub_ind==1) 
X	else if(a_ind . s_i==1) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_SIGN[1])lc640_write_int(ADR_SK_SIGN[1],0xffff);
N			else lc640_write_int(ADR_SK_SIGN[1],0);
N			}
N		}
N	else if(sub_ind==3) 
X	else if(a_ind . s_i==3) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(SK_REL_EN[1])lc640_write_int(ADR_SK_REL_EN[1],0);
N			else lc640_write_int(ADR_SK_REL_EN[1],0xffff);
N			}
N		}	
N	else if(sub_ind==4) 
X	else if(a_ind . s_i==4) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(SK_LCD_EN[1])lc640_write_int(ADR_SK_LCD_EN[1],0);
N			else lc640_write_int(ADR_SK_LCD_EN[1],0xffff);
N			}
N		}	
N	else if(sub_ind==5) 
X	else if(a_ind . s_i==5) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			}
N		}												
N	}
N 
N else if (ind==iExt_dud)
X else if (a_ind . i==iExt_dud)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)sub_ind=3;
X		if(a_ind . s_i==2)a_ind . s_i=3;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		if(sub_ind==1)index_set=0;
X		if(a_ind . s_i==1)a_ind . i_s=0;
N		else sub_ind--;
X		else a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		gran_char(&sub_ind,1,5);
X		gran_char(&a_ind . s_i,1,5);
N		}	
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=7;
X		a_ind . s_i=7;
N		}			
N	else if(sub_ind==1) 
X	else if(a_ind . s_i==1) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(!SK_SIGN[2])lc640_write_int(ADR_SK_SIGN[2],0xffff);
N			else lc640_write_int(ADR_SK_SIGN[2],0);
N			}
N		}
N	else if(sub_ind==3) 
X	else if(a_ind . s_i==3) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(SK_REL_EN[2])lc640_write_int(ADR_SK_REL_EN[2],0);
N			else lc640_write_int(ADR_SK_REL_EN[2],0xffff);
N			}
N		}	
N	else if(sub_ind==4) 
X	else if(a_ind . s_i==4) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(SK_LCD_EN[2])lc640_write_int(ADR_SK_LCD_EN[2],0);
N			else lc640_write_int(ADR_SK_LCD_EN[2],0xffff);
N			}
N		}	
N	else if(sub_ind==5) 
X	else if(a_ind . s_i==5) 
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			}
N		}												
N	}
N/*     
Nelse if (ind==iExt_dp)
N	{
N	ret(1000);
N	if(but==butD)
N		{
N		sub_ind++;
N		if(sub_ind==2)sub_ind=3;
N		gran_char(&sub_ind,1,5);
N		
N		}
N	else if(but==butU)
N		{
N		if(sub_ind==1)index_set=0;
N		else sub_ind--;
N		if(sub_ind==2)sub_ind=1;
N		gran_char(&sub_ind,1,5);
N		}	
N	else if(but==butD_)
N		{
N		sub_ind=7;
N		}			
N	else if(sub_ind==1) 
N		{
N		if(but==butE)
N			{
N			if(!SK_SIGN[3])lc640_write_int(ADR_SK_SIGN[3],0xffff);
N			else lc640_write_int(ADR_SK_SIGN[3],0);
N			}
N		}
N	else if(sub_ind==3) 
N		{
N		if(but==butE)
N			{
N			if(!SK_REL_EN[3])lc640_write_int(ADR_SK_REL_EN[3],0xffff);
N			else lc640_write_int(ADR_SK_REL_EN[3],0);
N			}
N		}	
N	else if(sub_ind==4) 
N		{
N		if(but==butE)
N			{
N			if(!SK_LCD_EN[3])lc640_write_int(ADR_SK_LCD_EN[3],0xffff);
N			else lc640_write_int(ADR_SK_LCD_EN[3],0);
N			}
N		}	
N	else if(sub_ind==5) 
N		{
N		if(but==butE)
N			{
N			tree_down(0,0);
N			}
N		}												
N	}         	
N*/		     
Nelse if(ind==iK)
Xelse if(a_ind . i==iK)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2);
X		gran_char(&a_ind . s_i,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2);
X		gran_char(&a_ind . s_i,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2;
X		a_ind . s_i=2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2;
N		}				
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			tree_up(iK_net,0,0,0);	
N			ret(1000);		
N			}
N		else if((NUMBAT)&&(sub_ind==1))
X		else if((NUMBAT)&&(a_ind . s_i==1))
N			{
N			tree_up(iK_bat_sel,0,0,0);	
N			ret(1000);
N			}
N		else if((NUMIST)&&(sub_ind==(1+(NUMBAT!=0))))
X		else if((NUMIST)&&(a_ind . s_i==(1+(NUMBAT!=0))))
N			{
N			tree_up(iK_bps_sel,0,0,0);	
N			ret(1000);
N			}
N/*		else if((sub_ind==(1+(NUMBAT!=0)+(NUMIST!=0))))
N			{
N			tree_up(iK_load,0,0,0);	
N			ret(1000);
N			}
N          
N         	else if(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0)))
N			{
N			tree_up(iK_t_ext,0,0,0);	
N			ret(1000);			
N			}
N          else if(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0)+1))
N			{
N			tree_up(iK_power_net3,0,0,0);	
N			ret(1000);
N               }               				
N          else if(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0)+2))
N			{
N	          tree_down(0,0);
N	          ret(0);
N               }	               			
N		}*/
N/**/		else if((NUMINV)&&(sub_ind==(1+(NUMBAT!=0)+(NUMIST!=0))))
X 		else if((NUMINV)&&(a_ind . s_i==(1+(NUMBAT!=0)+(NUMIST!=0))))
N			{
N			//tree_up(iK_inv_sel,0,0,0);	
N			ret(1000);
N			}
N								
N			else if((sub_ind==(1+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0))))		 /**/
X			else if((a_ind . s_i==(1+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0))))		  
N			{
N			tree_up(iK_load,0,0,0);	
N			ret(1000);
N			}
N          
N/**/     	else if(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)))	   /**/
X      	else if(a_ind . s_i==(2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)))	    
N			{
N			tree_up(iK_t_ext,0,0,0);	
N			ret(1000);			
N			}
N/**/		else if(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+1))		/**/
X 		else if(a_ind . s_i==(2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+1))		 
N			{
N			tree_up(iK_power_net3,0,0,0);	
N			ret(1000);
N               }               				
N/**/	   	else if(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2))	   /**/
X 	   	else if(a_ind . s_i==(2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+2))	    
N			{
N	          tree_down(0,0);
N	          ret(0);
N               }	               			
N		}					
N	}
N
Nelse if(ind==iK_VD)
Xelse if(a_ind . i==iK_VD)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4+(NUMIST!=0));
X		gran_char(&a_ind . s_i,0,4+(NUMIST!=0));
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4+(NUMIST!=0));
X		gran_char(&a_ind . s_i,0,4+(NUMIST!=0));
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=4+(NUMIST!=0);
X		a_ind . s_i=4+(NUMIST!=0);
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KUOUT);
X		temp_SS=lc640_read_int(0x10+52);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	    gran(&temp_SS,50,2000);
N
N		lc640_write_int(EE_KUOUT,temp_SS);					
X		lc640_write_int(0x10+52,temp_SS);					
N		speed=1;	
N					
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(ADR_KI1BAT[0]);
N		if(but==butR)temp_SS++;
X		if(but==239)temp_SS++;
N		else if(but==butR_)temp_SS+=2;
X		else if(but==111)temp_SS+=2;
N		else if(but==butL)temp_SS--;
X		else if(but==247)temp_SS--;
N		else if(but==butL_)temp_SS-=2;
X		else if(but==119)temp_SS-=2;
N						
N		gran(&temp_SS,200,30000);
N		lc640_write_int(ADR_KI1BAT[0],temp_SS);
N		phase=1;
N		speed=1;
N		}
N
N	else if((NUMIST)&&(sub_ind==2))
X	else if((NUMIST)&&(a_ind . s_i==2))
N		{
N		tree_up(iK_bps_sel,0,0,0);	
N		ret(1000);
N		}
N	else if(sub_ind==(2+(NUMIST!=0)))
X	else if(a_ind . s_i==(2+(NUMIST!=0)))
N		{
N		temp_SS=lc640_read_int(EE_KUVD);
X		temp_SS=lc640_read_int(0x10+54);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	    gran(&temp_SS,30,2000);
N
N		lc640_write_int(EE_KUVD,temp_SS);					
X		lc640_write_int(0x10+54,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==(3+(NUMIST!=0)))
X	else if(a_ind . s_i==(3+(NUMIST!=0)))
N		{
N		temp_SS=lc640_read_int(KT_EXT0);
X		temp_SS=lc640_read_int(0x10+100+50);
N	    if(but==butR)
X	    if(but==239)
N	    	{
N		    temp_SS++;
N	     	}
N	    else if(but==butR_)
X	    else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	    else if(but==butL)
X	    else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	    else if(but==butL_)
X	    else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	    gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT0,temp_SS);					
X		lc640_write_int(0x10+100+50,temp_SS);					
N		speed=1;	
N		}			
N   	else if(sub_ind==(4+(NUMIST!=0)))	  
X   	else if(a_ind . s_i==(4+(NUMIST!=0)))	  
N		{
N	    tree_down(0,0);
N	    ret(0);
N        }
N	}
N
N
Nelse if(ind==iK_220_IPS_TERMOKOMPENSAT)
Xelse if(a_ind . i==iK_220_IPS_TERMOKOMPENSAT)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+(NUMDT!=0));
X		gran_char(&a_ind . s_i,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+(NUMDT!=0));
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+(NUMDT!=0));
X		gran_char(&a_ind . s_i,0,2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+(NUMDT!=0));
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+(NUMDT!=0);
X		a_ind . s_i=2+(NUMBAT!=0)+(NUMIST!=0)+(NUMINV!=0)+(NUMDT!=0);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			if((AUSW_MAIN==22033)||(AUSW_MAIN==22018))
N				{
N				tree_up(iK_net3,0,0,0);
N		     	ret(1000);
N				}
N			else
N				{
N				tree_up(iK_net,0,0,0);	
N				ret(1000);		
N				}
N			}
N		else if((NUMBAT)&&(sub_ind==1))
X		else if((NUMBAT)&&(a_ind . s_i==1))
N			{
N			tree_up(iK_bat_sel,0,0,0);	
N			ret(1000);
N			}
N		else if((NUMIST)&&(sub_ind==(1+(NUMBAT!=0))))
X		else if((NUMIST)&&(a_ind . s_i==(1+(NUMBAT!=0))))
N			{
N			tree_up(iK_bps_sel,0,0,0);	
N			ret(1000);
N			}
N
N		else if((sub_ind==(1+(NUMBAT!=0)+(NUMIST!=0))))
X		else if((a_ind . s_i==(1+(NUMBAT!=0)+(NUMIST!=0))))
N			{
N			tree_up(iK_out,0,0,0);	
N			ret(1000);
N			}
N          
N         	else if((NUMDT)&&(sub_ind==(2+(NUMBAT!=0)+(NUMIST!=0))))
X         	else if((NUMDT)&&(a_ind . s_i==(2+(NUMBAT!=0)+(NUMIST!=0))))
N			{
N			tree_up(iK_t_ext_6U,0,0,0);	
N			ret(1000);			
N			}
N 						
N          else if(sub_ind==(3+(NUMBAT!=0)+(NUMIST!=0)/*+(NUMINV!=0)*/))
X          else if(a_ind . s_i==(3+(NUMBAT!=0)+(NUMIST!=0) ))
N			{
N	          tree_down(0,0);
N	          ret(0);
N               }	               			
N		}			
N	}
N
Nelse if(ind==iK_220_IPS_TERMOKOMPENSAT_IB)
Xelse if(a_ind . i==iK_220_IPS_TERMOKOMPENSAT_IB)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3+(NUMIST!=0)+(NUMDT!=0));
X		gran_char(&a_ind . s_i,0,3+(NUMIST!=0)+(NUMDT!=0));
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3+(NUMIST!=0)+(NUMDT!=0));
X		gran_char(&a_ind . s_i,0,3+(NUMIST!=0)+(NUMDT!=0));
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3+(NUMIST!=0)+(NUMDT!=0);
X		a_ind . s_i=3+(NUMIST!=0)+(NUMDT!=0);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			if((AUSW_MAIN==22063)||(AUSW_MAIN==22023)||(AUSW_MAIN==22043)||(AUSW_MAIN==22018))
N				{
N				tree_up(iK_net3,0,0,0);
N		     	ret(1000);
N				}
N			else
N				{
N				tree_up(iK_net,0,0,0);	
N				ret(1000);		
N				}
N			}
N		else if(sub_ind==1)
X		else if(a_ind . s_i==1)
N			{
N			tree_up(iK_bat_ips_termokompensat_ib,0,0,0);	
N			ret(1000);
N			}
N		else if((NUMIST)&&(sub_ind==2))
X		else if((NUMIST)&&(a_ind . s_i==2))
N			{
N			tree_up(iK_bps_sel,0,0,0);	
N			ret(1000);
N			}
N
N		else if((sub_ind==(2+(NUMIST!=0))))
X		else if((a_ind . s_i==(2+(NUMIST!=0))))
N			{
N			tree_up(iK_out,0,0,0);	
N			ret(1000);
N			}
N          
N         	else if((NUMDT)&&(sub_ind==(3+(NUMIST!=0))))
X         	else if((NUMDT)&&(a_ind . s_i==(3+(NUMIST!=0))))
N			{
N			tree_up(iK_t_ext_6U,0,0,0);	
N			ret(1000);			
N			}
N 						
N          else if(sub_ind==(3+(NUMIST!=0)+(NUMDT!=0)))
X          else if(a_ind . s_i==(3+(NUMIST!=0)+(NUMDT!=0)))
N			{
N	          tree_down(0,0);
N	          ret(0);
N               }	               			
N		}			
N	}
N
Nelse if(ind==iK_TELECORE)
Xelse if(a_ind . i==iK_TELECORE)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0));
X		gran_char(&a_ind . s_i,0,2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0));
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0));
X		gran_char(&a_ind . s_i,0,2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0));
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0);
X		a_ind . s_i=2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0);
N		}				
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==0)
X		if(a_ind . s_i==0)
N			{
N			tree_up(iK_net,0,0,0);
N		    ret(1000);
N			}
N		else if((NUMBAT_TELECORE)&&(sub_ind==1))
X		else if((NUMBAT_TELECORE)&&(a_ind . s_i==1))
N			{
N			tree_up(iK_bat_sel_TELECORE,0,0,0);	
N			ret(1000);
N			}
N		else if((NUMIST)&&(sub_ind==(1+(NUMBAT_TELECORE!=0))))
X		else if((NUMIST)&&(a_ind . s_i==(1+(NUMBAT_TELECORE!=0))))
N			{
N			tree_up(iK_bps_sel,0,0,0);	
N			ret(1000);
N			}
N
N		else if((sub_ind==(1+(NUMBAT_TELECORE!=0)+(NUMIST!=0))))
X		else if((a_ind . s_i==(1+(NUMBAT_TELECORE!=0)+(NUMIST!=0))))
N			{
N			tree_up(iK_load,0,0,0);	
N			ret(1000);
N			}
N          
N    	else if((NUMDT)&&(sub_ind==(2+(NUMBAT_TELECORE!=0)+(NUMIST!=0))))
X    	else if((NUMDT)&&(a_ind . s_i==(2+(NUMBAT_TELECORE!=0)+(NUMIST!=0))))
N			{
N			tree_up(iK_t_ext_6U,0,0,0);	
N			ret(1000);			
N			}
N    	else if(sub_ind==(2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0)))
X    	else if(a_ind . s_i==(2+(NUMBAT_TELECORE!=0)+(NUMIST!=0)+(NUMDT!=0)))
N			{
N	     	tree_down(0,0);
N	        ret(0);
N            }	               			
N		}			
N	}
N
Nelse if(ind==iK_net)
Xelse if(a_ind . i==iK_net)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,1);
X		gran_char(&a_ind . s_i,0,1);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,1);
X		gran_char(&a_ind . s_i,0,1);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=1;
X		a_ind . s_i=1;
N		}				
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KUNET);
X		temp_SS=lc640_read_int(0x10+16);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			//temp_SS=lc640_read_int(EE_KUNET);
N			temp_SS+=10;
N			//lc640_write_int(EE_KUNET,temp_SS);
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			//temp_SS=lc640_read_int(EE_KUNET);
N			temp_SS--;
N			//lc640_write_int(EE_KUNET,temp_SS);
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			//temp_SS=lc640_read_int(EE_KUNET);
N			temp_SS-=10;
N			//lc640_write_int(EE_KUNET,temp_SS);
N			}				
N		speed=1;
N		gran(&temp_SS,10,12000);
N		lc640_write_int(EE_KUNET,temp_SS);
X		lc640_write_int(0x10+16,temp_SS);
N					
N		}
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_net3)
Xelse if(a_ind . i==iK_net3)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}				
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KUNETA);
X		temp_SS=lc640_read_int(0x10+44);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,150,4000);
N		lc640_write_int(EE_KUNETA,temp_SS);
X		lc640_write_int(0x10+44,temp_SS);
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(EE_KUNETB);
X		temp_SS=lc640_read_int(0x10+46);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,150,4000);
N		lc640_write_int(EE_KUNETB,temp_SS);
X		lc640_write_int(0x10+46,temp_SS);
N		}
N
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		temp_SS=lc640_read_int(EE_KUNETC);
X		temp_SS=lc640_read_int(0x10+48);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,150,4000);
N		lc640_write_int(EE_KUNETC,temp_SS);
X		lc640_write_int(0x10+48,temp_SS);
N		}
N
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_power_net)
Xelse if(a_ind . i==iK_power_net)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}				
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KUNET_EXT0);
X		temp_SS=lc640_read_int(0x10+22);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KUNET_EXT0,temp_SS);
X		lc640_write_int(0x10+22,temp_SS);
N					
N		}
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(EE_KUNET_EXT1);
X		temp_SS=lc640_read_int(0x10+24);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KUNET_EXT1,temp_SS);
X		lc640_write_int(0x10+24,temp_SS);
N					
N		}
N
N
N
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_power_net3)
Xelse if(a_ind . i==iK_power_net3)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,6);
X		gran_char(&a_ind . s_i,0,6);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,6);
X		gran_char(&a_ind . s_i,0,6);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=6;
X		a_ind . s_i=6;
N		}
N						
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KVV0_EB2);
X		temp_SS=lc640_read_int(0x10+32);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KVV0_EB2,temp_SS);
X		lc640_write_int(0x10+32,temp_SS);
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(EE_KVV1_EB2);
X		temp_SS=lc640_read_int(0x10+34);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KVV1_EB2,temp_SS);
X		lc640_write_int(0x10+34,temp_SS);
N		}
N
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		temp_SS=lc640_read_int(EE_KVV2_EB2);
X		temp_SS=lc640_read_int(0x10+36);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KVV2_EB2,temp_SS);
X		lc640_write_int(0x10+36,temp_SS);
N		}
N
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		temp_SS=lc640_read_int(EE_KPES0_EB2);
X		temp_SS=lc640_read_int(0x10+38);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KPES0_EB2,temp_SS);
X		lc640_write_int(0x10+38,temp_SS);
N		}
N
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N		temp_SS=lc640_read_int(EE_KPES1_EB2);
X		temp_SS=lc640_read_int(0x10+40);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KPES1_EB2,temp_SS);
X		lc640_write_int(0x10+40,temp_SS);
N		}
N
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N		{
N		temp_SS=lc640_read_int(EE_KPES2_EB2);
X		temp_SS=lc640_read_int(0x10+42);
N		if(but==butR)
X		if(but==239)
N			{
N			temp_SS++;
N			}
N		else if(but==butR_)
X		else if(but==111)
N			{
N			temp_SS+=10;
N			}	
N		else if(but==butL)
X		else if(but==247)
N			{
N			temp_SS--;
N			}
N		else if(but==butL_)
X		else if(but==119)
N			{
N			temp_SS-=10;
N			}				
N		speed=1;
N		gran(&temp_SS,200,550);
N		lc640_write_int(EE_KPES2_EB2,temp_SS);
X		lc640_write_int(0x10+42,temp_SS);
N		}
N
N
N
N
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_bat_sel)
Xelse if(a_ind . i==iK_bat_sel)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMBAT);
X		gran_char(&a_ind . s_i,0,NUMBAT);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMBAT);
X		gran_char(&a_ind . s_i,0,NUMBAT);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=1+NUMBAT;
X		a_ind . s_i=1+NUMBAT;
N		}	
N	else if((but==butE)&&(NUMBAT)&&(BAT_IS_ON[0]==bisON)&&(sub_ind==0))
X	else if((but==254)&&(NUMBAT)&&(BAT_IS_ON[0]==bisON)&&(a_ind . s_i==0))
N		{
N		#ifdef UKU_6U
S		tree_up(iK_bat_simple,0,0,0);
N		#else
N
N		#ifdef UKU_220_V2
S		tree_up(iK_bat_simple,0,0,0);
N		#else
N		
N	/*	#ifdef UKU_220 
N		tree_up(iK_bat_simple,0,0,0);
N		#else*/
N		//tree_up(iK_bat,0,0,0);	
N		#endif
N		#endif
N		//mess_send(MESS_SRC_CONTROL,0xFFFF,0,10);
N     	//mess_send(MESS_BAT_CONTROL,0xFFFF&(~(1<<sub_ind1)),1<<(sub_ind1),10);
N
N		ret(1000);
N		}	
N	else if((but==butE)&&(NUMBAT)&&(BAT_IS_ON[1]==bisON)&&(sub_ind==((BAT_IS_ON[0]==bisON))))
X	else if((but==254)&&(NUMBAT)&&(BAT_IS_ON[1]==bisON)&&(a_ind . s_i==((BAT_IS_ON[0]==bisON))))
N		{
N
N		
N		//mess_send(MESS_SRC_CONTROL,0xFFFF,0,10);
N     	//mess_send(MESS_BAT_CONTROL,0xFFFF&(~(1<<sub_ind1)),1<<(sub_ind1),10);
N     		
N		ret(1000);
N		}	
N	else if(sub_ind==(NUMBAT))
X	else if(a_ind . s_i==(NUMBAT))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}				
N	}
N
Nelse if(ind==iK_bat_sel_TELECORE)
Xelse if(a_ind . i==iK_bat_sel_TELECORE)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMBAT_TELECORE);
X		gran_char(&a_ind . s_i,0,NUMBAT_TELECORE);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMBAT_TELECORE);
X		gran_char(&a_ind . s_i,0,NUMBAT_TELECORE);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=1+NUMBAT_TELECORE;
X		a_ind . s_i=1+NUMBAT_TELECORE;
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if((but==butE)&&(NUMBAT_TELECORE>0))
X		if((but==254)&&(NUMBAT_TELECORE>0))
N			{
N			tree_up(iK_bat_TELECORE,0,0,0);	
N			ret(1000);
N			}
N		}	
N	else if((sub_ind==1)&&(NUMBAT_TELECORE>1))
X	else if((a_ind . s_i==1)&&(NUMBAT_TELECORE>1))
N		{
N		if((but==butE)&&(NUMBAT_TELECORE>1))
X		if((but==254)&&(NUMBAT_TELECORE>1))
N			{
N			tree_up(iK_bat_TELECORE,0,0,1);	
N			ret(1000);
N			}
N		}
N	else if(sub_ind==(NUMBAT_TELECORE))
X	else if(a_ind . s_i==(NUMBAT_TELECORE))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}				
N	}
N
Nelse if(ind==iK_bat_TELECORE)
Xelse if(a_ind . i==iK_bat_TELECORE)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if((sub_ind==1)||(sub_ind==2))sub_ind=3;
X		if((a_ind . s_i==1)||(a_ind . s_i==2))a_ind . s_i=3;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if((sub_ind==1)||(sub_ind==2)) sub_ind=0;
X		if((a_ind . s_i==1)||(a_ind . s_i==2)) a_ind . s_i=0;
N        gran_char(&sub_ind,0,3);
X        gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}			
N					
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if(but==butE)
X		if(but==254)
N		     {
N		     if(phase==0)
N		          {
N		          lc640_write_int(ADR_KI0BAT[sub_ind1],ad7705_buff_[sub_ind1]);
X		          lc640_write_int(ADR_KI0BAT[a_ind . s_i1],ad7705_buff_[a_ind . s_i1]);
N		          phase=1;
N		          }
N		     }	
N		else
N			{
N			temp_SS=lc640_read_int(ADR_KI1BAT[sub_ind1]);
X			temp_SS=lc640_read_int(ADR_KI1BAT[a_ind . s_i1]);
N			if(but==butR)temp_SS++;
X			if(but==239)temp_SS++;
N			else if(but==butR_)temp_SS+=2;
X			else if(but==111)temp_SS+=2;
N			else if(but==butL)temp_SS--;
X			else if(but==247)temp_SS--;
N			else if(but==butL_)temp_SS-=2;
X			else if(but==119)temp_SS-=2;
N						
N			gran(&temp_SS,20,4000);
N			lc640_write_int(ADR_KI1BAT[sub_ind1],temp_SS);
X			lc640_write_int(ADR_KI1BAT[a_ind . s_i1],temp_SS);
N			phase=1;
N			}
N				
N		speed=1;			
N		}					
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}	
N
Nelse if(ind==iK_bat_ips_termokompensat_ib)
Xelse if(a_ind . i==iK_bat_ips_termokompensat_ib)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if((sub_ind==1)||(sub_ind==2))sub_ind=3;
X		if((a_ind . s_i==1)||(a_ind . s_i==2))a_ind . s_i=3;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if((sub_ind==1)||(sub_ind==2)) sub_ind=0;
X		if((a_ind . s_i==1)||(a_ind . s_i==2)) a_ind . s_i=0;
N          gran_char(&sub_ind,0,3);
X          gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}			
N					
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(ADR_KI1BAT[0]);
N		if(but==butR)temp_SS++;
X		if(but==239)temp_SS++;
N		else if(but==butR_)temp_SS+=2;
X		else if(but==111)temp_SS+=2;
N		else if(but==butL)temp_SS--;
X		else if(but==247)temp_SS--;
N		else if(but==butL_)temp_SS-=2;
X		else if(but==119)temp_SS-=2;
N						
N		gran(&temp_SS,200,30000);
N		lc640_write_int(ADR_KI1BAT[0],temp_SS);
N		phase=1;
N		speed=1;
N		}
N									 	
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}		
N
Nelse if(ind==iK_bps_sel)
Xelse if(a_ind . i==iK_bps_sel)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMIST);
X		gran_char(&a_ind . s_i,0,NUMIST);
N		phase=0;
N		can1_out(sub_ind,sub_ind,CMND,ALRM_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i,a_ind . s_i,0x16,0x63,0,0,0,0);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMIST);
X		gran_char(&a_ind . s_i,0,NUMIST);
N		phase=0;
N		can1_out(sub_ind,sub_ind,CMND,ALRM_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i,a_ind . s_i,0x16,0x63,0,0,0,0);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=1+NUMIST;
X		a_ind . s_i=1+NUMIST;
N		}	
N	else if((but==butE)&&(NUMIST)&&(sub_ind<NUMIST))
X	else if((but==254)&&(NUMIST)&&(a_ind . s_i<NUMIST))
N		{
N		tree_up(iK_bps,0,0,sub_ind);	
X		tree_up(iK_bps,0,0,a_ind . s_i);	
N		
N		can1_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0x16,0x63,0,0,0,0);
N		//mess_send(MESS_SRC_CONTROL,0xFFFF,0,10);
N     	//mess_send(MESS_BAT_CONTROL,0xFFFF&(~(1<<sub_ind1)),1<<(sub_ind1),10);
N
N		ret(1000);
N		}	
N	else if(sub_ind==(NUMIST))
X	else if(a_ind . s_i==(NUMIST))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}				
N	}
N
Nelse if(ind==iK_bps)
Xelse if(a_ind . i==iK_bps)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if((sub_ind==1)||(sub_ind==2))sub_ind=3;
X		if((a_ind . s_i==1)||(a_ind . s_i==2))a_ind . s_i=3;
N		else if((sub_ind==4)||(sub_ind==5))sub_ind=9;
X		else if((a_ind . s_i==4)||(a_ind . s_i==5))a_ind . s_i=9;
N		else if((sub_ind==7)||(sub_ind==8))sub_ind=9;
X		else if((a_ind . s_i==7)||(a_ind . s_i==8))a_ind . s_i=9;
N		else if((sub_ind==10)||(sub_ind==11))sub_ind=12;
X		else if((a_ind . s_i==10)||(a_ind . s_i==11))a_ind . s_i=12;
N		else if((sub_ind==13)||(sub_ind==14))sub_ind=15;
X		else if((a_ind . s_i==13)||(a_ind . s_i==14))a_ind . s_i=15;
N		else if((sub_ind==16)||(sub_ind==17))sub_ind=18;
X		else if((a_ind . s_i==16)||(a_ind . s_i==17))a_ind . s_i=18;
N		gran_char(&sub_ind,0,18);
X		gran_char(&a_ind . s_i,0,18);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if((sub_ind==1)||(sub_ind==2))sub_ind=0;
X		if((a_ind . s_i==1)||(a_ind . s_i==2))a_ind . s_i=0;
N		else if((sub_ind==4)||(sub_ind==5))sub_ind=3;
X		else if((a_ind . s_i==4)||(a_ind . s_i==5))a_ind . s_i=3;
N		else if((sub_ind==7)||(sub_ind==8))sub_ind=3;
X		else if((a_ind . s_i==7)||(a_ind . s_i==8))a_ind . s_i=3;
N		else if((sub_ind==10)||(sub_ind==11))sub_ind=9;
X		else if((a_ind . s_i==10)||(a_ind . s_i==11))a_ind . s_i=9;
N		else if((sub_ind==13)||(sub_ind==14))sub_ind=12;
X		else if((a_ind . s_i==13)||(a_ind . s_i==14))a_ind . s_i=12;
N		else if((sub_ind==16)||(sub_ind==17))sub_ind=15;		
X		else if((a_ind . s_i==16)||(a_ind . s_i==17))a_ind . s_i=15;		
N		gran_char(&sub_ind,0,18);
X		gran_char(&a_ind . s_i,0,18);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=18;
X		a_ind . s_i=18;
N		}
N	else if (sub_ind == 0)
X	else if (a_ind . s_i == 0)
N		{
N		if(but==butLR) can1_out(sub_ind1,sub_ind1,KLBR,(0*16)+1,(0*16)+1,0,0,0);
X		if(but==231) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(0*16)+1,(0*16)+1,0,0,0);
N	    else if(but==butR) can1_out(sub_ind1,sub_ind1,KLBR,(0*16)+2,(0*16)+2,0,0,0);
X	    else if(but==239) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(0*16)+2,(0*16)+2,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1,sub_ind1,KLBR,(0*16)+3,(0*16)+3,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(0*16)+3,(0*16)+3,0,0,0);
N    	else if(but==butL) can1_out(sub_ind1,sub_ind1,KLBR,(0*16)+4,(0*16)+4,0,0,0); 
X    	else if(but==247) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(0*16)+4,(0*16)+4,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1,sub_ind1,KLBR,(0*16)+5,(0*16)+5,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(0*16)+5,(0*16)+5,0,0,0);
N		speed=1;
N		}	
N		
N	else if (sub_ind == 3)
X	else if (a_ind . s_i == 3)
N		{
N		if(but==butLR) can1_out(sub_ind1,sub_ind1,KLBR,(1*16)+1,(1*16)+1,0,0,0);
X		if(but==231) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(1*16)+1,(1*16)+1,0,0,0);
N	    else if(but==butR) can1_out(sub_ind1,sub_ind1,KLBR,(1*16)+2,(1*16)+2,0,0,0);
X	    else if(but==239) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(1*16)+2,(1*16)+2,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1,sub_ind1,KLBR,(1*16)+3,(1*16)+3,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(1*16)+3,(1*16)+3,0,0,0);
N    	else if(but==butL) can1_out(sub_ind1,sub_ind1,KLBR,(1*16)+4,(1*16)+4,0,0,0); 
X    	else if(but==247) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(1*16)+4,(1*16)+4,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1,sub_ind1,KLBR,(1*16)+5,(1*16)+5,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(1*16)+5,(1*16)+5,0,0,0);
N		speed=1;
N		}		
N		
N/*	else if (sub_ind == 6)
N		{
N		temp_SS=lc640_read_int(EE_U_AVT);
N		if(but==butR)temp_SS++;
N		else if(but==butR_)temp_SS+=2;
N		else if(but==butL)temp_SS--;
N		else if(but==butL_)temp_SS-=2;
N		else if(but==butE_)can1_out(sub_ind1,sub_ind1,CMND,0xee,0xee,0,0,0);   
N		
N
N		gran(&temp_SS,200,1800);
N	
N		lc640_write_int(EE_U_AVT,temp_SS);
N		
N		speed=1;
N		}*/	
N		
N	else if (sub_ind == 9)
X	else if (a_ind . s_i == 9)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			can1_out(sub_ind1,sub_ind1,KLBR,(2*16)+1,(2*16)+1,0,0,0);
X			mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(2*16)+1,(2*16)+1,0,0,0);
N			phase=1;
N			}
N	    else if(but==butR) can1_out(sub_ind1,sub_ind1,KLBR,(2*16)+2,(2*16)+2,0,0,0);
X	    else if(but==239) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(2*16)+2,(2*16)+2,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1,sub_ind1,KLBR,(2*16)+3,(2*16)+3,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(2*16)+3,(2*16)+3,0,0,0);
N    	else if(but==butL) can1_out(sub_ind1,sub_ind1,KLBR,(2*16)+4,(2*16)+4,0,0,0); 
X    	else if(but==247) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(2*16)+4,(2*16)+4,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1,sub_ind1,KLBR,(2*16)+5,(2*16)+5,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(2*16)+5,(2*16)+5,0,0,0);
N		speed=1;
N		}		
N		
N	else if (sub_ind == 12)
X	else if (a_ind . s_i == 12)
N		{
N		if(but==butR) can1_out(sub_ind1,sub_ind1,KLBR,(3*16)+2,(3*16)+2,0,0,0);
X		if(but==239) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(3*16)+2,(3*16)+2,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1,sub_ind1,KLBR,(3*16)+3,(3*16)+3,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(3*16)+3,(3*16)+3,0,0,0);
N    	else if(but==butL) can1_out(sub_ind1,sub_ind1,KLBR,(3*16)+4,(3*16)+4,0,0,0); 
X    	else if(but==247) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(3*16)+4,(3*16)+4,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1,sub_ind1,KLBR,(3*16)+5,(3*16)+5,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(3*16)+5,(3*16)+5,0,0,0);
N		speed=1;
N		}								
N
N	else if (sub_ind == 15)
X	else if (a_ind . s_i == 15)
N		{
N		if(but==butLR) can1_out(sub_ind1,sub_ind1,KLBR,(5*16)+1,(5*16)+1,0,0,0);
X		if(but==231) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(5*16)+1,(5*16)+1,0,0,0);
N	    else if(but==butR) can1_out(sub_ind1,sub_ind1,KLBR,(5*16)+2,(5*16)+2,0,0,0);
X	    else if(but==239) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(5*16)+2,(5*16)+2,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1,sub_ind1,KLBR,(5*16)+3,(5*16)+3,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(5*16)+3,(5*16)+3,0,0,0);
N    	else if(but==butL) can1_out(sub_ind1,sub_ind1,KLBR,(5*16)+4,(5*16)+4,0,0,0); 
X    	else if(but==247) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(5*16)+4,(5*16)+4,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1,sub_ind1,KLBR,(5*16)+5,(5*16)+5,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEE,(5*16)+5,(5*16)+5,0,0,0);
N		speed=1;
N		}
N	else if(sub_ind==18)
X	else if(a_ind . s_i==18)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}
N	}		
N
Nelse if(ind==iRele_set)
Xelse if(a_ind . i==iRele_set)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=4;
X		a_ind . s_i=4;
N		}	
N	else if((but==butE)&&(sub_ind>=0)&&(sub_ind<=3))
X	else if((but==254)&&(a_ind . s_i>=0)&&(a_ind . s_i<=3))
N		{
N		tree_up(iRele_set_,0,0,sub_ind);	
X		tree_up(iRele_set_,0,0,a_ind . s_i);	
N		
N		//can1_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
N		//mess_send(MESS_SRC_CONTROL,0xFFFF,0,10);
N     	//mess_send(MESS_BAT_CONTROL,0xFFFF&(~(1<<sub_ind1)),1<<(sub_ind1),10);
N
N		ret(1000);
N		}	
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}				
N	}
N
Nelse if(ind==iRele_set_)
Xelse if(a_ind . i==iRele_set_)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if(sub_ind==2)
X		if(a_ind . s_i==2)
N			{
N			sub_ind=3;
X			a_ind . s_i=3;
N			index_set=2;
X			a_ind . i_s=2;
N			}
N		else if(sub_ind==8)
X		else if(a_ind . s_i==8)
N			{
N			index_set=7;
X			a_ind . i_s=7;
N			}
N		else if(sub_ind==9)
X		else if(a_ind . s_i==9)
N			{
N			sub_ind=10;
X			a_ind . s_i=10;
N			}
N		gran_char(&sub_ind,0,11);
X		gran_char(&a_ind . s_i,0,11);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if(sub_ind==2)sub_ind=1;
X		if(a_ind . s_i==2)a_ind . s_i=1;
N		else if(sub_ind==9)sub_ind=8;
X		else if(a_ind . s_i==9)a_ind . s_i=8;
N		gran_char(&sub_ind,0,11);		
X		gran_char(&a_ind . s_i,0,11);		
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=11;
X		a_ind . s_i=11;
N		}
N	else if (sub_ind == 0)
X	else if (a_ind . s_i == 0)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<0);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<0);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<0);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<0);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<0);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<0);
N		}	
N		
N	else if (sub_ind == 1)
X	else if (a_ind . s_i == 1)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<1);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<1);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<1);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<1);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<1);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<1);
N		}	
N		
N	else if (sub_ind == 3)
X	else if (a_ind . s_i == 3)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<2);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<2);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<2);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<2);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<2);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<2);
N		}
N		
N	else if (sub_ind == 4)
X	else if (a_ind . s_i == 4)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<3);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<3);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<3);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<3);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<3);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<3);
N		}	
N		
N	else if (sub_ind == 5)
X	else if (a_ind . s_i == 5)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<4);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<4);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<4);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<4);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<4);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<4);
N		}							
N
N	else if (sub_ind == 6)
X	else if (a_ind . s_i == 6)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<5);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<5);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<5);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<5);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<5);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<5);
N		}
N	else if (sub_ind == 7)
X	else if (a_ind . s_i == 7)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<6);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<6);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<6);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<6);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<6);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<6);
N		}
N	else if (sub_ind == 8)
X	else if (a_ind . s_i == 8)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<7);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<7);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<7);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<7);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<7);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<7);
N		}
N
N	else if (sub_ind == 10)
X	else if (a_ind . s_i == 10)
N		{
N		if(but==butE) RELE_SET_MASK[sub_ind1]^=(1<<8);
X		if(but==254) RELE_SET_MASK[a_ind . s_i1]^=(1<<8);
N	    else if(but==butR) RELE_SET_MASK[sub_ind1]|=(1<<8);
X	    else if(but==239) RELE_SET_MASK[a_ind . s_i1]|=(1<<8);
N    	else if(but==butL) RELE_SET_MASK[sub_ind1]&=~(1<<8);
X    	else if(but==247) RELE_SET_MASK[a_ind . s_i1]&=~(1<<8);
N		}
N
N	else if(sub_ind==11)
X	else if(a_ind . s_i==11)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	//if(RELE_SET_MASK[sub_ind1]!=lc640_read_int(ADR_EE_RELE_SET_MASK[sub_ind1]))lc640_write_int(ADR_EE_RELE_SET_MASK[sub_ind1],RELE_SET_MASK[sub_ind1]);
N	if(RELE_SET_MASK[sub_ind1]!=lc640_read_int(ADR_EE_RELE_SET_MASK[sub_ind1]))lc640_write_int(ADR_EE_RELE_SET_MASK[sub_ind1],RELE_SET_MASK[sub_ind1]);
X	if(RELE_SET_MASK[a_ind . s_i1]!=lc640_read_int(ADR_EE_RELE_SET_MASK[a_ind . s_i1]))lc640_write_int(ADR_EE_RELE_SET_MASK[a_ind . s_i1],RELE_SET_MASK[a_ind . s_i1]);
N
N	}
N
Nelse if(ind==iInv_set)
Xelse if(a_ind . i==iInv_set)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		if(sub_ind==1)
X		if(a_ind . s_i==1)
N			{
N			sub_ind=2;
X			a_ind . s_i=2;
N			index_set=1;
X			a_ind . i_s=1;
N			}
N		if(sub_ind==3)
X		if(a_ind . s_i==3)
N			{
N			sub_ind=4;
X			a_ind . s_i=4;
N			index_set=2;
X			a_ind . i_s=2;
N			}
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,4);
X		gran_char(&a_ind . s_i,0,4);
N		if(sub_ind==1)sub_ind=0;
X		if(a_ind . s_i==1)a_ind . s_i=0;
N		if(sub_ind==3)
X		if(a_ind . s_i==3)
N			{
N			sub_ind=2;
X			a_ind . s_i=2;
N			index_set=2;
X			a_ind . i_s=2;
N			}
N		}
N	else if (sub_ind == 0)
X	else if (a_ind . s_i == 0)
N		{
N		if(but==butR) 		can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xa2/*(12*16)+2*/,0xa2/*(12*16)+2*/,0,0,0);
X		if(but==239) 		mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xa2 ,0xa2 ,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xa3/*(12*16)+3*/,0xa3/*(12*16)+3*/,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xa3 ,0xa3 ,0,0,0);
N    		else if(but==butL) 	can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xa4/*(12*16)+4*/,0xa4/*(12*16)+4*/,0,0,0); 
X    		else if(but==247) 	mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xa4 ,0xa4 ,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xa5/*(12*16)+5*/,0xa5/*(12*16)+5*/,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xa5 ,0xa5 ,0,0,0);
N		speed=1;
N		}
N	else if (sub_ind == 2)
X	else if (a_ind . s_i == 2)
N		{
N		if(but==butR) 		can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xb2/*(12*16)+2*/,0xb2/*(12*16)+2*/,0,0,0);
X		if(but==239) 		mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xb2 ,0xb2 ,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xb3/*(12*16)+3*/,0xb3/*(12*16)+3*/,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xb3 ,0xb3 ,0,0,0);
N    		else if(but==butL) 	can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xb4/*(12*16)+4*/,0xb4/*(12*16)+4*/,0,0,0); 
X    		else if(but==247) 	mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xb4 ,0xb4 ,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1+first_inv_slot,sub_ind1+first_inv_slot,KLBR,0xb5/*(12*16)+5*/,0xb5/*(12*16)+5*/,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1+first_inv_slot,a_ind . s_i1+first_inv_slot,0xEE,0xb5 ,0xb5 ,0,0,0);
N		speed=1;
N		}
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	}
N	
Nelse if(ind==iK_makb_sel)
Xelse if(a_ind . i==iK_makb_sel)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMMAKB);
X		gran_char(&a_ind . s_i,0,NUMMAKB);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMMAKB);
X		gran_char(&a_ind . s_i,0,NUMMAKB);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=NUMMAKB;
X		a_ind . s_i=NUMMAKB;
N		}	
N	else if((but==butE)&&(NUMMAKB)&&(sub_ind<NUMMAKB))
X	else if((but==254)&&(NUMMAKB)&&(a_ind . s_i<NUMMAKB))
N		{
N		if(makb[sub_ind]._cnt<5)
X		if(makb[a_ind . s_i]._cnt<5)
N			{
N			tree_up(iK_makb,0,0,sub_ind);
X			tree_up(iK_makb,0,0,a_ind . s_i);
N			ret(1000);
N			}
N		else show_mess(
N					"                    ",
N	          		"   НЕ ПОДКЛЮЧЕН!!!  ",
N	          		"                    ",
N	          		"                    ",1000);	
N		}	
N	else if(sub_ind==(NUMMAKB))
X	else if(a_ind . s_i==(NUMMAKB))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}				
N	}
N
Nelse if(ind==iK_makb)
Xelse if(a_ind . i==iK_makb)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		//if(sub_ind>7)sub_ind=7;
N		//else if(sub_ind==1)sub_ind=0;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		//if(sub_ind<3)sub_ind=3;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=10;
X		a_ind . s_i=10;
N		}
N	else if ((sub_ind >= 0) && (sub_ind <= 9))
X	else if ((a_ind . s_i >= 0) && (a_ind . s_i <= 9))
N		{
N		if(but==butLR) can1_out(sub_ind1,sub_ind1,KLBR_MAKB,		(sub_ind*16)+1,(sub_ind*16)+1,0,0,0);
X		if(but==231) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEF,		(a_ind . s_i*16)+1,(a_ind . s_i*16)+1,0,0,0);
N	     else if(but==butR) can1_out(sub_ind1,sub_ind1,KLBR_MAKB,	(sub_ind*16)+2,(sub_ind*16)+2,0,0,0);
X	     else if(but==239) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEF,	(a_ind . s_i*16)+2,(a_ind . s_i*16)+2,0,0,0);
N		else if(but==butR_)	can1_out(sub_ind1,sub_ind1,KLBR_MAKB,	(sub_ind*16)+3,(sub_ind*16)+3,0,0,0);
X		else if(but==111)	mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEF,	(a_ind . s_i*16)+3,(a_ind . s_i*16)+3,0,0,0);
N    		else if(but==butL) can1_out(sub_ind1,sub_ind1,KLBR_MAKB,	(sub_ind*16)+4,(sub_ind*16)+4,0,0,0); 
X    		else if(but==247) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEF,	(a_ind . s_i*16)+4,(a_ind . s_i*16)+4,0,0,0); 
N		else if(but==butL_) can1_out(sub_ind1,sub_ind1,KLBR_MAKB,	(sub_ind*16)+5,(sub_ind*16)+5,0,0,0);
X		else if(but==119) mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0xEF,	(a_ind . s_i*16)+5,(a_ind . s_i*16)+5,0,0,0);
N		speed=1;
N		}	
N		
N	else if(sub_ind==10)
X	else if(a_ind . s_i==10)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
N
N
N
Nelse if(ind==iK_load)
Xelse if(a_ind . i==iK_load)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind=1;
X		a_ind . s_i=1;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind=0;
X		a_ind . s_i=0;
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KULOAD);
X		temp_SS=lc640_read_int(0x10+20);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N		#ifdef UKU_220
S	    gran(&temp_SS,300,2000);
N		#else 
N		#ifdef UKU_220_IPS_TERMOKOMPENSAT
N	    gran(&temp_SS,50,2000);
N	    #else 
S		gran(&temp_SS,100,5000);
N		#endif
N		#endif
N		lc640_write_int(EE_KULOAD,temp_SS);					
X		lc640_write_int(0x10+20,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_out)
Xelse if(a_ind . i==iK_out)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(EE_KUBPS);
X		temp_SS=lc640_read_int(0x10+50);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	    gran(&temp_SS,50,2000);
N
N		lc640_write_int(EE_KUBPS,temp_SS);					
X		lc640_write_int(0x10+50,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(EE_KUOUT);
X		temp_SS=lc640_read_int(0x10+52);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	    gran(&temp_SS,50,2000);
N
N		lc640_write_int(EE_KUOUT,temp_SS);					
X		lc640_write_int(0x10+52,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_t_ext)
Xelse if(a_ind . i==iK_t_ext)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(KT_EXT0);
X		temp_SS=lc640_read_int(0x10+100+50);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	     gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT0,temp_SS);					
X		lc640_write_int(0x10+100+50,temp_SS);					
N		speed=1;	
N					
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(KT_EXT1);
X		temp_SS=lc640_read_int(0x10+100+52);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	     gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT1,temp_SS);					
X		lc640_write_int(0x10+100+52,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		temp_SS=lc640_read_int(KT_EXT2);
X		temp_SS=lc640_read_int(0x10+100+54);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	     gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT2,temp_SS);					
X		lc640_write_int(0x10+100+54,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N
Nelse if(ind==iK_t_ext_6U)
Xelse if(a_ind . i==iK_t_ext_6U)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMDT);
X		gran_char(&a_ind . s_i,0,NUMDT);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMDT);
X		gran_char(&a_ind . s_i,0,NUMDT);
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		temp_SS=lc640_read_int(KT_EXT0);
X		temp_SS=lc640_read_int(0x10+100+50);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	     gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT0,temp_SS);					
X		lc640_write_int(0x10+100+50,temp_SS);					
N		speed=1;	
N					
N		}
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		temp_SS=lc640_read_int(KT_EXT1);
X		temp_SS=lc640_read_int(0x10+100+52);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	     gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT1,temp_SS);					
X		lc640_write_int(0x10+100+52,temp_SS);					
N		speed=1;	
N					
N		}
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		temp_SS=lc640_read_int(KT_EXT2);
X		temp_SS=lc640_read_int(0x10+100+54);
N	     if(but==butR)
X	     if(but==239)
N	     	{
N		     temp_SS++;
N	     	}
N	     else if(but==butR_)
X	     else if(but==111)
N	     	{
N	     	temp_SS+=2;
N	     	}	
N	     else if(but==butL)
X	     else if(but==247)
N	     	{
N	     	temp_SS--;
N	     	}
N	     else if(but==butL_)
X	     else if(but==119)
N	     	{
N	     	temp_SS-=2;
N	     	}
N	     gran(&temp_SS,1900,3000);
N		lc640_write_int(KT_EXT2,temp_SS);					
X		lc640_write_int(0x10+100+54,temp_SS);					
N		speed=1;	
N					
N		}
N 	if(sub_ind==NUMDT)
X 	if(a_ind . s_i==NUMDT)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N	}
N			
Nelse if(ind==iBatLog)
Xelse if(a_ind . i==iBatLog)
N	{
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,6);
X		gran_char(&a_ind . s_i,0,6);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,6);
X		gran_char(&a_ind . s_i,0,6);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=6;
X		a_ind . s_i=6;
N		}				
N	else if((but==butL)&&((sub_ind==0)||(sub_ind==3)||(sub_ind==4)))
X	else if((but==247)&&((a_ind . s_i==0)||(a_ind . s_i==3)||(a_ind . s_i==4)))
N		{
N		tree_down(0,0);
N		}		
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N	          //b[ptr_ind++]=a;
N	          //if(BAT_IS_ON[sub_ind1]==bisON) ind=iPrl_bat_in_out;
N	          //else 
N	               //{
N	               //ind=iPdp1;
N	               //ret_ind(iPrl_bat_in_out,0,10);
N	               //}
N	          tree_up(iPrl_bat_in_out,0,0,sub_ind1);
X	          tree_up(iPrl_bat_in_out,0,0,a_ind . s_i1);
N	          if(BAT_IS_ON[sub_ind1]!=bisON) show_mess("  Введение батареи  ",
X	          if(BAT_IS_ON[a_ind . s_i1]!=bisON) show_mess("  Введение батареи  ",
N	          								 "    уничтожит все   ",
N	          								 "   предшествующие   ",
N	          								 "      данные!!!     ",4000);     
N	          parol_init();
N	          }
N	     }
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N	     {
N	     if(but==butR)BAT_C_NOM[sub_ind1]++;
X	     if(but==239)BAT_C_NOM[a_ind . s_i1]++;
N	     else if(but==butR_)BAT_C_NOM[sub_ind1]+=10;
X	     else if(but==111)BAT_C_NOM[a_ind . s_i1]+=10;
N	     else if(but==butL)BAT_C_NOM[sub_ind1]--;
X	     else if(but==247)BAT_C_NOM[a_ind . s_i1]--;
N	     else if(but==butL_)BAT_C_NOM[sub_ind1]-=10;
X	     else if(but==119)BAT_C_NOM[a_ind . s_i1]-=10;
N	     gran(&BAT_C_NOM[sub_ind1],0,2000);
X	     gran(&BAT_C_NOM[a_ind . s_i1],0,2000);
N	     lc640_write_int(ADR_EE_BAT_C_NOM[sub_ind1],BAT_C_NOM[sub_ind1]);
X	     lc640_write_int(ADR_EE_BAT_C_NOM[a_ind . s_i1],BAT_C_NOM[a_ind . s_i1]);
N	     speed=1;
N	     }		     
N		
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{ 
N               cap=0;
N			deep=lc640_read_int(CNT_EVENT_LOG);
X			deep=lc640_read_int(1024+1024+512+1024+2);
N			ptr=lc640_read_int(PTR_EVENT_LOG);
X			ptr=lc640_read_int(1024+1024+512+1024);
N			
N			if(deep>63)
N				{
N				deep=0;
N			     ptr=0;
N			     }
N			     			
N			for(i=0;i<deep;i++)
N				{
N				lc640_read_long_ptr(EVENT_LOG+(32*ptr),av_head);
X				lc640_read_long_ptr(1024+(32*ptr),av_head);
N				
N				if((av_head[0]=='B')&&(av_head[1]==sub_ind1)&&(av_head[2]=='K')) 	//ищем записи батарейных событий 'K'(контроли емкости)
X				if((av_head[0]=='B')&&(av_head[1]==a_ind . s_i1)&&(av_head[2]=='K')) 	
N					{
N					cap++;
N					content[cap-1]=ptr;
N					}
N					
N				ptr=ptr_carry(ptr,64,-1); 
N	
N				} 
N				
N			tree_up(iBatLogKe,0,0,sub_ind1);
X			tree_up(iBatLogKe,0,0,a_ind . s_i1);
N			
N			av_j_si_max=cap;
N			if(av_j_si_max>63)av_j_si_max=0;
N			} 
N		}
N
N
N
N
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N		if(but==butE)
X		if(but==254)
N			{ 
N               cap=0;
N			deep=lc640_read_int(CNT_EVENT_LOG);
X			deep=lc640_read_int(1024+1024+512+1024+2);
N			ptr=lc640_read_int(PTR_EVENT_LOG);
X			ptr=lc640_read_int(1024+1024+512+1024);
N			
N			if(deep>63)
N				{
N				deep=0;
N			     ptr=0;
N			     }
N			     
N			for(i=0;i<deep;i++)
N				{
N				lc640_read_long_ptr(EVENT_LOG+(32*ptr),av_head);
X				lc640_read_long_ptr(1024+(32*ptr),av_head);
N				
N				if((av_head[0]=='B')/*&&(av_head[1]==sub_ind1)*/&&(av_head[2]=='Z')) 	//ищем записи батарейных событий 'z'(выравнивающий заряд)
N					{
N					cap++;
N					content[cap-1]=ptr;
N					}
N					
N				ptr=ptr_carry(ptr,64,-1); 
N				} 
N				
N			tree_up(iBatLogVz,0,0,sub_ind1);   
X			tree_up(iBatLogVz,0,0,a_ind . s_i1);   
N			
N			av_j_si_max=cap;
N			if(av_j_si_max>63)av_j_si_max=0;
N			} 
N		else if(but==butR)
X		else if(but==239)
N			{
N			//vz_mem_hndl(0,5);
N			//vz_mem_hndl(1,6);	       
N			} 
N		}
N
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N		{
N		if(but==butE)
X		if(but==254)
N			{ 
N               cap=0;
N			deep=lc640_read_int(CNT_EVENT_LOG);
X			deep=lc640_read_int(1024+1024+512+1024+2);
N			ptr=lc640_read_int(PTR_EVENT_LOG);
X			ptr=lc640_read_int(1024+1024+512+1024);
N
N			if(deep>63)
N				{
N				deep=0;
N			     ptr=0;
N			     }
N			
N			//out_usart0 (8,0x11,*((char*)&deep),*(((char*)&deep)+1),*((char*)&ptr),*(((char*)&ptr)+1),cap,content[cap-1],i,0);
N			
N			for(i=0;i<deep;i++)
N				{
N				lc640_read_long_ptr(EVENT_LOG+(32*ptr),av_head);
X				lc640_read_long_ptr(1024+(32*ptr),av_head);
N				
N				if((av_head[0]=='B')&&(av_head[1]==sub_ind1)&&(av_head[2]=='W')) 	//ищем записи батарейных событий 'W'(разряды)
X				if((av_head[0]=='B')&&(av_head[1]==a_ind . s_i1)&&(av_head[2]=='W')) 	
N					{
N					cap++;
N					content[cap-1]=ptr;
N					}
N					
N		   	/*   	out_usart0 (8,0x22,*((char*)&deep),*(((char*)&deep)+1),*((char*)&ptr),*(((char*)&ptr)+1),cap,content[cap-1],i,0); 
N				delay_ms(100);
N				PORTC.7=!PORTC.7;
N				#asm("wdr"); 	*/
N				ptr=ptr_carry(ptr,64,-1); 
N				} 
N				
N			/*ind=iJ_bat_wrk_sel;
N			sub_ind=0;*/
N
N			tree_up(iBatLogWrk,0,0,sub_ind1);
X			tree_up(iBatLogWrk,0,0,a_ind . s_i1);
N			
N			av_j_si_max=cap;
N			if(av_j_si_max>63)av_j_si_max=0;
N			} 
N		else if(but==butR)
X		else if(but==239)
N			{
N			//vz_mem_hndl(0,5);
N			//vz_mem_hndl(1,6);	       
N			} 
N		}		
N		 	         	
N     else if(sub_ind==6)
X     else if(a_ind . s_i==6)
N	     {
N	     if(but==butE)
X	     if(but==254)
N	          {
N			if(BAT_IS_ON[sub_ind1]!=bisON)tree_down(0,-4);
X			if(BAT_IS_ON[a_ind . s_i1]!=bisON)tree_down(0,-4);
N	          else tree_down(0,0);
N	          }
N	     }		     
N		
N	} 
N
Nelse if(ind==iBatLogVz)
Xelse if(a_ind . i==iBatLogVz)
N	{
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,av_j_si_max);
X		gran_char(&a_ind . s_i,0,av_j_si_max);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,av_j_si_max);
X		gran_char(&a_ind . s_i,0,av_j_si_max);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==av_j_si_max)
X		if(a_ind . s_i==av_j_si_max)
N			{
N			tree_down(0,0);
N			}
N		} 
N	else if(but==butL)
X	else if(but==247)
N		{
N		tree_down(0,0);
N		}		
N    //	else if(but==butR) vz_mem_hndl(sub_ind1,_sec);
N	
N		
N	}
N
Nelse if(ind==iBatLogKe)
Xelse if(a_ind . i==iBatLogKe)
N	{
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,av_j_si_max);
X		gran_char(&a_ind . s_i,0,av_j_si_max);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,av_j_si_max);
X		gran_char(&a_ind . s_i,0,av_j_si_max);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==av_j_si_max)
X		if(a_ind . s_i==av_j_si_max)
N			{
N			tree_down(0,0);
N			}
N		} 
N	else if(but==butL)
X	else if(but==247)
N		{
N		tree_down(0,0);
N		}		
N    //	else if(but==butR) ke_mem_hndl(sub_ind1,_sec);		
N	}
N
Nelse if(ind==iBatLogWrk)
Xelse if(a_ind . i==iBatLogWrk)
N	{
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,av_j_si_max);
X		gran_char(&a_ind . s_i,0,av_j_si_max);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,av_j_si_max);
X		gran_char(&a_ind . s_i,0,av_j_si_max);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		if(sub_ind==av_j_si_max)
X		if(a_ind . s_i==av_j_si_max)
N			{
N			tree_down(0,0);
N			}
N		else if(sub_ind<=av_j_si_max)
X		else if(a_ind . s_i<=av_j_si_max)
N			{
N			//ind=iWrk;
N			//sub_ind2=content[sub_ind];
N			index_set=0;
X			a_ind . i_s=0;
N			//sub_ind=0;
N			}	
N		} 
N	else if(but==butL)
X	else if(but==247)
N		{
N		tree_down(0,0);
N		}		
N	else if(but==butR)
X	else if(but==239)
N		{
N	    //	wrk_mem_hndl(sub_ind1);
N
N		} 
N	//int2lcdyx(BAT_TYPE[sub_ind1],0,2,0);
N	}
N
Nelse if(ind==iAv_view)
Xelse if(a_ind . i==iAv_view)
N	{
N	if(but==butE)
X	if(but==254)
N		{
N		avar_ind_stat&=~(1L<<sub_ind);
X		avar_ind_stat&=~(1L<<a_ind . s_i);
N		if(avar_ind_stat)
N			{
N			while(!(avar_ind_stat&(1<<sub_ind)))
X			while(!(avar_ind_stat&(1<<a_ind . s_i)))
N				{
N				sub_ind++;
X				a_ind . s_i++;
N				if(sub_ind>=32)
X				if(a_ind . s_i>=32)
N					{
N					tree_down(0,0);
N					avar_ind_stat=0;
N					}
N				}
N		 	}
N	 	else 
N			{
N			tree_down(0,0);
N			avar_ind_stat=0;
N			}
N		}
N 	}
N
N
N		
Nelse if(ind==iTst_VD)
Xelse if(a_ind . i==iTst_VD)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,10+NUMIST);
X		gran_char(&a_ind . s_i,0,10+NUMIST);
N		phase=0;
N		tst_state[0]=tstOFF;
N		tst_state[1]=tstOFF;
N		tst_state[2]=tstOFF;
N		tst_state[3]=tstOFF;
N		tst_state[4]=tstOFF;
N		tst_state[5]=tstOFF;
N		tst_state[6]=tstOFF;
N		tst_state[7]=tstOFF;
N		tst_state[8]=tstOFF;
N
N		if(sub_ind==1)
X		if(a_ind . s_i==1)
N			{
N			sub_ind=2;
X			a_ind . s_i=2;
N			index_set=1;
X			a_ind . i_s=1;
N			}
N		if(sub_ind==3)
X		if(a_ind . s_i==3)
N			{
N			sub_ind=4;
X			a_ind . s_i=4;
N			index_set=3;
X			a_ind . i_s=3;
N			}
N		if(sub_ind==5)
X		if(a_ind . s_i==5)
N			{
N			sub_ind=6;
X			a_ind . s_i=6;
N			index_set=5;
X			a_ind . i_s=5;
N			}
N		if(sub_ind==7)
X		if(a_ind . s_i==7)
N			{
N			sub_ind=8;
X			a_ind . s_i=8;
N			index_set=7;
X			a_ind . i_s=7;
N			}
N		}
N
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,10+NUMIST);
X		gran_char(&a_ind . s_i,0,10+NUMIST);
N		phase=0;
N		tst_state[0]=tstOFF;
N		tst_state[1]=tstOFF;
N		tst_state[2]=tstOFF;
N		tst_state[3]=tstOFF;
N		tst_state[4]=tstOFF;
N		tst_state[5]=tstOFF;
N		tst_state[6]=tstOFF;
N		tst_state[7]=tstOFF;
N		tst_state[8]=tstOFF;
N		
N		if(sub_ind==7)
X		if(a_ind . s_i==7)
N			{
N			sub_ind=6;
X			a_ind . s_i=6;
N			index_set=4;
X			a_ind . i_s=4;
N			} 
N		if(sub_ind==5)
X		if(a_ind . s_i==5)
N			{
N			sub_ind=4;
X			a_ind . s_i=4;
N			index_set=5;
X			a_ind . i_s=5;
N			} 
N		if(sub_ind==3)
X		if(a_ind . s_i==3)
N			{
N			sub_ind=2;
X			a_ind . s_i=2;
N			//index_set=5;
N			}
N		if(sub_ind==1)
X		if(a_ind . s_i==1)
N			{
N			sub_ind=0;
X			a_ind . s_i=0;
N			//index_set=5;
N			}
N		}
N
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if((but==butE)||(but==butR))
X		if((but==254)||(but==239))
N			{
N			if(tst_state[0]==tstOFF) tst_state[0]=tst1;
N			else if(tst_state[0]==tst1) tst_state[0]=tst2;
N			else tst_state[0]=tstOFF; 
N			}
N		else if(but==butL)
X		else if(but==247)
N			{
N			if(tst_state[0]==tst2) tst_state[0]=tst1;
N			else if(tst_state[0]==tstOFF) tst_state[0]=tst2;
N			else tst_state[0]=tstOFF; 
N			}
N		}
N		
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		if((but==butE)||(but==butR))
X		if((but==254)||(but==239))
N			{
N			if(tst_state[1]==tstOFF) tst_state[1]=tst1;
N			else if(tst_state[1]==tst1) tst_state[1]=tst2;
N			else tst_state[1]=tstOFF;
N			}
N		else if(but==butL)
X		else if(but==247)
N			{
N			if(tst_state[1]==tst2) tst_state[1]=tst1;
N			else if(tst_state[1]==tstOFF) tst_state[1]=tst2;
N			else tst_state[1]=tstOFF;
N			}
N		}
N			
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N		if((but==butE)||(but==butR))
X		if((but==254)||(but==239))
N			{
N			if(tst_state[2]==tstOFF) tst_state[2]=tst1;
N			else if(tst_state[2]==tst1) tst_state[2]=tst2;
N			else tst_state[2]=tstOFF;
N			}
N		else if(but==butL)
X		else if(but==247)
N			{
N			if(tst_state[2]==tst2) tst_state[2]=tst1;
N			else if(tst_state[2]==tstOFF) tst_state[2]=tst2;
N			else tst_state[2]=tstOFF;
N			}
N		}
N
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N		{
N		if((but==butE)||(but==butR))
X		if((but==254)||(but==239))
N			{
N			if(tst_state[3]==tstOFF) tst_state[3]=tst1;
N			else if(tst_state[3]==tst1) tst_state[3]=tst2;
N			else tst_state[3]=tstOFF;
N			}
N		else if(but==butL)
X		else if(but==247)
N			{
N			if(tst_state[3]==tst2) tst_state[3]=tst1;
N			else if(tst_state[3]==tstOFF) tst_state[3]=tst2;
N			else tst_state[3]=tstOFF;
N			}
N		}
N	else if((sub_ind>=8)&&(sub_ind<(8+NUMIST))&&(NUMIST)&&((but==butE)))	
X	else if((a_ind . s_i>=8)&&(a_ind . s_i<(8+NUMIST))&&(NUMIST)&&((but==254)))	
N		{
N		tree_up(iTst_bps,0,0,sub_ind-8);
X		tree_up(iTst_bps,0,0,a_ind . s_i-8);
N		can1_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
X		mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0x16,0x63,0,0,0,0);
N		tst_state[5]=tst1;
N		tst_state[6]=tstOFF;
N		}											
N
N	else if(sub_ind==(8+NUMIST))
X	else if(a_ind . s_i==(8+NUMIST))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	else if(sub_ind==(9+NUMIST))
X	else if(a_ind . s_i==(9+NUMIST))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			bRESET_INT_WDT=1;
N			}
N		}
N	else if(sub_ind==(10+NUMIST))
X	else if(a_ind . s_i==(10+NUMIST))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			bRESET_EXT_WDT=1;
N			}
N		}					
N	}
N#ifdef UKU_TELECORE2015
Selse if(ind==iTst_TELECORE)
S	{
S	ret(1000);
S	if(but==butD)
S		{
S		sub_ind++;
S		gran_char(&sub_ind,0,14+NUMIST);
S		phase=0;
S		tst_state[0]=tstOFF;
S		tst_state[1]=tstOFF;
S		tst_state[2]=tstOFF;
S		tst_state[3]=tstOFF;
S		tst_state[4]=tstOFF;
S		tst_state[5]=tstOFF;
S		tst_state[6]=tstOFF;
S		tst_state[7]=tstOFF;
S		tst_state[8]=tstOFF;
S		tst_state[9]=tstOFF;
S		tst_state[10]=(enum_tst_state)0;
S
S		if(sub_ind==1)
S			{
S			sub_ind=2;
S			index_set=1;
S			}
S		if(sub_ind==3)
S			{
S			sub_ind=4;
S			index_set=3;
S			}
S		if(sub_ind==5)
S			{
S			sub_ind=6;
S			index_set=5;
S			}
S		if(sub_ind==7)
S			{
S			sub_ind=8;
S			index_set=7;
S			}
S		if(sub_ind==9)
S			{
S			sub_ind=10;
S			index_set=9;
S			}
S		if(sub_ind==11)
S			{
S			sub_ind=12;
S			index_set=11;
S			}
S	/*	if(sub_ind==13)
S			{
S               sub_ind=14;
S			//index_set=9;
S			}*/
S/*		if(sub_ind==11)
S			{
S			sub_ind=12;
S			index_set=11;
S			}
S		if(sub_ind==13)
S			{
S			sub_ind=14;
S			index_set=13;
S			}   */
S		}
S
S	else if(but==butU)
S		{
S		sub_ind--;
S		gran_char(&sub_ind,0,14+NUMIST);
S		phase=0;
S		tst_state[0]=tstOFF;
S		tst_state[1]=tstOFF;
S		tst_state[2]=tstOFF;
S		tst_state[3]=tstOFF;
S		tst_state[4]=tstOFF;
S		tst_state[5]=tstOFF;
S		tst_state[6]=tstOFF;
S		tst_state[7]=tstOFF;
S		tst_state[8]=tstOFF;
S		tst_state[9]=tstOFF;
S		tst_state[10]=(enum_tst_state)0;
S
S/*		if(sub_ind==13)
S			{
S			sub_ind=12;
S			}		
S		if(sub_ind==11)
S			{
S			sub_ind=10;
S			}*/
S	/*	if(sub_ind==13)
S			{
S			sub_ind=12;
S			}*/
S		if(sub_ind==11)
S			{
S			sub_ind=10;
S			}
S		if(sub_ind==9)
S			{
S			sub_ind=8;
S			}
S		if(sub_ind==7)
S			{
S			sub_ind=6;
S			}
S		if(sub_ind==5)
S			{
S			sub_ind=4;
S			}
S		if(sub_ind==3)
S			{
S			sub_ind=2;
S			}
S		if(sub_ind==1)
S			{
S			sub_ind=0;
S			}
S		}
S
S	else if(sub_ind==0)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[0]==tstOFF) tst_state[0]=tst1;
S			else if(tst_state[0]==tst1) tst_state[0]=tst2;
S			else tst_state[0]=tstOFF; 
S			}
S		else if(but==butL)
S			{
S			if(tst_state[0]==tst2) tst_state[0]=tst1;
S			else if(tst_state[0]==tstOFF) tst_state[0]=tst2;
S			else tst_state[0]=tstOFF; 
S			}
S		}
S
S	else if(sub_ind==2)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[1]==tstOFF) tst_state[1]=tst1;
S			else if(tst_state[1]==tst1) tst_state[1]=tst2;
S			else tst_state[1]=tstOFF;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[1]==tst2) tst_state[1]=tst1;
S			else if(tst_state[1]==tstOFF) tst_state[1]=tst2;
S			else tst_state[1]=tstOFF;
S			}
S		}
S
S	else if(sub_ind==4)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[3]==tstOFF) tst_state[3]=tst1;
S			else if(tst_state[3]==tst1) tst_state[3]=tst2;
S			else tst_state[3]=tstOFF;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[3]==tst2) tst_state[3]=tst1;
S			else if(tst_state[3]==tstOFF) tst_state[3]=tst2;
S			else tst_state[3]=tstOFF;
S			}
S		}
S
S	else if(sub_ind==6)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[4]==tstOFF) tst_state[4]=tst1;
S			else if(tst_state[4]==tst1) tst_state[4]=tst2;
S			else tst_state[4]=tstOFF;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[4]==tst2) tst_state[4]=tst1;
S			else if(tst_state[4]==tstOFF) tst_state[4]=tst2;
S			else tst_state[4]=tstOFF;
S			}
S		}
S
S	else if(sub_ind==8)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[5]==tstOFF) tst_state[5]=tst1;
S			else if(tst_state[5]==tst1) tst_state[5]=tst2;
S			else tst_state[5]=tstOFF;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[5]==tst2) tst_state[5]=tst1;
S			else if(tst_state[5]==tstOFF) tst_state[5]=tst2;
S			else tst_state[5]=tstOFF;
S			}
S		}
S
S	else if(sub_ind==10)
S		{
S		if((but==butE)||(but==butR)||(but==butL))
S			{
S			if(tst_state[2]==tstOFF) tst_state[2]=tst1;
S			else tst_state[2]=tstOFF;
S			}
S		}
S
S	else if((sub_ind>=12)&&(sub_ind<(12+NUMIST))&&(NUMIST)&&((but==butE)))	
S		{
S		tree_up(iTst_bps,0,0,sub_ind-12);
S		can2_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
S		tst_state[5]=tst1;
S		tst_state[6]=tstOFF;
S		}											
S	else if(sub_ind==(12+NUMIST))
S		{
S		if(but==butE)
S			{
S			bRESET=1;
S			}
S	
S		}
S	else if(sub_ind==(13+NUMIST))
S		{
S		if(but==butE)
S			{
S			bRESET_EXT=1;
S			}
S	
S		}			
S	else if(sub_ind==(14+NUMIST))
S		{
S		if(but==butE)
S			{
S			tree_down(0,0);
S			ret(0);
S			}
S	
S		}	
S	}
N#endif
N
N#ifdef UKU_TELECORE2017
Selse if(ind==iTst_TELECORE)
S	{
S	ret(1000);
S	if(but==butD)
S		{
S		sub_ind++;
S		gran_char(&sub_ind,0,13+NUMIST);
S		phase=0;
S		tst_state[0]=tstOFF;
S		tst_state[1]=tstOFF;
S		tst_state[2]=tstOFF;
S		tst_state[3]=tstOFF;
S		tst_state[4]=tstOFF;
S		tst_state[5]=tstOFF;
S		tst_state[6]=tstOFF;
S		tst_state[7]=tstOFF;
S		tst_state[8]=tstOFF;
S		tst_state[9]=tstOFF;
S		tst_state[10]=(enum_tst_state)0;
S
S		if(sub_ind==1)
S			{
S			sub_ind=2;
S			index_set=1;
S			}
S		if(sub_ind==3)
S			{
S			sub_ind=4;
S			index_set=3;
S			}
S		if(sub_ind==5)
S			{
S			sub_ind=6;
S			index_set=5;
S			}
S		if(sub_ind==7)
S			{
S			sub_ind=8;
S			index_set=7;
S			}
S		if(sub_ind==9)
S			{
S			sub_ind=10;
S			index_set=9;
S			}
S		if(sub_ind==11)
S			{
S			sub_ind=12;
S			index_set=11;
S			}
S		}
S
S	else if(but==butU)
S		{
S		sub_ind--;
S		gran_char(&sub_ind,0,13+NUMIST);
S		phase=0;
S		tst_state[0]=tstOFF;
S		tst_state[1]=tstOFF;
S		tst_state[2]=tstOFF;
S		tst_state[3]=tstOFF;
S		tst_state[4]=tstOFF;
S		tst_state[5]=tstOFF;
S		tst_state[6]=tstOFF;
S		tst_state[7]=tstOFF;
S		tst_state[8]=tstOFF;
S		tst_state[9]=tstOFF;
S		tst_state[10]=(enum_tst_state)0;
S
S		if(sub_ind==11)
S			{
S			sub_ind=10;
S			}
S		if(sub_ind==9)
S			{
S			sub_ind=8;
S			}
S		if(sub_ind==7)
S			{
S			sub_ind=6;
S			}
S		if(sub_ind==5)
S			{
S			sub_ind=4;
S			}
S		if(sub_ind==3)
S			{
S			sub_ind=2;
S			}
S		if(sub_ind==1)
S			{
S			sub_ind=0;
S			}
S		}
S
S	else if(sub_ind==0)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[0]==tstOFF) tst_state[0]=tst1;
S			else if(tst_state[0]==tst1) tst_state[0]=tst2;
S			else tst_state[0]=tstOFF; 
S			}
S		else if(but==butL)
S			{
S			if(tst_state[0]==tst2) tst_state[0]=tst1;
S			else if(tst_state[0]==tstOFF) tst_state[0]=tst2;
S			else tst_state[0]=tstOFF; 
S			}
S		}
S
S	else if(sub_ind==2)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[1]==tstOFF) tst_state[1]=tst1;
S			else if(tst_state[1]==tst1) tst_state[1]=tst2;
S			else tst_state[1]=tstOFF;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[1]==tst2) tst_state[1]=tst1;
S			else if(tst_state[1]==tstOFF) tst_state[1]=tst2;
S			else tst_state[1]=tstOFF;
S			}
S		}
S
S	else if(sub_ind==4)
S		{
S		if((but==butE)||(but==butR))
S			{
S			if(tst_state[2]==tstOFF) tst_state[2]=tst1;
S			else if(tst_state[2]==tst1) tst_state[2]=tst2;
S			else tst_state[2]=tstOFF;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[2]==tst2) tst_state[2]=tst1;
S			else if(tst_state[2]==tstOFF) tst_state[2]=tst2;
S			else tst_state[2]=tstOFF;
S			}
S		}
S
S	else if(sub_ind==6)
S		{
S		if((but==butR))
S			{
S			if(tst_state[3]<5)tst_state[3]++;
S			else tst_state[3]=5;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[3]>0)tst_state[3]--;
S			else tst_state[3]=0;
S			}
S		}
S
S	else if(sub_ind==8)
S		{
S		if((but==butR))
S			{
S			if(tst_state[4]<5)tst_state[4]++;
S			else tst_state[4]=5;
S			}
S		else if(but==butL)
S			{
S			if(tst_state[4]>0)tst_state[4]--;
S			else tst_state[4]=0;
S			}
S		}
S
S	else if(sub_ind==10)
S		{
S		if((but==butE)||(but==butR)||(but==butL))
S			{
S			if(tst_state[5]==tstOFF) tst_state[5]=tst1;
S			else tst_state[5]=tstOFF;
S			}
S		}
S
S	else if((sub_ind>=12)&&(sub_ind<(12+NUMIST))&&(NUMIST)&&((but==butE)))	
S		{
S		tree_up(iTst_bps,0,0,sub_ind-12);
S		can2_out(sub_ind1,sub_ind1,CMND,ALRM_RES,0,0,0,0);
S		tst_state[5]=tst1;
S		tst_state[6]=tstOFF;
S		}											
S	else if(sub_ind==(12+NUMIST))
S		{
S		if(but==butE)
S			{
S			bRESET=1;
S			bRESET_INT_WDT=1;
S			bRESET_EXT_WDT=1;
S			}
S	
S		}
S	else if(sub_ind==(13+NUMIST))
S		{
S		if(but==butE)
S			{
S			tree_down(0,0);
S			ret(0);
S			}
S	
S		}	
S	}
N#endif
N
N
Nelse if(ind==iTst_bps)
Xelse if(a_ind . i==iTst_bps)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		tst_state[5]=tst1;
N		tst_state[6]=tstOFF;
N		
N		if(sub_ind==2)
X		if(a_ind . s_i==2)
N			{
N			sub_ind=3;
X			a_ind . s_i=3;
N			//index_set=2;
N			}
N
N		}
N
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		tst_state[5]=tst1;
N		tst_state[6]=tstOFF;
N		
N		if(sub_ind==2)
X		if(a_ind . s_i==2)
N			{
N			sub_ind=1;
X			a_ind . s_i=1;
N			//index_set=2;
N			}
N		}
N
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if(but==butR)
X		if(but==239)
N			{
N			if(tst_state[5]==tstOFF)tst_state[5]=tst1;
N			//else if(tst_state[5]==tst1)tst_state[5]=tst2;
N			else tst_state[5]=tstOFF;
N			}
N		else if(but==butL)
X		else if(but==247)
N			{
N			if(tst_state[5]==tstOFF)tst_state[5]=tst1;
N			//else if(tst_state[5]==tst1)tst_state[5]=tstOFF;
N			else tst_state[5]=tstOFF;
N			}
N		}
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if((but==butE)||(but==butR))
X		if((but==254)||(but==239))
N			{
N			if(tst_state[6]==tstOFF) tst_state[6]=tst1;
N			//else if(tst_state[6]==tst1) tst_state[6]=tst2;
N			else tst_state[6]=tstOFF;
N			}
N		else if(but==butL)
X		else if(but==247)
N			{
N			if(tst_state[6]==tstOFF) tst_state[6]=tst1;
N			//else if(tst_state[6]==tstOFF) tst_state[6]=tst2;
N			else tst_state[6]=tstOFF;
N			}
N		}		
N		
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}	
N	}
N
Nelse if(ind==iKlimat)
Xelse if(a_ind . i==iKlimat)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,7);
X		gran_char(&a_ind . s_i,0,7);
N	
N		}
N
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,7);
X		gran_char(&a_ind . s_i,0,7);
N		
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {
N	     if(but==butR)TBOXMAX++;
X	     if(but==239)TBOXMAX++;
N	     else if(but==butR_)TBOXMAX+=2;
X	     else if(but==111)TBOXMAX+=2;
N	     else if(but==butL)TBOXMAX--;
X	     else if(but==247)TBOXMAX--;
N	     else if(but==butL_)TBOXMAX-=2;
X	     else if(but==119)TBOXMAX-=2;
N	     gran(&TBOXMAX,50,80);
N	     lc640_write_int(EE_TBOXMAX,TBOXMAX);
X	     lc640_write_int(0x10+100+92,TBOXMAX);
N	     speed=1;
N	     }
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N	     {
N	     if(but==butR)TBOXVENTMAX++;
X	     if(but==239)TBOXVENTMAX++;
N	     else if(but==butR_)TBOXVENTMAX+=2;
X	     else if(but==111)TBOXVENTMAX+=2;
N	     else if(but==butL)TBOXVENTMAX--;
X	     else if(but==247)TBOXVENTMAX--;
N	     else if(but==butL_)TBOXVENTMAX-=2;
X	     else if(but==119)TBOXVENTMAX-=2;
N	     gran(&TBOXVENTMAX,49,81);
N	     lc640_write_int(EE_TBOXVENTMAX,TBOXVENTMAX);
X	     lc640_write_int(0x10+100+96,TBOXVENTMAX);
N	     speed=1;
N	     }
N
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N	     {
N	     if(but==butR)TBOXREG++;
X	     if(but==239)TBOXREG++;
N	     else if(but==butR_)TBOXREG+=2;
X	     else if(but==111)TBOXREG+=2;
N	     else if(but==butL)TBOXREG--;
X	     else if(but==247)TBOXREG--;
N	     else if(but==butL_)TBOXREG-=2;
X	     else if(but==119)TBOXREG-=2;
N	     gran(&TBOXREG,5,30);
N	     lc640_write_int(EE_TBOXREG,TBOXREG);
X	     lc640_write_int(0x10+100+94,TBOXREG);
N	     speed=1;
N	     }
N
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N	     {
N	     if(but==butR)TLOADDISABLE++;
X	     if(but==239)TLOADDISABLE++;
N	     else if(but==butR_)TLOADDISABLE+=2;
X	     else if(but==111)TLOADDISABLE+=2;
N	     else if(but==butL)TLOADDISABLE--;
X	     else if(but==247)TLOADDISABLE--;
N	     else if(but==butL_)TLOADDISABLE-=2;
X	     else if(but==119)TLOADDISABLE-=2;
N	     gran(&TLOADDISABLE,49,81);
N	     lc640_write_int(EE_TLOADDISABLE,TLOADDISABLE);
X	     lc640_write_int(0x10+100+98,TLOADDISABLE);
N	     speed=1;
N	     }
N
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N	     {
N	     if(but==butR)TLOADENABLE++;
X	     if(but==239)TLOADENABLE++;
N	     else if(but==butR_)TLOADENABLE+=2;
X	     else if(but==111)TLOADENABLE+=2;
N	     else if(but==butL)TLOADENABLE--;
X	     else if(but==247)TLOADENABLE--;
N	     else if(but==butL_)TLOADENABLE-=2;
X	     else if(but==119)TLOADENABLE-=2;
N	     gran(&TLOADENABLE,44,TLOADDISABLE-5);
N	     lc640_write_int(EE_TLOADENABLE,TLOADENABLE);
X	     lc640_write_int(0x10+100+100,TLOADENABLE);
N	     speed=1;
N	     }
N
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N	     {
N	     if(but==butR)TBATDISABLE++;
X	     if(but==239)TBATDISABLE++;
N	     else if(but==butR_)TBATDISABLE+=2;
X	     else if(but==111)TBATDISABLE+=2;
N	     else if(but==butL)TBATDISABLE--;
X	     else if(but==247)TBATDISABLE--;
N	     else if(but==butL_)TBATDISABLE-=2;
X	     else if(but==119)TBATDISABLE-=2;
N	     gran(&TBATDISABLE,49,91);
N	     lc640_write_int(EE_TBATDISABLE,TBATDISABLE);
X	     lc640_write_int(0x10+100+102,TBATDISABLE);
N	     speed=1;
N	     }
N
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N	     {
N	     if(but==butR)TBATENABLE++;
X	     if(but==239)TBATENABLE++;
N	     else if(but==butR_)TBATENABLE+=2;
X	     else if(but==111)TBATENABLE+=2;
N	     else if(but==butL)TBATENABLE--;
X	     else if(but==247)TBATENABLE--;
N	     else if(but==butL_)TBATENABLE-=2;
X	     else if(but==119)TBATENABLE-=2;
N	     gran(&TBATENABLE,44,TBATDISABLE-5);
N	     lc640_write_int(EE_TBATENABLE,TBATENABLE);
X	     lc640_write_int(0x10+100+104,TBATENABLE);
N	     speed=1;
N	     }
N	else if(sub_ind==7)
X	else if(a_ind . s_i==7)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	}
N
Nelse if(ind==iKlimat_kontur)
Xelse if(a_ind . i==iKlimat_kontur)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,9);
X		gran_char(&a_ind . s_i,0,9);
N	
N		}
N
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,9);
X		gran_char(&a_ind . s_i,0,9);
N		
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	     {
N	     if(but==butR)TBOXMAX++;
X	     if(but==239)TBOXMAX++;
N	     else if(but==butR_)TBOXMAX+=2;
X	     else if(but==111)TBOXMAX+=2;
N	     else if(but==butL)TBOXMAX--;
X	     else if(but==247)TBOXMAX--;
N	     else if(but==butL_)TBOXMAX-=2;
X	     else if(but==119)TBOXMAX-=2;
N	     gran(&TBOXMAX,50,80);
N	     lc640_write_int(EE_TBOXMAX,TBOXMAX);
X	     lc640_write_int(0x10+100+92,TBOXMAX);
N	     speed=1;
N	     }
N
N/*	else if(sub_ind==1)
N	     {
N	     if(but==butR)TBOXVENTON++;
N	     else if(but==butR_)TBOXVENTON+=2;
N	     else if(but==butL)TBOXVENTON--;
N	     else if(but==butL_)TBOXVENTON-=2;
N	     gran(&TBOXVENTON,TBOXVENTOFF+2,150);
N	     lc640_write_int(EE_TBOXVENTON,TBOXVENTON);
N	     speed=1;
N	     }
N
N	else if(sub_ind==2)
N	     {
N	     if(but==butR)TBOXVENTOFF++;
N	     else if(but==butR_)TBOXVENTOFF+=2;
N	     else if(but==butL)TBOXVENTOFF--;
N	     else if(but==butL_)TBOXVENTOFF-=2;
N	     gran(&TBOXVENTOFF,TBOXWARMOFF+2,TBOXVENTON-2);
N	     lc640_write_int(EE_TBOXVENTOFF,TBOXVENTOFF);
N	     speed=1;
N	     }  */
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N	     {
N	     if(but==butR)TBOXVENTMAX++;
X	     if(but==239)TBOXVENTMAX++;
N	     else if(but==butR_)TBOXVENTMAX+=2;
X	     else if(but==111)TBOXVENTMAX+=2;
N	     else if(but==butL)TBOXVENTMAX--;
X	     else if(but==247)TBOXVENTMAX--;
N	     else if(but==butL_)TBOXVENTMAX-=2;
X	     else if(but==119)TBOXVENTMAX-=2;
N	     gran(&TBOXVENTMAX,49,81);
N	     lc640_write_int(EE_TBOXVENTMAX,TBOXVENTMAX);
X	     lc640_write_int(0x10+100+96,TBOXVENTMAX);
N	     speed=1;
N	     }
N
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N	     {
N	     if(but==butR)TBOXREG++;
X	     if(but==239)TBOXREG++;
N	     else if(but==butR_)TBOXREG+=2;
X	     else if(but==111)TBOXREG+=2;
N	     else if(but==butL)TBOXREG--;
X	     else if(but==247)TBOXREG--;
N	     else if(but==butL_)TBOXREG-=2;
X	     else if(but==119)TBOXREG-=2;
N	     //gran(&TBOXREG,5,30);
N		gran(&TBOXREG,0,50);
N	     lc640_write_int(EE_TBOXREG,TBOXREG);
X	     lc640_write_int(0x10+100+94,TBOXREG);
N	     speed=1;
N	     }
N
N
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N	     {
N	     if(but==butR)TBOXWARMON++;
X	     if(but==239)TBOXWARMON++;
N	     else if(but==butR_)TBOXWARMON+=2;
X	     else if(but==111)TBOXWARMON+=2;
N	     else if(but==butL)TBOXWARMON--;
X	     else if(but==247)TBOXWARMON--;
N	     else if(but==butL_)TBOXWARMON-=2;
X	     else if(but==119)TBOXWARMON-=2;
N	     //gran(&TBOXWARMON,-20,20);
N		gran(&TBOXWARMON,-50,50);
N	     lc640_write_int(EE_TBOXWARMON,TBOXWARMON);
X	     lc640_write_int(0x10+100+132,TBOXWARMON);
N	     speed=1;
N	     }
N
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N	     {
N	     if(but==butR)TBOXWARMOFF++;
X	     if(but==239)TBOXWARMOFF++;
N	     else if(but==butR_)TBOXWARMOFF+=2;
X	     else if(but==111)TBOXWARMOFF+=2;
N	     else if(but==butL)TBOXWARMOFF--;
X	     else if(but==247)TBOXWARMOFF--;
N	     else if(but==butL_)TBOXWARMOFF-=2;
X	     else if(but==119)TBOXWARMOFF-=2;
N	     //gran(&TBOXWARMOFF,-20,20);
N		gran(&TBOXWARMOFF,-50,50);
N	     lc640_write_int(EE_TBOXWARMOFF,TBOXWARMOFF);
X	     lc640_write_int(0x10+100+134,TBOXWARMOFF);
N	     speed=1;
N	     }
N
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N	     {
N	     if(but==butR)TLOADDISABLE++;
X	     if(but==239)TLOADDISABLE++;
N	     else if(but==butR_)TLOADDISABLE+=2;
X	     else if(but==111)TLOADDISABLE+=2;
N	     else if(but==butL)TLOADDISABLE--;
X	     else if(but==247)TLOADDISABLE--;
N	     else if(but==butL_)TLOADDISABLE-=2;
X	     else if(but==119)TLOADDISABLE-=2;
N	     gran(&TLOADDISABLE,49,81);
N	     lc640_write_int(EE_TLOADDISABLE,TLOADDISABLE);
X	     lc640_write_int(0x10+100+98,TLOADDISABLE);
N	     speed=1;
N	     }
N
N	else if(sub_ind==6)
X	else if(a_ind . s_i==6)
N	     {
N	     if(but==butR)TLOADENABLE++;
X	     if(but==239)TLOADENABLE++;
N	     else if(but==butR_)TLOADENABLE+=2;
X	     else if(but==111)TLOADENABLE+=2;
N	     else if(but==butL)TLOADENABLE--;
X	     else if(but==247)TLOADENABLE--;
N	     else if(but==butL_)TLOADENABLE-=2;
X	     else if(but==119)TLOADENABLE-=2;
N	     gran(&TLOADENABLE,44,TLOADDISABLE-5);
N	     lc640_write_int(EE_TLOADENABLE,TLOADENABLE);
X	     lc640_write_int(0x10+100+100,TLOADENABLE);
N	     speed=1;
N	     }
N
N	else if(sub_ind==7)
X	else if(a_ind . s_i==7)
N	     {
N	     if(but==butR)TBATDISABLE++;
X	     if(but==239)TBATDISABLE++;
N	     else if(but==butR_)TBATDISABLE+=2;
X	     else if(but==111)TBATDISABLE+=2;
N	     else if(but==butL)TBATDISABLE--;
X	     else if(but==247)TBATDISABLE--;
N	     else if(but==butL_)TBATDISABLE-=2;
X	     else if(but==119)TBATDISABLE-=2;
N	     gran(&TBATDISABLE,49,91);
N	     lc640_write_int(EE_TBATDISABLE,TBATDISABLE);
X	     lc640_write_int(0x10+100+102,TBATDISABLE);
N	     speed=1;
N	     }
N
N	else if(sub_ind==8)
X	else if(a_ind . s_i==8)
N	     {
N	     if(but==butR)TBATENABLE++;
X	     if(but==239)TBATENABLE++;
N	     else if(but==butR_)TBATENABLE+=2;
X	     else if(but==111)TBATENABLE+=2;
N	     else if(but==butL)TBATENABLE--;
X	     else if(but==247)TBATENABLE--;
N	     else if(but==butL_)TBATENABLE-=2;
X	     else if(but==119)TBATENABLE-=2;
N	     gran(&TBATENABLE,44,TBATDISABLE-5);
N	     lc640_write_int(EE_TBATENABLE,TBATENABLE);
X	     lc640_write_int(0x10+100+104,TBATENABLE);
N	     speed=1;
N	     }
N	else if(sub_ind==9)
X	else if(a_ind . s_i==9)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	}
N#ifdef UKU_TELECORE2015
S else if(ind==iKlimat_TELECORE)
S	{
S	ret(1000);
S	if(but==butD)
S		{
S		sub_ind++;
S		if(sub_ind==1)
S			{
S			sub_ind++;
S			index_set=1;
S			}
S		gran_char(&sub_ind,0,11);
S		if(sub_ind==3)sub_ind++;
S		gran_char(&sub_ind,0,11);	
S		}
S
S	else if(but==butU)
S		{
S		sub_ind--;
S		if(sub_ind==1)sub_ind--;
S		gran_char(&sub_ind,0,11);
S		if(sub_ind==3)sub_ind--;
S		gran_char(&sub_ind,0,11);
S		
S		}
S	else if(sub_ind==0)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_WARM_SIGNAL++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_WARM_SIGNAL++;
S	     else if(but==butL)TELECORE2015_KLIMAT_WARM_SIGNAL--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_WARM_SIGNAL--;
S	     gran_ring(&TELECORE2015_KLIMAT_WARM_SIGNAL,0,1);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_WARM_SIGNAL,TELECORE2015_KLIMAT_WARM_SIGNAL);
S	     speed=1;
S	     }
S	else if(sub_ind==2)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_VENT_SIGNAL++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_VENT_SIGNAL++;
S	     else if(but==butL)TELECORE2015_KLIMAT_VENT_SIGNAL--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_VENT_SIGNAL--;
S	     gran_ring(&TELECORE2015_KLIMAT_VENT_SIGNAL,0,1);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_VENT_SIGNAL,TELECORE2015_KLIMAT_VENT_SIGNAL);
S	     speed=1;
S	     }
S	else if(sub_ind==4)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_WARM_ON++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_WARM_ON+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_WARM_ON--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_WARM_ON-=2;
S	     gran(&TELECORE2015_KLIMAT_WARM_ON,-20,50);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_WARM_ON,TELECORE2015_KLIMAT_WARM_ON);
S	     speed=1;
S	     }
S
S	else if(sub_ind==5)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_WARM_OFF++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_WARM_OFF+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_WARM_OFF--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_WARM_OFF-=2;
S	     gran(&TELECORE2015_KLIMAT_WARM_OFF,-20,50);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_WARM_OFF,TELECORE2015_KLIMAT_WARM_OFF);
S	     speed=1;
S	     }
S
S
S	else if(sub_ind==6)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_CAP++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_CAP+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_CAP--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_CAP-=2;
S	     //gran(&TBOXWARMON,-20,20);
S		gran(&TELECORE2015_KLIMAT_CAP,5,95);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_CAP,TELECORE2015_KLIMAT_CAP);
S	     speed=1;
S	     }
S
S	else if(sub_ind==7)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_VENT_ON++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_VENT_ON+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_VENT_ON--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_VENT_ON-=2;
S	     gran(&TELECORE2015_KLIMAT_VENT_ON,0,80);
S		gran(&TELECORE2015_KLIMAT_VENT_ON,TELECORE2015_KLIMAT_VENT_OFF,80);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_VENT_ON,TELECORE2015_KLIMAT_VENT_ON);
S	     speed=1;
S	     }
S
S	else if(sub_ind==8)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_VENT_OFF++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_VENT_OFF+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_VENT_OFF--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_VENT_OFF-=2;
S	     gran(&TELECORE2015_KLIMAT_VENT_OFF,0,80);
S		gran(&TELECORE2015_KLIMAT_VENT_OFF,0,TELECORE2015_KLIMAT_VENT_OFF);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_VENT_OFF,TELECORE2015_KLIMAT_VENT_OFF);
S	     speed=1;
S	     }
S	else if(sub_ind==9)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_VVENT_ON++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_VVENT_ON+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_VVENT_ON--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_VVENT_ON-=2;
S	     gran(&TELECORE2015_KLIMAT_VVENT_ON,0,80);
S		gran(&TELECORE2015_KLIMAT_VVENT_ON,TELECORE2015_KLIMAT_VVENT_OFF,80);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_VVENT_ON,TELECORE2015_KLIMAT_VVENT_ON);
S	     speed=1;
S	     }
S
S	else if(sub_ind==10)
S	     {
S	     if(but==butR)TELECORE2015_KLIMAT_VVENT_OFF++;
S	     else if(but==butR_)TELECORE2015_KLIMAT_VVENT_OFF+=2;
S	     else if(but==butL)TELECORE2015_KLIMAT_VVENT_OFF--;
S	     else if(but==butL_)TELECORE2015_KLIMAT_VVENT_OFF-=2;
S	     gran(&TELECORE2015_KLIMAT_VVENT_OFF,0,80);
S		gran(&TELECORE2015_KLIMAT_VVENT_OFF,0,TELECORE2015_KLIMAT_VVENT_OFF);
S	     lc640_write_int(EE_TELECORE2015_KLIMAT_VVENT_OFF,TELECORE2015_KLIMAT_VVENT_OFF);
S	     speed=1;
S	     }
S
S
S	else if(sub_ind==11)
S		{
S		if(but==butE)
S			{
S			tree_down(0,0);
S			ret(0);
S			}
S		}
S	}
N#endif
N#ifdef UKU_TELECORE2017
S else if(ind==iKlimat_TELECORE)
S	{
S	ret(1000);
S	if(but==butD)
S		{
S		sub_ind++;
S		if(sub_ind==1)
S			{
S			sub_ind++;
S			index_set=1;
S			}
S		gran_char(&sub_ind,0,17);
S		if(sub_ind==3)sub_ind++;
S		gran_char(&sub_ind,0,17);	
S		}
S
S	else if(but==butU)
S		{
S		sub_ind--;
S		if(sub_ind==1)sub_ind--;
S		gran_char(&sub_ind,0,17);
S 		}
S	else if(but==butLR_)
S		{
S		lc640_write_int(EE_TELECORE2017_KLIMAT_WARM_SIGNAL,0);
S		lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_SIGNAL,1);
S		lc640_write_int(EE_TELECORE2017_KLIMAT_WARM_ON,10);
S		lc640_write_int(EE_TELECORE2017_KLIMAT_WARM_OFF,30);
S		lc640_write_int(EE_TELECORE2017_KLIMAT_CAP,30);
S		//lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON0,30);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON20,40);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON40,50);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON60,60);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON80,70);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON100,80);
S	    //lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON0,10);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON20,20);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON40,30);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON60,40);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON80,50);
S	    lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON100,60);
S 		}
S
S	else if(sub_ind==0)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_WARM_SIGNAL++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_WARM_SIGNAL++;
S	     else if(but==butL)TELECORE2017_KLIMAT_WARM_SIGNAL--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_WARM_SIGNAL--;
S	     gran_ring(&TELECORE2017_KLIMAT_WARM_SIGNAL,0,1);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_WARM_SIGNAL,TELECORE2017_KLIMAT_WARM_SIGNAL);
S	     speed=1;
S	     }
S	else if(sub_ind==2)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_SIGNAL++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_SIGNAL++;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_SIGNAL--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_SIGNAL--;
S	     gran_ring(&TELECORE2017_KLIMAT_VENT_SIGNAL,0,1);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_SIGNAL,TELECORE2017_KLIMAT_VENT_SIGNAL);
S	     speed=1;
S	     }
S	else if(sub_ind==4)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_WARM_ON++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_WARM_ON+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_WARM_ON--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_WARM_ON-=2;
S	     gran(&TELECORE2017_KLIMAT_WARM_ON,-20,50);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_WARM_ON,TELECORE2017_KLIMAT_WARM_ON);
S	     speed=1;
S	     }
S
S	else if(sub_ind==5)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_WARM_OFF++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_WARM_OFF+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_WARM_OFF--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_WARM_OFF-=2;
S	     gran(&TELECORE2017_KLIMAT_WARM_OFF,-20,50);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_WARM_OFF,TELECORE2017_KLIMAT_WARM_OFF);
S	     speed=1;
S	     }
S
S
S	else if(sub_ind==6)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_CAP++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_CAP+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_CAP--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_CAP-=2;
S	     gran(&TELECORE2017_KLIMAT_CAP,5,95);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_CAP,TELECORE2017_KLIMAT_CAP);
S	     speed=1;
S	     }
S
S/*	else if(sub_ind==7)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_ON0++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_ON0+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_ON0--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_ON0-=2;
S		 gran(&TELECORE2017_KLIMAT_VENT_ON0,0,TELECORE2017_KLIMAT_VENT_ON20);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON0,TELECORE2017_KLIMAT_VENT_ON0);
S	     speed=1;
S	     }*/
S
S
S	else if(sub_ind==7)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_ON100++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_ON100+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_ON100--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_ON100-=2;
S		 gran(&TELECORE2017_KLIMAT_VENT_ON100,TELECORE2017_KLIMAT_VENT_ON80,100);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON100,TELECORE2017_KLIMAT_VENT_ON100);
S	     speed=1;
S	     }
S	else if(sub_ind==8)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_ON80++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_ON80+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_ON80--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_ON80-=2;
S		 gran(&TELECORE2017_KLIMAT_VENT_ON80,TELECORE2017_KLIMAT_VENT_ON60,TELECORE2017_KLIMAT_VENT_ON100);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON80,TELECORE2017_KLIMAT_VENT_ON80);
S	     speed=1;
S	     }
S
S
S	else if(sub_ind==9)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_ON60++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_ON60+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_ON60--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_ON60-=2;
S		 gran(&TELECORE2017_KLIMAT_VENT_ON60,TELECORE2017_KLIMAT_VENT_ON40,TELECORE2017_KLIMAT_VENT_ON80);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON60,TELECORE2017_KLIMAT_VENT_ON60);
S	     speed=1;
S	     }
S
S	else if(sub_ind==10)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_ON40++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_ON40+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_ON40--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_ON40-=2;
S		 gran(&TELECORE2017_KLIMAT_VENT_ON40,TELECORE2017_KLIMAT_VENT_ON20,TELECORE2017_KLIMAT_VENT_ON60);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON40,TELECORE2017_KLIMAT_VENT_ON40);
S	     speed=1;
S	     }
S
S	else if(sub_ind==11)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_VENT_ON20++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_VENT_ON20+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_VENT_ON20--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_VENT_ON20-=2;
S		 gran(&TELECORE2017_KLIMAT_VENT_ON20,0,TELECORE2017_KLIMAT_VENT_ON40);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_VENT_ON20,TELECORE2017_KLIMAT_VENT_ON20);
S	     speed=1;
S	     }
S
S/*	else if(sub_ind==12)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_DVENT_ON0++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_DVENT_ON0+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_DVENT_ON0--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_DVENT_ON0-=2;
S		 gran(&TELECORE2017_KLIMAT_DVENT_ON0,0,TELECORE2017_KLIMAT_DVENT_ON20);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON0,TELECORE2017_KLIMAT_DVENT_ON0);
S	     speed=1;
S	     }*/
S
S	else if(sub_ind==12)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_DVENT_ON100++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_DVENT_ON100+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_DVENT_ON100--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_DVENT_ON100-=2;
S		 gran(&TELECORE2017_KLIMAT_DVENT_ON100,TELECORE2017_KLIMAT_DVENT_ON80,100);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON100,TELECORE2017_KLIMAT_DVENT_ON100);
S	     speed=1;
S	     }
S
S	else if(sub_ind==13)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_DVENT_ON80++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_DVENT_ON80+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_DVENT_ON80--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_DVENT_ON80-=2;
S		 gran(&TELECORE2017_KLIMAT_DVENT_ON80,TELECORE2017_KLIMAT_DVENT_ON60,TELECORE2017_KLIMAT_DVENT_ON100);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON80,TELECORE2017_KLIMAT_DVENT_ON80);
S	     speed=1;
S	     }
S
S	else if(sub_ind==14)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_DVENT_ON60++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_DVENT_ON60+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_DVENT_ON60--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_DVENT_ON60-=2;
S		 gran(&TELECORE2017_KLIMAT_DVENT_ON60,TELECORE2017_KLIMAT_DVENT_ON40,TELECORE2017_KLIMAT_DVENT_ON80);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON60,TELECORE2017_KLIMAT_DVENT_ON60);
S	     speed=1;
S	     }
S
S	else if(sub_ind==15)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_DVENT_ON40++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_DVENT_ON40+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_DVENT_ON40--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_DVENT_ON40-=2;
S		 gran(&TELECORE2017_KLIMAT_DVENT_ON40,TELECORE2017_KLIMAT_DVENT_ON20,TELECORE2017_KLIMAT_DVENT_ON60);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON40,TELECORE2017_KLIMAT_DVENT_ON40);
S	     speed=1;
S	     }
S
S	else if(sub_ind==16)
S	     {
S	     if(but==butR)TELECORE2017_KLIMAT_DVENT_ON20++;
S	     else if(but==butR_)TELECORE2017_KLIMAT_DVENT_ON20+=2;
S	     else if(but==butL)TELECORE2017_KLIMAT_DVENT_ON20--;
S	     else if(but==butL_)TELECORE2017_KLIMAT_DVENT_ON20-=2;
S		 gran(&TELECORE2017_KLIMAT_DVENT_ON20,0,TELECORE2017_KLIMAT_DVENT_ON40);
S	     lc640_write_int(EE_TELECORE2017_KLIMAT_DVENT_ON20,TELECORE2017_KLIMAT_DVENT_ON20);
S	     speed=1;
S	     }
S
S	else if(sub_ind==17)
S		{
S		if(but==butE)
S			{
S			tree_down(0,0);
S			ret(0);
S			}
S		}
S	}
N#endif
Nelse if(ind==iNpn_set)
Xelse if(a_ind . i==iNpn_set)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N	
N		}
N
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N	    {
N	    if(NPN_OUT==npnoRELEVENT)NPN_OUT=npnoRELEAVBAT2;
N		else if(NPN_OUT==npnoRELEAVBAT2)NPN_OUT=npnoOFF;
N		else NPN_OUT=npnoRELEVENT;
N	    lc640_write_int(EE_NPN_OUT,NPN_OUT);
X	    lc640_write_int(0x10+100+116,NPN_OUT);
N	    
N	    }
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N	    {
N		if(NPN_OUT==npnoOFF)
N			{
N			if(but==butE)			
X			if(but==254)			
N				{
N				tree_down(0,0);
N				ret(0);
N				}
N			}
N		else
N			{
N			/*if(NPN_SIGN==npnsAVNET)NPN_SIGN=npnsULOAD;
N			else NPN_SIGN=npnsAVNET;
N			lc640_write_int(EE_NPN_SIGN,NPN_SIGN);*/
N
N			if(but==butR)UONPN++;
X			if(but==239)UONPN++;
N	     	else if(but==butR_)UONPN+=2;
X	     	else if(but==111)UONPN+=2;
N	     	else if(but==butL)UONPN--;
X	     	else if(but==247)UONPN--;
N	     	else if(but==butL_)UONPN-=2;
X	     	else if(but==119)UONPN-=2;
N	     	gran(&UONPN,100,2500);
N	     	lc640_write_int(EE_UONPN,UONPN);
X	     	lc640_write_int(0x10+100+120,UONPN);
N	     	speed=1;
N
N			}
N		}
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N/*		if(NPN_SIGN==npnsULOAD)
N			{
N			if(but==butR)UONPN++;
N	     	else if(but==butR_)UONPN+=2;
N	     	else if(but==butL)UONPN--;
N	     	else if(but==butL_)UONPN-=2;
N	     	gran(&UONPN,100,2500);
N	     	lc640_write_int(EE_UONPN,UONPN);
N	     	speed=1;
N			}
N		else 
N			{
N			if(but==butR)TZNPN++;
N	     	else if(but==butR_)TZNPN+=2;
N	     	else if(but==butL)TZNPN--;
N	     	else if(but==butL_)TZNPN-=2;
N	     	gran(&TZNPN,10,60);
N	     	lc640_write_int(EE_TZNPN,TZNPN);
N	     	speed=1;
N			}*/
N
N			if(but==butR)UVNPN++;
X			if(but==239)UVNPN++;
N	     	else if(but==butR_)UVNPN+=2;
X	     	else if(but==111)UVNPN+=2;
N	     	else if(but==butL)UVNPN--;
X	     	else if(but==247)UVNPN--;
N	     	else if(but==butL_)UVNPN-=2;
X	     	else if(but==119)UVNPN-=2;
N	     	gran(&UVNPN,100,2500);
N	     	lc640_write_int(EE_UVNPN,UVNPN);
X	     	lc640_write_int(0x10+100+122,UVNPN);
N	     	speed=1;
N		}
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N/*		if(NPN_SIGN==npnsULOAD)
N			{
N			if(but==butR)UVNPN++;
N	     	else if(but==butR_)UVNPN+=2;
N	     	else if(but==butL)UVNPN--;
N	     	else if(but==butL_)UVNPN-=2;
N	     	gran(&UVNPN,100,2500);
N	     	lc640_write_int(EE_UVNPN,UVNPN);
N	     	speed=1;
N			}
N		else 
N			{
N			if(but==butE)			
N				{
N				tree_down(0,0);
N				ret(0);
N				}
N			}*/
N			if(but==butR)TZNPN++;
X			if(but==239)TZNPN++;
N	     	else if(but==butR_)TZNPN+=2;
X	     	else if(but==111)TZNPN+=2;
N	     	else if(but==butL)TZNPN--;
X	     	else if(but==247)TZNPN--;
N	     	else if(but==butL_)TZNPN-=2;
X	     	else if(but==119)TZNPN-=2;
N	     	gran(&TZNPN,10,60);
N	     	lc640_write_int(EE_TZNPN,TZNPN);
X	     	lc640_write_int(0x10+100+124,TZNPN);
N	     	speed=1;
N		}
N	else if(sub_ind==4)
X	else if(a_ind . s_i==4)
N		{
N/*		if(NPN_SIGN==npnsULOAD)
N			{
N			if(but==butR)TZNPN++;
N	     	else if(but==butR_)TZNPN+=2;
N	     	else if(but==butL)TZNPN--;
N	     	else if(but==butL_)TZNPN-=2;
N	     	gran(&TZNPN,10,60);
N	     	lc640_write_int(EE_TZNPN,TZNPN);
N	     	speed=1;
N			}*/
N			if(but==butE)			
X			if(but==254)			
N				{
N				tree_down(0,0);
N				ret(0);
N				}
N		}
N	else if(sub_ind==5)
X	else if(a_ind . s_i==5)
N		{
N		if(NPN_SIGN==npnsULOAD)
N			{
N			if(but==butE)			
X			if(but==254)			
N				{
N				tree_down(0,0);
N				ret(0);
N				}
N			}
N		}
N
N
N	}
Nelse if(ind==iBps_list)
Xelse if(a_ind . i==iBps_list)
N	{
N	ret_ind(0,0,0);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind1--;
X		a_ind . s_i1--;
N		gran_char(&sub_ind1,0,NUMIST-2);
X		gran_char(&a_ind . s_i1,0,NUMIST-2);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind1++;
X		a_ind . s_i1++;
N		gran_char(&sub_ind1,0,NUMIST-2);
X		gran_char(&a_ind . s_i1,0,NUMIST-2);
N		}
N
N	else if (but==butD_)
X	else if (but==123)
N		{
N		sub_ind1=NUMIST-2;
X		a_ind . s_i1=NUMIST-2;
N		}
N				
N	else if(but==butR)
X	else if(but==239)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N				
N	else if(but==butL)
X	else if(but==247)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butE)
X	else if(but==254)
N		{
N		tree_down(0,0);
N		}
N		
N	else if(but==butE_)
X	else if(but==126)
N		{
N		if(bAVG_BLOCK) bAVG_BLOCK=0;
N		else bAVG_BLOCK=1;
N		}						
N	}
Nelse if(ind==iAvt_set_sel)
Xelse if(a_ind . i==iAvt_set_sel)
N	{
N	ret(1000);
N	if (but==butU)
X	if (but==253)
N		{      
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,NUMIST);
X		gran_char(&a_ind . s_i,0,NUMIST);
N		}
N		
N	else if (but==butD)
X	else if (but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,NUMIST);
X		gran_char(&a_ind . s_i,0,NUMIST);
N		}
N	else if((sub_ind>=0)&&(sub_ind<NUMIST))
X	else if((a_ind . s_i>=0)&&(a_ind . s_i<NUMIST))
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_up(iAvt_set,0,0,sub_ind);
X			tree_up(iAvt_set,0,0,a_ind . s_i);
N			}
N		}
N	else if(sub_ind==NUMIST)
X	else if(a_ind . s_i==NUMIST)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			}	
N		}
N	}
Nelse if(ind==iAvt_set)
Xelse if(a_ind . i==iAvt_set)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		if((sub_ind==1)||(sub_ind==2))sub_ind=3;
X		if((a_ind . s_i==1)||(a_ind . s_i==2))a_ind . s_i=3;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		if((sub_ind==1)||(sub_ind==2))sub_ind=0;
X		if((a_ind . s_i==1)||(a_ind . s_i==2))a_ind . s_i=0;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		phase=0;
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}
N 	else if (sub_ind == 0)
X 	else if (a_ind . s_i == 0)
N		{
N		temp_SS=lc640_read_int(EE_U_AVT);
X		temp_SS=lc640_read_int(0x10+100+80);
N		if(but==butR)temp_SS++;
X		if(but==239)temp_SS++;
N		else if(but==butR_)temp_SS+=2;
X		else if(but==111)temp_SS+=2;
N		else if(but==butL)temp_SS--;
X		else if(but==247)temp_SS--;
N		else if(but==butL_)temp_SS-=2;
X		else if(but==119)temp_SS-=2;
N		else if(but==butE_)can1_out(sub_ind1,sub_ind1,CMND,0xee,0xee,0,0,0);   
X		else if(but==126)mcp2515_transmit(a_ind . s_i1,a_ind . s_i1,0x16,0xee,0xee,0,0,0);   
N		
N		#ifdef UKU206_220				
S		gran(&temp_SS,1000,3000);
N		#endif
N
N		#ifdef UKU206_24
S		gran(&temp_SS,200,300);
N		#endif
N
N		#ifdef UKU320
S		gran(&temp_SS,400,800);
N		#endif
N
N		#ifdef UKU320_24
S		gran(&temp_SS,200,300);
N		#endif
N
N		#ifdef UKU320_F
S		gran(&temp_SS,400,800);
N		#endif		
N		lc640_write_int(EE_U_AVT,temp_SS);
X		lc640_write_int(0x10+100+80,temp_SS);
N		
N		speed=1;	
N					
N		}	
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			//a=b[--ptr_ind];
N			//sub_ind++;
N			tree_down(0,1);
N			ret(0);
N			}
N		}			
N
N	}
Nelse if(ind==iOut_volt_contr)
Xelse if(a_ind . i==iOut_volt_contr)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		gran_char(&sub_ind,0,3);
X		gran_char(&a_ind . s_i,0,3);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=3;
X		a_ind . s_i=3;
N		}
N	else if(sub_ind==3)
X	else if(a_ind . s_i==3)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if(but==butR)U_OUT_KONTR_MAX++;
X		if(but==239)U_OUT_KONTR_MAX++;
N		else if(but==butR_)U_OUT_KONTR_MAX=(U_OUT_KONTR_MAX/5+1)*5;
X		else if(but==111)U_OUT_KONTR_MAX=(U_OUT_KONTR_MAX/5+1)*5;
N		else if(but==butL)U_OUT_KONTR_MAX--;
X		else if(but==247)U_OUT_KONTR_MAX--;
N		else if(but==butL_)U_OUT_KONTR_MAX=(U_OUT_KONTR_MAX/5-1)*5;
X		else if(but==119)U_OUT_KONTR_MAX=(U_OUT_KONTR_MAX/5-1)*5;
N		gran(&U_OUT_KONTR_MAX,10,3000);
N		lc640_write_int(EE_U_OUT_KONTR_MAX,U_OUT_KONTR_MAX);
X		lc640_write_int(0x10+100+182,U_OUT_KONTR_MAX);
N		speed=1;
N		}				
N
N	else if(sub_ind==1)
X	else if(a_ind . s_i==1)
N		{
N		if(but==butR)U_OUT_KONTR_MIN++;
X		if(but==239)U_OUT_KONTR_MIN++;
N		else if(but==butR_)U_OUT_KONTR_MIN=(U_OUT_KONTR_MIN/5+1)*5;
X		else if(but==111)U_OUT_KONTR_MIN=(U_OUT_KONTR_MIN/5+1)*5;
N		else if(but==butL)U_OUT_KONTR_MIN--;
X		else if(but==247)U_OUT_KONTR_MIN--;
N		else if(but==butL_)U_OUT_KONTR_MIN=(U_OUT_KONTR_MIN/5-1)*5;
X		else if(but==119)U_OUT_KONTR_MIN=(U_OUT_KONTR_MIN/5-1)*5;
N		gran(&U_OUT_KONTR_MIN,10,3000);
N		lc640_write_int(EE_U_OUT_KONTR_MIN,U_OUT_KONTR_MIN);
X		lc640_write_int(0x10+100+184,U_OUT_KONTR_MIN);
N		speed=1;
N		}				
N
N
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		if(but==butR)U_OUT_KONTR_DELAY++;
X		if(but==239)U_OUT_KONTR_DELAY++;
N	    else if(but==butR_)U_OUT_KONTR_DELAY+=2;
X	    else if(but==111)U_OUT_KONTR_DELAY+=2;
N	    else if(but==butL)U_OUT_KONTR_DELAY--;
X	    else if(but==247)U_OUT_KONTR_DELAY--;
N	    else if(but==butL_)U_OUT_KONTR_DELAY-=2;
X	    else if(but==119)U_OUT_KONTR_DELAY-=2;
N	    gran(&U_OUT_KONTR_DELAY,5,100);
N	    lc640_write_int(EE_U_OUT_KONTR_DELAY,U_OUT_KONTR_DELAY);
X	    lc640_write_int(0x10+100+186,U_OUT_KONTR_DELAY);
N	    speed=1;
N		}				
N
N
N/*	
N	int2lcd(U_BAT_KONTR_MAX,'!',1);
N	int2lcd(U_BAT_KONTR_MIN,'@',1);
N	int2lcd(U_BAT_KONTR_DELAY,'#',0);
N	*/
N
N	}
N
Nelse if(ind==iDop_rele_set)
Xelse if(a_ind . i==iDop_rele_set)
N	{
N	ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind+=2;
X		a_ind . s_i+=2;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind-=2;
X		a_ind . s_i-=2;
N		gran_char(&sub_ind,0,2);
X		gran_char(&a_ind . s_i,0,2);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=2;
X		a_ind . s_i=2;
N		}
N	else if(sub_ind==2)
X	else if(a_ind . s_i==2)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			tree_down(0,0);
N			ret(0);
N			}
N		}
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if((but==butR)||(but==butR_))DOP_RELE_FUNC++;
X		if((but==239)||(but==111))DOP_RELE_FUNC++;
N		if((but==butL)||(but==butL_))DOP_RELE_FUNC--;
X		if((but==247)||(but==119))DOP_RELE_FUNC--;
N		gran(&DOP_RELE_FUNC,0,1);
N		lc640_write_int(EE_DOP_RELE_FUNC,DOP_RELE_FUNC);
X		lc640_write_int(0x10+100+188,DOP_RELE_FUNC);
N		speed=1;
N		}				
N	}
N
Nelse if (ind==iIps_Curr_Avg_Set)
Xelse if (a_ind . i==iIps_Curr_Avg_Set)
N	{
N     ret(1000);
N	if(but==butD)
X	if(but==251)
N		{
N		sub_ind++;
X		a_ind . s_i++;
N		sub_ind1=0;
X		a_ind . s_i1=0;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butU)
X	else if(but==253)
N		{
N		sub_ind--;
X		a_ind . s_i--;
N		sub_ind1=0;
X		a_ind . s_i1=0;
N		gran_char(&sub_ind,0,simax);
X		gran_char(&a_ind . s_i,0,simax);
N		}
N	else if(but==butD_)
X	else if(but==123)
N		{
N		sub_ind=simax;
X		a_ind . s_i=simax;
N		}			
N	else if(sub_ind==simax)
X	else if(a_ind . s_i==simax)
N		{
N		if(but==butE)tree_down(0,0);
X		if(but==254)tree_down(0,0);
N		}
N
N	else if(sub_ind==0)
X	else if(a_ind . s_i==0)
N		{
N		if(but==butE)
X		if(but==254)
N			{
N			if(ICA_EN)ICA_EN=0;
N			else ICA_EN=1;
N			lc640_write_int(EE_ICA_EN,ICA_EN);
X			lc640_write_int(0x10+350+6,ICA_EN);
N			}
N		}
N	else if(ICA_EN)
N		{
N		if(sub_ind==1)
X		if(a_ind . s_i==1)
N			{
N			if(but==butE)
X			if(but==254)
N				{
N				if(ICA_CH)ICA_CH=0;
N				else ICA_CH=1;
N				lc640_write_int(EE_ICA_CH,ICA_CH);
X				lc640_write_int(0x10+350+4,ICA_CH);
N				}
N			}
N		else if(ICA_CH==0)
N			{
N			if(sub_ind==2)
X			if(a_ind . s_i==2)
N				{
N				if((but==butR)||(but==butR_))
X				if((but==239)||(but==111))
N					{
N					ICA_MODBUS_ADDRESS++;
N					gran(&ICA_MODBUS_ADDRESS,1,254);
N					lc640_write_int(EE_ICA_MODBUS_ADDRESS,ICA_MODBUS_ADDRESS);
X					lc640_write_int(0x10+350+8,ICA_MODBUS_ADDRESS);
N					speed=1;
N					}
N				if((but==butL)||(but==butL_))
X				if((but==247)||(but==119))
N					{
N					ICA_MODBUS_ADDRESS--;
N					gran(&ICA_MODBUS_ADDRESS,1,254);
N					lc640_write_int(EE_ICA_MODBUS_ADDRESS,ICA_MODBUS_ADDRESS);
X					lc640_write_int(0x10+350+8,ICA_MODBUS_ADDRESS);
N					speed=1;
N					}
N				}
N			}
N
N		else if(ICA_CH==1)
N			{
N			if(sub_ind==2)
X			if(a_ind . s_i==2)
N				{
N				if((but==butE)||(but==butE_))
X				if((but==254)||(but==126))
N					{
N					sub_ind1++;
X					a_ind . s_i1++;
N					gran_ring_char(&sub_ind1,0,3);
X					gran_ring_char(&a_ind . s_i1,0,3);
N					}
N				else if(sub_ind1==0)
X				else if(a_ind . s_i1==0)
N					{
N					if((but==butR)||(but==butR_))
X					if((but==239)||(but==111))
N						{
N						ICA_MODBUS_TCP_IP1++;
N						gran_ring(&ICA_MODBUS_TCP_IP1,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP1,ICA_MODBUS_TCP_IP1);
X						lc640_write_int(0x10+350+10,ICA_MODBUS_TCP_IP1);
N						speed=1;
N						}
N					if((but==butL)||(but==butL_))
X					if((but==247)||(but==119))
N						{
N						ICA_MODBUS_TCP_IP1--;
N						gran(&ICA_MODBUS_TCP_IP1,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP1,ICA_MODBUS_TCP_IP1);
X						lc640_write_int(0x10+350+10,ICA_MODBUS_TCP_IP1);
N						speed=1;
N						}
N					}
N				else if(sub_ind1==1)
X				else if(a_ind . s_i1==1)
N					{
N					if((but==butR)||(but==butR_))
X					if((but==239)||(but==111))
N						{
N						ICA_MODBUS_TCP_IP2++;
N						gran_ring(&ICA_MODBUS_TCP_IP2,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP2,ICA_MODBUS_TCP_IP2);
X						lc640_write_int(0x10+350+12,ICA_MODBUS_TCP_IP2);
N						speed=1;
N						}
N					if((but==butL)||(but==butL_))
X					if((but==247)||(but==119))
N						{
N						ICA_MODBUS_TCP_IP2--;
N						gran(&ICA_MODBUS_TCP_IP2,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP2,ICA_MODBUS_TCP_IP2);
X						lc640_write_int(0x10+350+12,ICA_MODBUS_TCP_IP2);
N						speed=1;
N						}
N					}
N				else if(sub_ind1==2)
X				else if(a_ind . s_i1==2)
N					{
N					if((but==butR)||(but==butR_))
X					if((but==239)||(but==111))
N						{
N						ICA_MODBUS_TCP_IP3++;
N						gran_ring(&ICA_MODBUS_TCP_IP3,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP3,ICA_MODBUS_TCP_IP3);
X						lc640_write_int(0x10+350+14,ICA_MODBUS_TCP_IP3);
N						speed=1;
N						}
N					if((but==butL)||(but==butL_))
X					if((but==247)||(but==119))
N						{
N						ICA_MODBUS_TCP_IP3--;
N						gran(&ICA_MODBUS_TCP_IP3,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP3,ICA_MODBUS_TCP_IP3);
X						lc640_write_int(0x10+350+14,ICA_MODBUS_TCP_IP3);
N						speed=1;
N						}
N					}
N				else if(sub_ind1==3)
X				else if(a_ind . s_i1==3)
N					{
N					if((but==butR)||(but==butR_))
X					if((but==239)||(but==111))
N						{
N						ICA_MODBUS_TCP_IP4++;
N						gran_ring(&ICA_MODBUS_TCP_IP4,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP4,ICA_MODBUS_TCP_IP4);
X						lc640_write_int(0x10+350+16,ICA_MODBUS_TCP_IP4);
N						speed=1;
N						}
N					if((but==butL)||(but==butL_))
X					if((but==247)||(but==119))
N						{
N						ICA_MODBUS_TCP_IP4--;
N						gran(&ICA_MODBUS_TCP_IP4,0,255);
N						lc640_write_int(EE_ICA_MODBUS_TCP_IP4,ICA_MODBUS_TCP_IP4);
X						lc640_write_int(0x10+350+16,ICA_MODBUS_TCP_IP4);
N						speed=1;
N						}
N					}
N				}
N			if(sub_ind==3)
X			if(a_ind . s_i==3)
N				{
N				if((but==butR)||(but==butR_))
X				if((but==239)||(but==111))
N					{
N					ICA_MODBUS_TCP_UNIT_ID++;
N					gran(&ICA_MODBUS_TCP_UNIT_ID,1,254);
N					lc640_write_int(EE_ICA_MODBUS_TCP_UNIT_ID,ICA_MODBUS_TCP_UNIT_ID);
X					lc640_write_int(0x10+350+18,ICA_MODBUS_TCP_UNIT_ID);
N					speed=1;
N					}
N				if((but==butL)||(but==butL_))
X				if((but==247)||(but==119))
N					{
N					ICA_MODBUS_TCP_UNIT_ID--;
N					gran(&ICA_MODBUS_TCP_UNIT_ID,1,254);
N					lc640_write_int(EE_ICA_MODBUS_TCP_UNIT_ID,ICA_MODBUS_TCP_UNIT_ID);
X					lc640_write_int(0x10+350+18,ICA_MODBUS_TCP_UNIT_ID);
N					speed=1;
N					}
N				}
N			}
N		}
N
N
N  	} 
N
N		
Nbut_an_end:
Nn_but=0;
W "main.c" 14051 1 label "but_an_end" was declared but never referenced
N}
N
N//-----------------------------------------------
Nvoid watchdog_enable (void) 
N{
NLPC_WDT->WDTC=2000000;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDTC=2000000;
NLPC_WDT->WDCLKSEL=0;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDCLKSEL=0;
NLPC_WDT->WDMOD=3;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDMOD=3;
NLPC_WDT->WDFEED=0xaa;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDFEED=0xaa;
NLPC_WDT->WDFEED=0x55;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDFEED=0x55;
N}
N
N//-----------------------------------------------
Nvoid watchdog_reset (void) 
N{
NLPC_WDT->WDFEED=0xaa;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDFEED=0xaa;
NLPC_WDT->WDFEED=0x55;
X((LPC_WDT_TypeDef *) ((0x40000000UL) + 0x00000) )->WDFEED=0x55;
N}
N
N
N//***********************************************
N//***********************************************
N//***********************************************
N//***********************************************
N//***********************************************
Nvoid SysTick_Handler (void) 	 /* SysTick Interrupt Handler (1ms)    */
N{
N//sys_plazma++;
Nb2000Hz=1;
N
Nif(bTPS)
N	{
N	LPC_GPIO1->FIODIR|=(1UL<<26);
X	((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIODIR|=(1UL<<26);
N	LPC_GPIO1->FIOPIN^=(1UL<<26);
X	((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIOPIN^=(1UL<<26);
N	}
N
Nif(++t0cnt4>=2)
N	{
Nt0cnt4=0;
Nb1000Hz=1;
N
N	bFF=(char)(GET_REG(LPC_GPIO0->FIOPIN, 27, 1));
X	bFF=(char)(( (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00000) )->FIOPIN & ((0xffffffff>>(32-1))<<27)) >> 27));
N	if(bFF!=bFF_) hz_out++;
N	bFF_=bFF;
N
N
Nif(++t0cnt5>=40)
N     {
N     t0cnt5=0;
N     b50Hz=1;
N     }
N     
Nif(++t0cnt>=10)
N     {
N     t0cnt=0;
N     b100Hz=1;
N
N     hz_out_cnt++;
N     if(hz_out_cnt>=500)
N	     {	
N	     hz_out_cnt=0;
N	     net_F=hz_out;
N	     hz_out=0;
N	     }
N
N     if(++t0cnt0>=10)
N	     {
N	     t0cnt0=0;
N	     b10Hz=1;
N		beep_drv();
N		if(main_10Hz_cnt<10000) main_10Hz_cnt++;
N	     }
N
N     if(t0cnt0==5)
N	     {
N		//beep_drv();
N	     }
N
N     if(++t0cnt1>=20)
N	     {
N	     t0cnt1=0;
N	     b5Hz=1;
N		if(bFL5)bFL5=0;
N		else bFL5=1;     
N	     }
N
N     if(++t0cnt2>=50)
N	     {
N	     t0cnt2=0;
N	     b2Hz=1;
N		if(bFL2)bFL2=0;
N		else bFL2=1;
N
N	     }         
N
N     if(++t0cnt3>=100)
N	     {
N	     t0cnt3=0;
N	     b1Hz=1;
N		if(main_1Hz_cnt<10000) main_1Hz_cnt++;
N		if(bFL)bFL=0;
N		else bFL=1;
N
N		t0cntMin++;
N		if(t0cntMin>=60)
N			{
N			t0cntMin=0;
N			b1min=1;
N			}
N	     }
N     }
N
N	}
N
N
Nif(modbus_timeout_cnt<6)
N	{
N	modbus_timeout_cnt++;
N	if(modbus_timeout_cnt>=6)
N		{
N		bMODBUS_TIMEOUT=1;
N		}
N	}
Nelse if (modbus_timeout_cnt>6)
N	{
N	modbus_timeout_cnt=0;
N	bMODBUS_TIMEOUT=0;
N	}
N
N//LPC_GPIO0->FIOCLR|=0x00000001;
N  return;          
N
N
N
N//LPC_GPIO0->FIOCLR|=0x00000001;
N}
N
N
N//***********************************************
N__irq void timer0_interrupt(void) 
N{	
N/*if(BPS1_spa_leave)T0EMR_bit.EM1=0; 
Nelse T0EMR_bit.EM1=1;
Nif(BPS2_spa_leave)T0EMR_bit.EM3=0; 
Nelse T0EMR_bit.EM3=1;
NT0IR = 0xff;*/
N}
N
N//===============================================
N//===============================================
N//===============================================
N//===============================================
Nint main (void) 
N{
Nchar ind_reset_cnt=0;
N//long i;
Nchar mac_adr[6] = { 0x00,0x73,0x04,50,60,70 };
N
N//i=200000;
N//while(--i){};
N
NSystemInit();
N
NbTPS=1;
N
NSysTick->LOAD = (SystemFrequency / 2000) - 1;
X((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD = (SystemFrequency / 2000) - 1;
NSysTick->CTRL = 0x07;
X((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = 0x07;
N
N//init_timer( 0,SystemFrequency/2000/4 - 1 ); // 1ms	
N//enable_timer( 0 );
N
N//rs232_data_out_1();
N
Nbps[0]._state=bsOFF_AV_NET;
Nbps[1]._state=bsOFF_AV_NET;
Nbps[2]._state=bsOFF_AV_NET;
Nbps[3]._state=bsOFF_AV_NET;
Nbps[4]._state=bsOFF_AV_NET;
Nbps[5]._state=bsOFF_AV_NET;
Nbps[6]._state=bsOFF_AV_NET;
N
NSET_REG(LPC_GPIO0->FIODIR, 0, 27, 1);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00000) )->FIODIR = ( (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00000) )->FIODIR & ~((0xffffffff>>(32-1))<<27)) | (0 << 27) );
NSET_REG(LPC_GPIO2->FIODIR, 1, 7, 1);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR = ( (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR & ~((0xffffffff>>(32-1))<<7)) | (1 << 7) );
NSET_REG(LPC_GPIO2->FIODIR, 1, 8, 1);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR = ( (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR & ~((0xffffffff>>(32-1))<<8)) | (1 << 8) );
N//LPC_GPIO1->FIODIR  |= 1<<27;                
N	;
N//FIO1MASK = 0x00000000;	 
N//LPC_GPIO0->FIODIR  |= 1<<27;
N//LPC_GPIO0->FIOSET  |= 1<<27;
N
N///SET_REG(LPC_GPIO0->FIODIR,0,10,1); //вход частоты 
N#ifdef UKU2071x
NSET_REG(LPC_GPIO3->FIODIR,1,SHIFT_REL_AV_NET,1);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00060) )->FIODIR = ( (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00060) )->FIODIR & ~((0xffffffff>>(32-1))<<25)) | (1 << 25) );
NSET_REG(LPC_GPIO3->FIOCLR,1,SHIFT_REL_AV_NET,1);  // реле аварии сети под ток
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00060) )->FIOCLR = ( (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00060) )->FIOCLR & ~((0xffffffff>>(32-1))<<25)) | (1 << 25) );  
N#else 
SSET_REG(LPC_GPIO3->FIODIR,1,SHIFT_REL_AV_NET,1);
SSET_REG(LPC_GPIO3->FIOSET,1,SHIFT_REL_AV_NET,1);  // реле аварии сети под ток
N#endif
N
N
N
Nad7705_reset();
Ndelay_ms(20);
X{long xx; xx=(unsigned long)20 * 12000UL; while(xx)xx--;};
N
Nad7705_write(0x21);
Nad7705_write(BIN8(1101)); 
Xad7705_write((((0x1101) | 0x1101>>3 | 0x1101>>6 | 0x1101>>9) & 0xf | ((0x1101) | 0x1101>>3 | 0x1101>>6 | 0x1101>>9)>>12 & 0xf0)); 
Nad7705_write(0x11);
Nad7705_write(0x44);
N
N
Nad7705_buff[0][1]=0x7fff;
Nad7705_buff[0][2]=0x7fff;
Nad7705_buff[0][3]=0x7fff;
Nad7705_buff[0][4]=0x7fff;
Nad7705_buff[0][5]=0x7fff;
Nad7705_buff[0][6]=0x7fff;
Nad7705_buff[0][7]=0x7fff;
Nad7705_buff[0][8]=0x7fff;
Nad7705_buff[0][9]=0x7fff;
Nad7705_buff[0][10]=0x7fff;
Nad7705_buff[0][11]=0x7fff;
Nad7705_buff[0][12]=0x7fff;
Nad7705_buff[0][13]=0x7fff;
Nad7705_buff[0][14]=0x7fff;
Nad7705_buff[0][15]=0x7fff;
Nad7705_buff[1][1]=0x7fff;
Nad7705_buff[1][2]=0x7fff;
Nad7705_buff[1][3]=0x7fff;
Nad7705_buff[1][4]=0x7fff;
Nad7705_buff[1][5]=0x7fff;
Nad7705_buff[1][6]=0x7fff;
Nad7705_buff[1][7]=0x7fff;
Nad7705_buff[1][8]=0x7fff;
Nad7705_buff[1][9]=0x7fff;
Nad7705_buff[1][10]=0x7fff;
Nad7705_buff[1][11]=0x7fff;
Nad7705_buff[1][12]=0x7fff;
Nad7705_buff[1][13]=0x7fff;
Nad7705_buff[1][14]=0x7fff;
Nad7705_buff[1][15]=0x7fff;
N
Nad7705_buff_[0]=0x7fff;
Nad7705_buff_[1]=0x7fff;
N
N/*
Nad7705_reset();
Ndelay_ms(20);
N
Nad7705_write(0x20);
Nad7705_write(BIN8(1101)); 
Nad7705_write(0x10);
Nad7705_write(0x44);
N
Nad7705_reset();
Ndelay_ms(20);  
N
Nad7705_write(0x20);
Nad7705_write(BIN8(1101)); 
Nad7705_write(0x10);
Nad7705_write(0x44); 
N
Ndelay_ms(20); */
N
N
N
N
Nlcd_init();  
Nlcd_on();
Nlcd_clear();
N		
N///LPC_GPIO4->FIODIR |= (1<<29);           /* LEDs on PORT2 defined as Output    */
Nrtc_init();
N///pwm_init();
Nind=iMn_VD;
Xa_ind . i=iMn_VD;
N
N//snmp_plazma=15;
N
N
N//#ifdef ETHISON
N//mac_adr[5]=*((char*)&AUSW_MAIN_NUMBER);
N//mac_adr[4]=*(((char*)&AUSW_MAIN_NUMBER)+1);
N//mac_adr[3]=*(((char*)&AUSW_MAIN_NUMBER)+2);
N//mem_copy (own_hw_adr, mac_adr, 6);
N
N
N//if(lc640_read_int(EE_ETH_IS_ON)==1)
N	//{
N	bgnd_par(		"                    ",
N     		"    Инициализация   ",
N     		"      Ethernet      ",
N     		"                    ");
N	//bitmap_hndl();
N	//lcd_out(lcd_bitmap);
N	//init_TcpNet ();
N
N	//init_ETH();
N	//mem_copy (&localm[NETIF_ETH], &ip_config, sizeof(ip_config));
N
N//	}
N//#endif
N//event2snmp(2);
N
N
N//LPC_GPIO0->FIODIR |= (0x60000000);
N
Nadc_init();
N
NLPC_GPIO0->FIODIR|=(1<<11);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00000) )->FIODIR|=(1<<11);
NLPC_GPIO0->FIOSET|=(1<<11);
X((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00000) )->FIOSET|=(1<<11);
N
N
Nlc640_write_int(100,134);
N
N#ifndef MCP2515_CAN
Scan1_init(BITRATE62_5K25MHZ); 
Scan2_init(BITRATE125K25MHZ);
SFullCAN_SetFilter(1,0x0e9);
SFullCAN_SetFilter(0,0x18e);
N#endif
N
N
N
Nmemo_read();
N
N#ifndef UKU_220 
NUARTInit(0, (uint32_t)MODBUS_BAUDRATE*10UL);	/* baud rate setting */
N#endif
N
N#ifdef UKU_220 
SUART_2_Init((uint32_t)MODBUS_BAUDRATE*10UL);	/* baud rate setting */
SUARTInit(0, (uint32_t)MODBUS_BAUDRATE*10UL);	/* baud rate setting */
N#endif
N
N
Nmac_adr[5]=*((char*)&AUSW_MAIN_NUMBER);
Nmac_adr[4]=*(((char*)&AUSW_MAIN_NUMBER)+1);
Nmac_adr[3]=*(((char*)&AUSW_MAIN_NUMBER)+2);
Nmem_copy (own_hw_adr, mac_adr, 6);
N
Nsnmp_Community[0]=(char)lc640_read_int(EE_COMMUNITY); 
Xsnmp_Community[0]=(char)lc640_read_int(0x10+500+200+270); 
N//if((snmp_Community[0]==0)||(snmp_Community[0]==' '))snmp_Community[0]=0;
Nsnmp_Community[1]=(char)lc640_read_int(EE_COMMUNITY+2);
Xsnmp_Community[1]=(char)lc640_read_int(0x10+500+200+270+2);
Nif((snmp_Community[1]==0)||(snmp_Community[1]==' '))snmp_Community[1]=0;
Nsnmp_Community[2]=(char)lc640_read_int(EE_COMMUNITY+4);
Xsnmp_Community[2]=(char)lc640_read_int(0x10+500+200+270+4);
Nif((snmp_Community[2]==0)||(snmp_Community[2]==' '))snmp_Community[2]=0;
Nsnmp_Community[3]=(char)lc640_read_int(EE_COMMUNITY+6);
Xsnmp_Community[3]=(char)lc640_read_int(0x10+500+200+270+6);
Nif((snmp_Community[3]==0)||(snmp_Community[3]==' '))snmp_Community[3]=0;
Nsnmp_Community[4]=(char)lc640_read_int(EE_COMMUNITY+8);
Xsnmp_Community[4]=(char)lc640_read_int(0x10+500+200+270+8);
Nif((snmp_Community[4]==0)||(snmp_Community[4]==' '))snmp_Community[4]=0;
Nsnmp_Community[5]=(char)lc640_read_int(EE_COMMUNITY+10);
Xsnmp_Community[5]=(char)lc640_read_int(0x10+500+200+270+10);
Nif((snmp_Community[5]==0)||(snmp_Community[5]==' '))snmp_Community[5]=0;
Nsnmp_Community[6]=(char)lc640_read_int(EE_COMMUNITY+12);
Xsnmp_Community[6]=(char)lc640_read_int(0x10+500+200+270+12);
Nif((snmp_Community[6]==0)||(snmp_Community[6]==' '))snmp_Community[6]=0;
Nsnmp_Community[7]=(char)lc640_read_int(EE_COMMUNITY+14);
Xsnmp_Community[7]=(char)lc640_read_int(0x10+500+200+270+14);
Nif((snmp_Community[7]==0)||(snmp_Community[7]==' '))snmp_Community[7]=0;
Nsnmp_Community[8]=(char)lc640_read_int(EE_COMMUNITY+16);
Xsnmp_Community[8]=(char)lc640_read_int(0x10+500+200+270+16);
Nif((snmp_Community[8]==0)||(snmp_Community[8]==' '))snmp_Community[8]=0;
Nsnmp_Community[9]=0; /**/
N
Nif(lc640_read_int(EE_ETH_IS_ON)==1)
Xif(lc640_read_int(0x10+500+200)==1)
N	{
N	bgnd_par(		"                    ",
N     		"    Инициализация   ",
N     		"      Ethernet      ",
N     		"                    ");
N	bitmap_hndl();
N	lcd_out(lcd_bitmap);
N	init_TcpNet ();
N	lcd_out(lcd_bitmap);
N	init_ETH();
N	//mem_copy (&localm[NETIF_ETH], &ip_config, sizeof(ip_config));
N//	lcd_out(lcd_bitmap);
N	}
N//sys_plazma1=sys_plazma;
Nind_reset_cnt=58;
N
Nif(__ee_spc_stat==spcVZ)
N	{
N	if(__ee_vz_cnt)
N		{
N		spc_stat=spcVZ;  
N		vz_cnt_h=__ee_vz_cnt/60;
N		vz_cnt_h_=(lc640_read_int(EE_SPC_VZ_LENGT)-__ee_vz_cnt)/60;
X		vz_cnt_h_=(lc640_read_int(0x10+480+14)-__ee_vz_cnt)/60;
W "main.c" 14436 15 pointless comparison of unsigned integer with zero
N		if(vz_cnt_h_<0)vz_cnt_h_=0;
N		vz_cnt_s_=(short)(((lc640_read_int(EE_SPC_VZ_LENGT)-__ee_vz_cnt)*60)%3600UL);
X		vz_cnt_s_=(short)(((lc640_read_int(0x10+480+14)-__ee_vz_cnt)*60)%3600UL);
N
N		vz_cnt_s=0;
N		}
N	}
Nelse if(__ee_spc_stat==spcKE)
N	{
N	spc_stat=spcKE;
N	spc_bat=__ee_spc_bat;
N	bat[spc_bat]._zar_cnt_ke=0;
N	spc_phase=__ee_spc_phase;
N	}
Nwatchdog_enable();
Nif((AUSW_MAIN==2400)||(AUSW_MAIN==4800)||(AUSW_MAIN==6000)||(BAT_TYPE==1))
N	{
N	cntrl_stat=350;
N	cntrl_stat_old=350;
N	}
N
N#ifdef UKU_TELECORE2015
Scntrl_stat=0;
Scntrl_stat_old=0;
N#endif
N
N
N#ifdef UKU_TELECORE2017
S{
Ssigned short tempSS,tempSS1;
StempSS=0;
StempSS1=0;
StempSS=ULAUNCH;
Sif(ULAUNCH<420)tempSS=420;
Sif(ULAUNCH>540)tempSS=540;
StempSS-=420;
StempSS*=100;
StempSS/=12;
S
Scntrl_stat=tempSS;
Sgran(&cntrl_stat,100,1000);
Scntrl_stat_old=0;
S//cntrl_stat=500;
S}
N#endif
N
N#ifdef UKU_220_IPS_TERMOKOMPENSAT
Ncntrl_stat=10*PWM_START;
Ncntrl_stat_old=10*PWM_START;
N#endif
N
N
N//ind=iDeb;
N//sub_ind=6;
N#ifdef MCP2515_CAN
Ncan_mcp2515_init();
N#endif
N
N#ifdef SC16IS740_UART
W "main.c" 14494 1 function "sc16is700_init" declared implicitly
Nsc16is700_init((uint32_t)(MODBUS_BAUDRATE*10UL));
N#endif
N//sc16is700_init();
N
Nreload_hndl();
N
Nsocket_tcp = tcp_get_socket (TCP_TYPE_SERVER, 0, 10, tcp_callback);
Xsocket_tcp = tcp_get_socket (0x01, 0, 10, tcp_callback);
Nif (socket_tcp != 0) 
N	{
N    tcp_listen (socket_tcp, 502);
N  	}
N
NUOUT_=UOUT;
N
N//lc640_write_int(EE_RELE_SET_MASK0,25);
N  		
Nwhile (1)  
N	{
N	bTPS=0; 
N     //timer_poll ();
N     main_TcpNet ();
N
N	//watchdog_reset();
N#ifdef MCP2515_CAN
N	if(bMCP2515_IN)
N		{
N		bMCP2515_IN=0;
W "main.c" 14521 3 function "can_in_an1" declared implicitly
N		can_in_an1();
N		}
N#endif
N	if(bMODBUS_TIMEOUT)
N		{
N		bMODBUS_TIMEOUT=0;
N		//modbus_plazma++;;
W "main.c" 14528 3 function "modbus_in" declared implicitly
N		modbus_in();
N		}
N
N	if(bRXIN0) 
N		{
N		bRXIN0=0;
N	
N		uart_in0();
N		} 
N
N/*	if(bRXIN_SC16IS700) 
N		{
N		bRXIN_SC16IS700=0;
N	
N		uart_in_SC16IS700();
N		}*/
N
N	/*
N	if(bRXIN1) 
N		{
N		bRXIN1=0;
N	
N		uart_in1();
N		}*/ 
N     if(b10000Hz)
N		{
N		b10000Hz=0; 
N		
N
N		}
N
N     if(b2000Hz)
N		{
N
N		if(adc_window_cnt<200)adc_window_cnt++;
N
N		b2000Hz=0; 
N		adc_drv7();
N		
N		}
N
N	if(b1000Hz)
N		{
N		b1000Hz=0;
N		#ifdef MCP2515_CAN
N		can_mcp2515_hndl();
N		//mcp2515_read_status();
N		#endif
N
N		#ifdef SC16IS740_UART
W "main.c" 14578 3 function "sc16is700_uart_hndl" declared implicitly
N		sc16is700_uart_hndl();
N		#endif		
N		}
N	
N	if(b100Hz)
N		{
N		b100Hz=0;
N
N		//LPC_GPIO2->FIODIR|=(1<<7);
N		//LPC_GPIO2->FIOPIN^=(1<<7);		
N
N		if((!bRESET_INT_WDT)&&(!bRESET_EXT_WDT))but_drv();
N		but_an();
N		}
N		 
N	if(b50Hz)
N		{
N		b50Hz=0;
N		//#ifdef MCP2515_CAN
N		//net_drv_mcp2515();
N		//#endif
N		//#ifndef MCP2515_CAN
N		net_drv();
N		//#endif
N		}
N
N	if(b10Hz)
N		{
N		char i;
N
N     timer_tick ();
N     tick = __TRUE;
X     tick = 1;
N
N		b10Hz=0;
N				
N		u_necc_hndl();
N		
N		for(i=0;i<NUMIST;i++)bps_drv(i);
N		bps_hndl();
N
N		//inv_search();
N		
N		//if(NUMINV) {for(i=0;i<NUMINV;i++)inv_drv(i);}		  
N		
N		//nv[0]._Uii=123;
N
N
N		
N		ind_hndl(); 
N		#ifndef SIMULATOR
N		bitmap_hndl();
N		if(!bRESET_EXT_WDT)
N			{
N			lcd_out(lcd_bitmap);
N			}
N		#endif
N		//ad7705_drv();
N		//ad7705_write(0x20);
N
N		adc_window_cnt=0;  
N
N		ret_hndl();  
N		mess_hndl();
N
N		cntrl_hndl();
N			  
N
N		//ret_hndl();
N		ext_drv();
N		avt_hndl();
N		
W "main.c" 14649 3 function "u_avar_hndl" declared implicitly
N		u_avar_hndl();
W "main.c" 14650 3 function "t_sys_avar_hndl" declared implicitly
N		t_sys_avar_hndl();
W "main.c" 14651 3 function "overload_hndl" declared implicitly
N		overload_hndl();
N		}
N
N	if(b5Hz)
N		{
N		b5Hz=0;
N
N		if(!bRESET_EXT_WDT)
N			{
N			ad7705_drv();
N			}
N		if(!bRESET_EXT_WDT)
N			{
N			
N			}  memo_read();
N		LPC_GPIO1->FIODIR|=(1UL<<26);
X		((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00020) )->FIODIR|=(1UL<<26);
N		matemat();
N		
W "main.c" 14669 3 function "rele_av_hndl" declared implicitly
N		rele_av_hndl();
N		rele_hndl();
N		if(!bRESET_EXT_WDT)avar_hndl();
N		zar_superviser_drv();
N		snmp_data();
N		//LPC_GPIO1->FIODIR|=(1UL<<31);
N		//LPC_GPIO1->FIOPIN^=(1UL<<31);
N
N 		cntrl_hndl();
N  		}
N
N	if(b2Hz)
N		{
N		b2Hz=0;
N
N				//uart_out_adr1(dig,150);
N		//sc16is700_wr_buff(CS16IS7xx_THR, 20);
N
N		//sc16is700_wr_byte(CS16IS7xx_LCR, 0x80);
N		//can1_out(cnt_net_drv,cnt_net_drv,GETTM,bps[cnt_net_drv]._flags_tu,*((char*)(&bps[cnt_net_drv]._vol_u)),*((char*)((&bps[cnt_net_drv]._vol_u))+1),*((char*)(&bps[cnt_net_drv]._vol_i)),*((char*)((&bps[cnt_net_drv]._vol_i))+1));
N  		}
N
N	if(b1Hz)
N		{
N		b1Hz=0;
N		if(!bRESET_INT_WDT)
N			{
N			watchdog_reset();
N			}
N		//can1_out_adr((char*)&net_U,21);
N
N		samokalibr_hndl();
N		num_necc_hndl();
N		//zar_drv();
N		ubat_old_drv();
N		beep_hndl();
N		avg_hndl();
W "main.c" 14706 3 function "u_out_reg_hndl" declared implicitly
N		u_out_reg_hndl();
N		//vz_drv();	 
N		//avz_drv();
N		//ke_drv();
N	
N		vent_hndl();
N
N		plazma_plazma_plazma++;
N
N		if(++ind_reset_cnt>=60)
N			{
N			ind_reset_cnt=0;
N			lcd_init();
N			lcd_on();
N			lcd_clear();
N			}
N               
N          vent_hndl();
N
N
N		  
N		if(t_ext_can_nd<10) t_ext_can_nd++;
N		
N		//if(main_1Hz_cnt<200)main_1Hz_cnt++;
N
N
N		can_reset_hndl();
W "main.c" 14733 3 function "npn_hndl" declared implicitly
N		npn_hndl();
N/*		#ifdef UKU_220_IPS_TERMOKOMPENSAT
N		if((AUSW_MAIN==22063)||(AUSW_MAIN==22023)||(AUSW_MAIN==22043))rs232_data_out_tki();
N		else if(AUSW_MAIN==22010)rs232_data_out_1();
N		else rs232_data_out();
N		#endif */	
N 
N		//modbus_registers_transmit(MODBUS_ADRESS,4,0,5);
N		
N	/*	putchar2(0x56);
N		putchar2(0x57);
N		putchar2(0x58);
N		putchar2(0x59);
N		putchar2(0x5a);*/
N
W "main.c" 14748 3 function "powerAntiAliasingHndl" declared implicitly
N		powerAntiAliasingHndl();
N
N		//outVoltContrHndl();
N
N		
N		vent_resurs_hndl();
N		
N
N		ips_current_average_hndl();
W "main.c" 14757 3 function "vd_is_work_hndl" declared implicitly
N		vd_is_work_hndl();
N		}
N	if(b1min)
N		{
N		b1min=0;
N
N		if((tloaddisable_cmnd)&&(tloaddisable_cmnd<=10))
N			{
N			tloaddisable_cmnd--;
N			if(!tloaddisable_cmnd)tloaddisable_cmnd=20;
N			}
N		if((tbatdisable_cmnd)&&(tbatdisable_cmnd<=10))
N			{
N			if(!tbatdisable_cmnd)tbatdisable_cmnd=20;
N			}
N		
W "main.c" 14773 3 function "numOfForvardBps_hndl" declared implicitly
N		numOfForvardBps_hndl();			//Программа смены первого источника для равномерного износа БПСов
N		}
N
N	}
N}
W "main.c" 790 13 function "timer_poll" was declared but never referenced
